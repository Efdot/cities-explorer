<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Cities by Efdot x Diid | Explorer</title>
    <meta name="description" content="Explore the Cities generative art collection by Efdot x Diid on Art Blocks. Browse 500 unique city maps, filter by traits, and discover collectors.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Cities by Efdot x Diid | Explorer">
    <meta property="og:description" content="Explore the Cities generative art collection. Browse unique city maps, filter by traits, and discover collectors.">
    <meta property="og:image" content="https://media-proxy.artblocks.io/1/0x7c78f67700e700b4005c8a3d920a1a99e6004800/0.png">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cities by Efdot x Diid | Explorer">
    <meta name="twitter:description" content="Explore the Cities generative art collection. Browse unique city maps, filter by traits, and discover collectors.">
    <meta name="twitter:image" content="https://media-proxy.artblocks.io/1/0x7c78f67700e700b4005c8a3d920a1a99e6004800/0.png">

    <!-- Preconnect to critical API endpoints -->
    <link rel="preconnect" href="https://data.artblocks.io" crossorigin>
    <link rel="preconnect" href="https://token.artblocks.io" crossorigin>
    <link rel="dns-prefetch" href="https://api.ensideas.com">

    <!-- Preconnect to image CDNs for faster loading -->
    <link rel="preconnect" href="https://blush-worried-heron-358.mypinata.cloud" crossorigin>
    <link rel="preconnect" href="https://ipfs.io" crossorigin>
    <link rel="preconnect" href="https://images.squarespace-cdn.com" crossorigin>
    <link rel="preconnect" href="https://f8n-production-collection-assets.imgix.net" crossorigin>
    <link rel="preconnect" href="https://nft-cdn.alchemy.com" crossorigin>
    <link rel="preconnect" href="https://images.ninfa.io" crossorigin>
    <link rel="preconnect" href="https://media-proxy.artblocks.io" crossorigin>

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒ†</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒ†</text></svg>">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00E5CC">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- Preload splash screen asset for instant display -->
    <link rel="preload" href="loading-goo.gif" as="image">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* Disable transitions during resize for performance */
        body.resizing * { transition: none !important; animation: none !important; }

        /* Focus states for accessibility */
        :focus { outline: none; }
        :focus-visible { outline: 2px solid var(--teal); outline-offset: 2px; }
        button:focus-visible, a:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--teal);
            outline-offset: 2px;
        }

        :root {
            --bg-deep: #0A0910;
            --bg-panel: #14131c;
            --bg-card: #1e1d28;
            --bg-input: #28273a;
            --border: #363550;
            --text: #fff;
            --text-dim: #a0a0c0;
            --text-muted: #8888a8;
            --teal: #E8B86D; /* warm gold - was teal */
            --yellow: #FFE135;
            --pink: #D4A574; /* muted warm - was pink */
            --blue: #00B4FF;
            --purple: #B967FF;
            --orange: #FF8C42;
            --mint: #D4A574; /* muted warm tone */
            --warm: #E8B86D; /* warm gold accent */
        }

        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-deep);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            overflow: hidden;
            letter-spacing: 0.02em;
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        .app-wrapper { display: flex; width: 100%; height: 100vh; }

        /* Prevent iOS zoom on input focus */
        input, select, textarea { font-size: 16px !important; }

        .bg-bubbles { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; overflow: hidden; z-index: 0; }
        .bubble { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.15; transition: background 1s ease-out; }
        .bubble-1 { width: 400px; height: 400px; background: var(--warm); top: -100px; right: -100px; }
        .bubble-2 { width: 300px; height: 300px; background: var(--orange); bottom: -50px; left: 20%; animation-delay: -5s; }
        .bubble-3 { width: 250px; height: 250px; background: var(--yellow); top: 40%; right: 10%; animation-delay: -10s; }
        @keyframes float { 0%, 100% { transform: translate(0, 0) scale(1); } 33% { transform: translate(30px, -30px) scale(1.05); } 66% { transform: translate(-20px, 20px) scale(0.95); } }

        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 300px;
            background: var(--bg-panel);
            padding: 20px 20px;
            padding-bottom: 64px;
            overflow-y: auto;
            height: 100vh;
            z-index: 100;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .sidebar h1 { font-size: 28px; font-weight: 700; text-transform: none; letter-spacing: 0.02em; margin-bottom: 4px; color: #fff; font-family: Helvetica, Arial, sans-serif; cursor: pointer; transition: opacity 0.2s ease; }
        .sidebar h1:hover { opacity: 0.7; }
        .artist-logos { display: flex; align-items: center; gap: 6px; margin-bottom: 14px; }
        .artist-logo { height: 17px; width: auto; opacity: 0; transition: all 0.3s ease; filter: brightness(0) invert(1); cursor: pointer; }
        .artist-logos .logo-x { opacity: 0; transition: opacity 0.3s ease; }
        /* Show logos on hover over the brand area (desktop only) */
        @media (min-width: 769px) {
            .sidebar h1:hover ~ .artist-logos .artist-logo,
            .sidebar h1:hover ~ .artist-logos .logo-x,
            .artist-logos:hover .artist-logo,
            .artist-logos:hover .logo-x { opacity: 0.5; }
        }
        @media (max-width: 768px) {
            /* Logos hidden on mobile - shown in action sheet footer */
            .artist-logo, .artist-logos .logo-x { opacity: 0; pointer-events: none; }
            .artist-logos { display: none; }
            .sidebar h1 { display: none; }
        }
        .artist-logo:hover { opacity: 0.9; filter: brightness(0) invert(1) drop-shadow(0 0 8px rgba(212, 165, 116, 0.5)); }
        .artist-logo.ef-logo:hover { animation: logoWiggle 0.4s ease-in-out; }
        .artist-logo.diid-logo { height: 22px; position: relative; top: 0px; }
        .sidebar-about-link { display: inline-block; opacity: 0.4; text-decoration: none; transition: all 0.3s ease; margin-left: 8px; }
        .sidebar-about-link:hover { opacity: 0.8; }
        .sidebar-about-link img { height: 18px; width: auto; filter: brightness(0) invert(1); transition: all 0.3s ease; }
        .sidebar-about-link:hover img { filter: brightness(0) invert(1) drop-shadow(0 0 4px rgba(255,255,255,0.3)); }
        @keyframes logoWiggle { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } }
        .efdot-shop-fixed { position: fixed; bottom: 24px; right: 24px; height: 28px; width: auto; opacity: 0.25; transition: all 0.3s ease; cursor: pointer; z-index: 99; filter: brightness(0) invert(0.5); }
        .efdot-shop-fixed:hover { opacity: 0.6; transform: scale(1.1); }
        /* Sidebar note area - reserved space */
        .sidebar-note-area { min-height: 40px; margin-top: 8px; padding: 0 4px; position: relative; }
        .note-placeholder { font-size: 9px; font-weight: 500; color: var(--text-muted); opacity: 0; cursor: pointer; animation: noteFadeIn 3s ease-out forwards; animation-delay: 1s; letter-spacing: 0.02em; }
        @keyframes noteFadeIn { 0% { opacity: 0; } 100% { opacity: 0.35; } }
        .note-dots { animation: dotsWiggle 1.5s steps(3) infinite; display: inline-block; }
        @keyframes dotsWiggle { 0%, 100% { opacity: 0.4; } 33% { opacity: 0.7; } 66% { opacity: 0.5; } }
        .note-cursor { animation: cursorBlink 0.5s steps(1) 3, cursorFadeOut 0.3s ease-out 1.5s forwards; margin-left: 1px; }
        @keyframes cursorBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes cursorFadeOut { 0% { opacity: 1; } 100% { opacity: 0; } }
        .note-input { display: none; width: 100%; background: transparent; border: none; border-bottom: 1px solid var(--border); color: var(--text); font-size: 9px; font-family: inherit; font-weight: 500; padding: 6px 0; resize: none; height: 36px; line-height: 1.4; }
        .note-input:focus { outline: none; border-bottom-color: var(--text-muted); }
        .note-input::placeholder { color: var(--text-muted); opacity: 0.4; }
        .sidebar-note-area.active .note-placeholder { display: none; }
        .sidebar-note-area.active .note-input { display: block; }
        .note-counter { font-size: 7px; color: var(--text-muted); opacity: 0; text-align: right; margin-top: 4px; transition: opacity 0.2s; }
        .sidebar-note-area.active .note-counter { opacity: 0.4; }

        .studio-credit { margin-top: auto; padding-top: 12px; text-align: center; }
        .studio-credit a { display: inline-block; text-decoration: none; transition: all 0.3s ease; opacity: 0.4; }
        .studio-credit a:hover { opacity: 0.8; }
        .studio-credit img { height: 24px; width: auto; filter: brightness(0) invert(1); transition: all 0.3s ease; }
        .studio-credit a:hover img { filter: brightness(0) invert(1) drop-shadow(0 0 4px rgba(255,255,255,0.3)); }
        .logo-x { font-size: 7px; color: var(--text-muted); font-weight: 300; }
        .section-label { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-muted); margin-bottom: 14px; margin-top: 6px; }
        .control-group { margin-bottom: 8px; }
        .control-group label { display: block; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-dim); margin-bottom: 6px; }
        .control-group input[type="text"], .control-group input[type="number"], .control-group select { width: 100%; padding: 10px 16px; background: var(--bg-input); border: none; color: var(--text); border-radius: 50px; font-size: 13px; font-family: inherit; font-weight: 600; transition: all 0.3s ease; }
        .control-group input:focus, .control-group select:focus { outline: none; background: var(--bg-card); box-shadow: 0 0 0 2px rgba(0, 229, 204, 0.3); }
        .control-group select { cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%23a0a0c0'%3E%3Cpath d='M1 3l4 4 4-4'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 14px center; padding-right: 36px; color-scheme: dark; }
        .control-group select option { background: #1e1d28; color: #fff; padding: 8px; }

        .btn { width: 100%; padding: 14px; border: none; border-radius: 20px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); margin-bottom: 10px; font-family: inherit; }
        .btn:active { transform: scale(0.97); }
        .btn-primary { background: transparent; border: 2px solid var(--teal); color: var(--teal); }
        .btn-primary:hover { background: var(--teal); color: #000; box-shadow: 0 8px 24px rgba(0, 229, 204, 0.25); }
        .btn-secondary { background: var(--bg-input); color: var(--text-dim); }
        .btn-secondary:hover { background: var(--bg-card); color: var(--text); }
        .btn-download { background: var(--blue); color: #fff; }
        .btn-download:hover { box-shadow: 0 8px 24px rgba(0, 180, 255, 0.25); }
        .btn-twitter { background: #1DA1F2; color: #fff; }
        .btn-twitter:hover { background: #0d8ddb; }
        .btn-instagram { background: linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%); color: #fff; }

        .btn-group { display: flex; gap: 10px; }
        .btn-group .btn { flex: 1; }
        .btn-sm { padding: 10px 12px; font-size: 9px; border-radius: 50px; margin-bottom: 6px; }

        /* Icon buttons */
        .icon-btn { width: 36px; height: 36px; padding: 0; border: none; border-radius: 50%; background: var(--bg-input); color: var(--text-dim); font-size: 15px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .icon-btn:hover { background: var(--bg-card); color: var(--text); }
        .icon-btn.active { background: var(--pink); color: #fff; }

        /* Heart favorite button */
        .heart-btn { width: 40px; height: 40px; background: var(--bg-input); border: none; font-size: 18px; border-radius: 50%; opacity: 0.7; transition: all 0.25s ease; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .heart-btn .heart-red { display: inline; }
        .heart-btn .heart-blue { display: none; }
        .heart-btn:hover { opacity: 1; transform: scale(1.1); background: var(--bg-card); }
        .heart-btn:hover .heart-red { display: none; }
        .heart-btn:hover .heart-blue { display: inline; }
        .heart-btn.favorited { opacity: 1; box-shadow: 0 0 8px var(--spot-color, var(--pink)); background: color-mix(in srgb, var(--spot-color, var(--pink)) 15%, var(--bg-input)); }
        .heart-btn.favorited .heart-red { display: inline; }
        .heart-btn.favorited .heart-blue { display: none; }
        .heart-btn.favorited:hover .heart-red { display: none; }
        .heart-btn.favorited:hover .heart-blue { display: inline; }

        /* Action bar with icons */
        .action-bar { display: flex; gap: 6px; align-items: center; margin-bottom: 4px; margin-top: 6px; }
        .action-bar-main { flex: 1 1 auto; margin-bottom: 0; min-width: 0; }
        .action-bar .btn { width: auto; margin-bottom: 0; }
        .action-bar .heart-btn { height: 34px; width: 34px; min-width: 34px; border-radius: 50%; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 15px; }
        .action-icons { display: flex; gap: 6px; flex-wrap: wrap; }
        .action-icons .icon-btn { width: 32px; height: 32px; font-size: 13px; border-radius: 50%; }

        /* Saved to favorites note */
        .saved-note { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); opacity: 0; height: 0; overflow: hidden; transition: opacity 0.3s ease, height 0.3s ease; margin-top: 0; }
        .saved-note.visible { opacity: 0.5; height: 24px; margin-top: 10px; }
        .saved-dots::after { content: ''; animation: savedDots 1.5s steps(4) infinite; }
        @keyframes savedDots { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }

        /* Icon buttons row */
        .icon-buttons-row { display: flex; justify-content: center; gap: 6px; margin-bottom: 8px; margin-top: 4px; }
        .icon-buttons-row .icon-btn { flex: 0 0 auto; text-decoration: none; background: transparent; border-radius: 8px; width: 40px; height: 30px; font-size: 15px; display: flex; align-items: center; justify-content: center; }
        .icon-buttons-row .icon-btn:hover { transform: translateY(-1px); background: var(--bg-input); }
        .icon-buttons-row .icon-btn.text-btn { width: auto; padding: 0 6px; font-size: 7px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.04em; border-radius: 8px; border: none; color: var(--text-muted); opacity: 0.3; transition: all 0.2s ease; }
        .icon-buttons-row .icon-btn.text-btn:hover { opacity: 0.7; color: var(--warm); background: transparent; }
        .icon-buttons-row .opensea-icon { filter: grayscale(100%); }
        .icon-buttons-row .opensea-icon:hover { filter: grayscale(0%); }

        /* Sidebar bottom row */
        .sidebar-bottom-row { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 12px 0; margin-top: 8px; }
        .text-btn { background: none; border: none; color: var(--text-muted); font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; padding: 4px 2px; transition: color 0.2s ease; }
        .text-btn:hover { color: var(--text); }
        .text-btn .fav-count { color: var(--pink); }
        .row-divider { color: var(--border); font-size: 8px; }

        /* Originals button */
        .originals-btn { background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; gap: 6px; transition: all 0.3s ease; opacity: 0.5; }
        .originals-btn:hover { opacity: 1; }
        .originals-btn .originals-icon { font-size: 16px; filter: grayscale(100%) brightness(2); transition: filter 0.3s ease; }
        .originals-btn:hover .originals-icon { filter: grayscale(50%) brightness(1.5); }
        .originals-btn .originals-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); max-width: 0; overflow: hidden; white-space: nowrap; transition: max-width 0.3s ease, opacity 0.3s ease; opacity: 0; }
        .originals-btn:hover .originals-label { max-width: 80px; opacity: 1; }

        /* Grid originals button */
        .grid-originals-btn { background: none; border: none; cursor: pointer; padding: 6px 8px; display: flex; align-items: center; gap: 6px; transition: all 0.3s ease; opacity: 0.5; border-radius: 6px; }
        .grid-originals-btn:hover { opacity: 1; background: var(--bg-input); }
        .grid-originals-btn .originals-icon { font-size: 16px; filter: grayscale(100%) brightness(2); transition: filter 0.3s ease; }
        .grid-originals-btn:hover .originals-icon { filter: grayscale(50%) brightness(1.5); }
        .grid-originals-btn .originals-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); max-width: 0; overflow: hidden; white-space: nowrap; transition: max-width 0.3s ease, opacity 0.3s ease; opacity: 0; }
        .grid-originals-btn:hover .originals-label { max-width: 80px; opacity: 1; }

        /* Grid sort toggle */
        .grid-sort-toggle { background: none; border: none; cursor: pointer; padding: 4px 10px; font-size: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); opacity: 0.5; transition: all 0.3s ease; border-radius: 12px; white-space: nowrap; }
        .grid-sort-toggle:hover { opacity: 1; background: var(--bg-input); }
        .grid-sort-toggle .sort-arrow { display: inline-block; transition: transform 0.2s ease; margin-left: 2px; }
        .grid-sort-toggle.sort-desc .sort-arrow { transform: rotate(180deg); }
        .grid-numbers-toggle { background: none; border: none; cursor: pointer; padding: 4px 8px; font-size: 10px; font-weight: 700; color: var(--text-muted); opacity: 0.4; transition: all 0.3s ease; border-radius: 8px; margin-left: -6px; }
        .grid-numbers-toggle:hover { opacity: 0.8; background: var(--bg-input); }
        .grid-numbers-toggle.active { opacity: 1; color: var(--warm); }

        /* Grid clock - city emoji in filter bar, left-aligned under Cities title */
        .grid-clock { font-size: 14px; cursor: default; opacity: 0.25; transition: opacity 0.3s ease, filter 0.3s ease; filter: grayscale(100%); line-height: 1; white-space: nowrap; position: absolute; left: 28px; display: inline-grid; place-items: center start; }
        .grid-clock:hover { opacity: 1; filter: grayscale(0%); }
        .grid-clock .clock-emoji, .grid-clock .clock-time { grid-area: 1 / 1; transition: opacity 0.2s ease; }
        .grid-clock .clock-time { opacity: 0; font-size: 9px; font-weight: 600; font-family: Helvetica, Arial, sans-serif; letter-spacing: 0.04em; color: var(--text-muted); }
        .grid-clock:hover .clock-emoji { opacity: 0; }
        .grid-clock:hover .clock-time { opacity: 1; }
        .filter-toggle-bar:hover .grid-clock { opacity: 0.7; }
        @media (max-width: 768px) { .grid-clock { display: none; } }

        /* Grid energy clock - non-interactive display */
        .grid-energy-clock { background: none; border: none; cursor: default; padding: 4px 8px; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); opacity: 0.5; transition: all 0.3s ease; border-radius: 12px; white-space: nowrap; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; }
        .grid-energy-clock .energy-icon { filter: grayscale(100%); transition: filter 0.3s ease; font-size: 16px; }
        .grid-energy-clock:hover { opacity: 0.8; }
        .grid-energy-clock:hover .energy-icon { filter: grayscale(0%); }
        .grid-energy-clock.energy-rising { color: #ffb347; }
        .grid-energy-clock.energy-rising:hover .energy-icon { filter: grayscale(0%) drop-shadow(0 0 4px #ffb347); }
        .grid-energy-clock.energy-living { color: #87ceeb; }
        .grid-energy-clock.energy-living:hover .energy-icon { filter: grayscale(0%) drop-shadow(0 0 4px #87ceeb); }
        .grid-energy-clock.energy-fading { color: #dda0dd; }
        .grid-energy-clock.energy-fading:hover .energy-icon { filter: grayscale(0%) drop-shadow(0 0 4px #dda0dd); }
        .grid-energy-clock.energy-resting { color: #6b7280; }
        .grid-energy-clock.energy-resting:hover .energy-icon { filter: grayscale(0%) drop-shadow(0 0 4px #6b7280); }

        /* Story link next to info */
        .story-link { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); text-decoration: none; opacity: 0.4; transition: all 0.3s ease; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .story-link:hover { opacity: 0.8; color: var(--warm); }
        .story-link .timeline-icon { font-size: 12px; filter: grayscale(100%); transition: filter 0.3s ease; }
        .story-link:hover .timeline-icon { filter: grayscale(0%); }
        .story-link .timeline-label { display: none; }
        .story-link:hover .timeline-label { display: inline; }

        /* Collector message - subtle */
        /* Collector message removed - info lives in collector section */

        .btn-fullscreen { background: transparent; border: 1px solid var(--border); color: var(--text-muted); padding: 8px 12px; border-radius: 50px; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; }
        .btn-fullscreen:hover { background: var(--bg-card); color: var(--text); border-color: var(--text-muted); }
        .btn-shuffle { background: transparent; border: 1px solid var(--border); color: var(--text-muted); position: relative; overflow: hidden; padding: 8px 12px; flex: 0 0 auto; border-radius: 50px; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; white-space: nowrap; font-family: inherit; }
        .btn-shuffle:hover { background: var(--yellow); color: #000; border-color: var(--yellow); }
        .btn-shuffle.active { background: var(--bg-card); border-color: var(--teal); color: var(--teal); }
        .btn-shuffle .explore-progress { position: absolute; bottom: 0; left: 0; height: 3px; background: var(--teal); width: 0%; transition: width 0.1s linear; }
        .btn-shuffle.active .explore-progress { animation: exploreCountdown 5s linear forwards; }
        @keyframes exploreCountdown { from { width: 0%; } to { width: 100%; } }
        @keyframes shuffleStart {
            0% { transform: scale(1) rotate(0deg); }
            20% { transform: scale(1.1) rotate(-3deg); }
            40% { transform: scale(0.95) rotate(2deg); }
            60% { transform: scale(1.05) rotate(-1deg); }
            80% { transform: scale(0.98) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .btn-shuffle.shuffling { animation: shuffleStart 0.5s ease-out; }

        /* Collapsible filters */
        .filters-toggle { display: flex; justify-content: space-between; align-items: center; padding: 7px 16px; background: var(--bg-input); border-radius: 50px; cursor: pointer; margin-bottom: 6px; }
        .filters-toggle span { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); transition: color 0.2s ease; }
        .filters-section:not(.collapsed) .filters-toggle span { color: var(--warm); }
        .filters-toggle .toggle-icon { transition: transform 0.2s; }
        .filters-section.collapsed .filters-toggle .toggle-icon { transform: rotate(-90deg); }
        .filters-section.collapsed .filters-content { display: none; }
        .filters-section { margin-bottom: 6px; }

        /* Metadata section collapsible */
        .metadata-section { margin-bottom: 4px; }
        .metadata-toggle { display: flex; justify-content: space-between; align-items: center; padding: 7px 16px; background: var(--bg-input); border-radius: 50px; cursor: pointer; margin-bottom: 4px; }
        .metadata-toggle span { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); transition: color 0.2s ease; }
        .metadata-section:not(.collapsed) .metadata-toggle span { color: var(--warm); }
        .metadata-toggle .toggle-icon { transition: transform 0.2s; }
        .metadata-section.collapsed .metadata-toggle .toggle-icon { transform: rotate(-90deg); }
        .metadata-section.collapsed .metadata-content { display: none; }
        .filters-content { padding-top: 6px; padding-bottom: 8px; }
        .metadata-content { padding-bottom: 8px; }

        /* Checkbox filter */
        .checkbox-filter { display: flex; align-items: center; gap: 10px; padding: 10px 18px; background: var(--bg-input); border-radius: 50px; cursor: pointer; margin-bottom: 8px; }
        .checkbox-filter input { appearance: none; -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%; background: transparent; border: none; cursor: pointer; transition: all 0.2s ease; }
        .checkbox-filter input:checked { background: rgba(255, 107, 53, 0.4); border: none; }
        .checkbox-filter label { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); cursor: pointer; }

        /* Grid size toggle button - cycles through sizes */
        .grid-size-toggle { width: 32px; height: 32px; padding: 0; border: none; border-radius: 50%; background: var(--bg-input); color: var(--text-muted); cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .grid-size-toggle:hover { background: var(--bg-card); color: var(--text); }
        .grid-size-toggle .size-icon { display: grid; transition: all 0.2s ease; }
        .grid-size-toggle .size-icon b { display: block; background: currentColor; aspect-ratio: 1; }
        /* Single large square */
        .grid-size-toggle .size-icon.size-1 { grid-template-columns: 14px; grid-template-rows: 14px; }
        .grid-size-toggle .size-icon.size-1 b { border-radius: 2px; }
        /* 2x2 grids - different sizes */
        .grid-size-toggle .size-icon.size-2 { grid-template-columns: repeat(2, 7px); grid-template-rows: repeat(2, 7px); gap: 2px; }
        .grid-size-toggle .size-icon.size-2 b { border-radius: 1px; }
        .grid-size-toggle .size-icon.size-3 { grid-template-columns: repeat(2, 6px); grid-template-rows: repeat(2, 6px); gap: 2px; }
        .grid-size-toggle .size-icon.size-3 b { border-radius: 1px; }
        .grid-size-toggle .size-icon.size-4 { grid-template-columns: repeat(2, 5px); grid-template-rows: repeat(2, 5px); gap: 2px; }
        .grid-size-toggle .size-icon.size-4 b { border-radius: 1px; }
        /* 3x3 grids */
        .grid-size-toggle .size-icon.size-6 { grid-template-columns: repeat(3, 4px); grid-template-rows: repeat(3, 4px); gap: 1px; }
        .grid-size-toggle .size-icon.size-6 b { border-radius: 1px; }
        .grid-size-toggle .size-icon.size-8 { grid-template-columns: repeat(3, 3px); grid-template-rows: repeat(3, 3px); gap: 1px; }
        .grid-size-toggle .size-icon.size-8 b { border-radius: 0; }
        /* 4x4 grids */
        .grid-size-toggle .size-icon.size-10 { grid-template-columns: repeat(4, 3px); grid-template-rows: repeat(4, 3px); gap: 1px; }
        .grid-size-toggle .size-icon.size-10 b { border-radius: 0; }
        .grid-size-toggle .size-icon.size-12 { grid-template-columns: repeat(4, 2px); grid-template-rows: repeat(4, 2px); gap: 1px; }
        .grid-size-toggle .size-icon.size-12 b { border-radius: 0; }
        .grid-size-toggle .size-icon.size-auto { grid-template-columns: repeat(4, 2px); grid-template-rows: repeat(4, 2px); gap: 1px; opacity: 0.6; }
        .grid-size-toggle .size-icon.size-auto b { border-radius: 0; }

        /* Grid column variations */
        .grid-items.grid-2-col, .grid-group-items.grid-2-col { grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .grid-items.grid-3-col, .grid-group-items.grid-3-col { grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .grid-items.grid-4-col, .grid-group-items.grid-4-col { grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .grid-items.grid-6-col, .grid-group-items.grid-6-col { grid-template-columns: repeat(6, 1fr); gap: 5px; }
        .grid-items.grid-8-col, .grid-group-items.grid-8-col { grid-template-columns: repeat(8, 1fr); gap: 4px; }
        .grid-items.grid-auto, .grid-group-items.grid-auto { grid-template-columns: repeat(14, 1fr); gap: 2px; }

        /* Favorites grid - clean, spacious layout */
        .grid-items.favorites-grid { gap: 16px; padding: 20px; width: 100%; }
        .grid-items.favorites-grid.grid-2-col { gap: 24px; }
        .grid-items.favorites-grid.grid-3-col { gap: 20px; }
        .grid-items.favorites-grid.grid-4-col { gap: 16px; }
        .grid-items.favorites-grid .grid-item { border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }

        /* Collectors button in grid - brighter when not clicked, muted when active */
        .grid-mode-btn.collectors-btn { background: transparent; border-color: rgba(212, 165, 116, 0.25); color: var(--text-muted); opacity: 0.6; }
        .grid-mode-btn.collectors-btn:hover { background: rgba(212, 165, 116, 0.06); border-color: var(--warm); color: var(--warm); opacity: 0.9; }
        .grid-mode-btn.collectors-btn.active { opacity: 0.25; border-color: transparent; color: var(--text-muted); background: transparent; }
        .grid-mode-btn.favorites-active { background: var(--warm); border-color: var(--warm); color: #000; }
        .grid-mode-btn.favorites-active:hover { background: var(--warm); border-color: var(--warm); color: #000; }
        /* Origins button in grid */
        .grid-mode-btn.origins-btn { background: transparent; border-color: rgba(212, 165, 116, 0.25); color: var(--text-muted); opacity: 0.6; }
        .grid-mode-btn.origins-btn:hover { background: rgba(212, 165, 116, 0.06); border-color: var(--warm); color: var(--warm); opacity: 0.9; }
        .grid-mode-btn.origins-btn.active { background: rgba(232, 184, 109, 0.15); border-color: var(--warm); color: var(--warm); opacity: 1; }

        /* Origins grid items */
        .origin-item { position: relative; aspect-ratio: 1; border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.3s ease; background: var(--bg-card); }
        .origin-item:hover { transform: scale(1.02); box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index: 2; }
        .origin-item img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease; }
        .origin-item:hover img { transform: scale(1.05); }
        .origin-item-label { position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.85)); font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: #fff; opacity: 0; transition: opacity 0.3s ease; }
        .origin-item:hover .origin-item-label { opacity: 1; }
        .origin-item-year { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 10px; font-size: 8px; font-weight: 700; color: var(--warm); opacity: 0; transition: opacity 0.3s ease; }
        .origin-item:hover .origin-item-year { opacity: 1; }
        .origin-item-edition { position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 10px; font-size: 8px; font-weight: 700; color: var(--text-dim); opacity: 0; transition: opacity 0.3s ease; }
        .origin-item:hover .origin-item-edition { opacity: 1; }

        /* Collector Originals Section in Grid View (shown below Cities) */
        .collector-originals-section { margin-top: 32px; padding-top: 24px; border-top: 1px solid rgba(255,255,255,0.06); }
        .collector-originals-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; }
        .collector-originals-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.12em; color: var(--warm); }
        .collector-originals-count { font-size: 9px; font-weight: 700; color: var(--text-muted); background: rgba(232, 184, 109, 0.15); padding: 3px 8px; border-radius: 10px; }
        .collector-originals-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; }
        .collector-original-item { position: relative; aspect-ratio: 1; border-radius: 10px; overflow: hidden; cursor: pointer; transition: all 0.3s ease; background: var(--bg-card); }
        .collector-original-item:hover { transform: translateY(-4px); box-shadow: 0 12px 32px rgba(232, 184, 109, 0.2); }
        .collector-original-img { width: 100%; height: 100%; background-size: cover; background-position: center; transition: transform 0.4s ease; }
        .collector-original-item:hover .collector-original-img { transform: scale(1.05); }
        .collector-original-info { position: absolute; bottom: 0; left: 0; right: 0; padding: 12px; background: linear-gradient(transparent, rgba(0,0,0,0.9)); }
        .collector-original-title { display: block; font-size: 12px; font-weight: 600; color: #fff; margin-bottom: 2px; }
        .collector-original-collection { display: block; font-size: 9px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.08em; color: var(--warm); opacity: 0.8; }
        .collector-original-arrow { position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; border-radius: 50%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; opacity: 0; transition: all 0.3s ease; font-size: 10px; color: var(--warm); }
        .collector-original-item:hover .collector-original-arrow { opacity: 1; }
        .collector-cities-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 0; }
        .collector-cities-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.12em; color: var(--warm); }
        .collector-cities-count { font-size: 9px; font-weight: 700; color: var(--text-muted); background: rgba(232, 184, 109, 0.15); padding: 3px 8px; border-radius: 10px; }
        /* Highlight flash animation for scrolling to origin */
        .timeline-item.highlight-flash, .timeline-group-item.highlight-flash { animation: highlightFlash 2s ease-out; }
        @keyframes highlightFlash { 0% { box-shadow: 0 0 0 4px var(--warm); } 100% { box-shadow: 0 0 0 0 transparent; } }

        /* O.M.A.G.E. Inquiry Modal */
        .omage-inquiry-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.95); z-index: 3000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(20px); padding: 20px; }
        .omage-inquiry-modal.open { display: flex; }
        .omage-inquiry-content { background: var(--bg-panel); border-radius: 16px; max-width: 400px; width: 100%; padding: 24px; position: relative; max-height: 90vh; overflow-y: auto; }
        .omage-inquiry-close { position: absolute; top: 12px; right: 12px; background: none; border: none; color: var(--text-muted); font-size: 24px; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s ease; }
        .omage-inquiry-close:hover { background: var(--bg-input); color: var(--text); }
        .omage-inquiry-header { text-align: center; margin-bottom: 20px; }
        .omage-inquiry-title { font-size: 18px; font-weight: 700; color: var(--warm); margin-bottom: 4px; }
        .omage-inquiry-subtitle { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; }
        .omage-inquiry-body { margin-bottom: 20px; }
        .omage-inquiry-image { width: 100%; aspect-ratio: 1; border-radius: 8px; overflow: hidden; margin-bottom: 16px; }
        .omage-inquiry-image img { width: 100%; height: 100%; object-fit: cover; }
        .omage-inquiry-details { font-size: 13px; color: var(--text-dim); line-height: 1.6; }
        .omage-inquiry-details strong { color: var(--text); }
        .omage-inquiry-form { display: flex; flex-direction: column; gap: 12px; }
        .omage-inquiry-input { background: var(--bg-input); border: none; border-radius: 8px; padding: 12px 16px; color: var(--text); font-size: 14px; font-family: inherit; }
        .omage-inquiry-input::placeholder { color: var(--text-muted); }
        .omage-inquiry-input:focus { outline: none; box-shadow: 0 0 0 2px rgba(232, 184, 109, 0.3); }
        .omage-inquiry-textarea { min-height: 80px; resize: vertical; }
        .omage-inquiry-submit { background: var(--warm); border: none; border-radius: 8px; padding: 14px; color: #000; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; transition: all 0.2s ease; }
        .omage-inquiry-submit:hover { background: #f0c87d; transform: translateY(-1px); }
        .omage-inquiry-success { text-align: center; padding: 20px; color: var(--teal); font-size: 14px; }

        /* OpenSea Warning Modal */
        .opensea-warning-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.95); z-index: 3100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(20px); padding: 20px; }
        .opensea-warning-modal.open { display: flex; }
        .opensea-warning-content { background: var(--bg-panel); border-radius: 16px; max-width: 360px; width: 100%; padding: 28px 24px; text-align: center; position: relative; }
        .opensea-warning-icon { font-size: 32px; margin-bottom: 12px; }
        .opensea-warning-title { font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 8px; }
        .opensea-warning-text { font-size: 13px; color: var(--text-dim); line-height: 1.5; margin-bottom: 20px; }
        .opensea-warning-text a { color: var(--warm); text-decoration: none; }
        .opensea-warning-actions { display: flex; gap: 10px; }
        .opensea-warning-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; }
        .opensea-warning-btn.primary { background: var(--warm); color: #000; }
        .opensea-warning-btn.primary:hover { background: var(--orange); }
        .opensea-warning-btn.secondary { background: #333; color: #888; }
        .opensea-warning-btn.secondary:hover { background: #444; color: #fff; }
        .origin-item.available::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; border: 2px solid var(--teal); border-radius: 8px; pointer-events: none; }
        @keyframes availablePulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        .origin-item.available .origin-item-label::before { content: 'ðŸŸ¢ '; }

        /* Origins grid groups by collection */
        .origins-group { margin-bottom: 24px; }
        .origins-group-header { display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: var(--bg-input); border-radius: 12px; margin-bottom: 12px; cursor: pointer; transition: all 0.2s ease; }
        .origins-group-header:hover { background: var(--bg-card); }
        .origins-group-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--warm); flex: 1; }
        .origins-group-count { font-size: 10px; color: var(--text-muted); }
        .origins-group-toggle { font-size: 10px; color: var(--text-muted); transition: transform 0.2s ease; }
        .origins-group.collapsed .origins-group-toggle { transform: rotate(-90deg); }
        .origins-group.collapsed .origins-group-items { display: none; }
        .origins-group-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; padding: 0 4px; }
        .origins-group-items.grid-2-col { grid-template-columns: repeat(2, 1fr); }
        .origins-group-items.grid-3-col { grid-template-columns: repeat(3, 1fr); }
        .origins-group-items.grid-4-col { grid-template-columns: repeat(4, 1fr); }
        .origins-group-items.grid-6-col { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
        .origins-group-items.grid-8-col { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
        .origins-group-items.grid-11-col { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); }
        .origins-group-items.grid-12-col { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
        .origins-group-items.grid-auto { grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); }

        /* Legacy size icon classes - kept for backwards compatibility */
        .size-small { width: 8px; height: 8px; display: block; background: currentColor; border-radius: 2px; }
        .size-medium { width: 12px; height: 12px; display: block; background: currentColor; border-radius: 2px; }
        .size-large { width: 16px; height: 16px; display: block; background: currentColor; border-radius: 2px; }

        /* Palette inspector - floating style */
        .palette-inspector { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(20px); overflow-y: auto; padding: 40px 20px; transition: background 0.4s ease; }
        .palette-inspector.open { display: flex; }
        .palette-inspector-content { text-align: center; max-width: 320px; width: 100%; position: relative; }
        /* Floating swatch - no card */
        .pantone-swatch { background: transparent; overflow: visible; position: relative; z-index: 2; }
        .pantone-bg-strip { display: none; }
        .pantone-name-floating { font-size: 20px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.08em; text-shadow: 0 2px 8px rgba(0,0,0,0.5); margin-bottom: 14px; transition: color 0.3s ease; }
        /* Dark text for light backgrounds */
        .palette-inspector.light-bg .pantone-name-floating { color: rgba(0,0,0,0.85); text-shadow: none; }
        .palette-inspector.light-bg .pantone-meta-item { color: rgba(0,0,0,0.5); }
        .palette-inspector.light-bg .pantone-meta-item span { color: rgba(0,0,0,0.8); }
        .palette-inspector.light-bg .pantone-category-label { color: rgba(0,0,0,0.4); }
        .palette-inspector.light-bg .pantone-fav-btn { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.6); }
        .palette-inspector.light-bg .pantone-fav-btn:hover { background: rgba(0,0,0,0.15); }
        .palette-inspector.light-bg .pantone-fav-btn.favorited { background: rgba(255,107,138,0.3); color: #d4365c; }
        .palette-inspector.light-bg .pantone-hex-toggle { background: rgba(0,0,0,0.08); border-color: rgba(0,0,0,0.15); color: rgba(0,0,0,0.6); }
        .palette-inspector.light-bg .pantone-hex-toggle:hover { background: rgba(0,0,0,0.12); color: rgba(0,0,0,0.8); }
        .palette-inspector.light-bg .pantone-hex-toggle.active { background: rgba(0,0,0,0.8); color: #fff; }
        .palette-inspector.light-bg .palette-inspector-similar-label { color: rgba(0,0,0,0.4); }
        .palette-inspector.light-bg .palette-fan-arrow { background: rgba(0,0,0,0.08); border-color: rgba(0,0,0,0.15); color: rgba(0,0,0,0.6); }
        .palette-inspector.light-bg .palette-fan-arrow:hover { background: rgba(0,0,0,0.15); color: rgba(0,0,0,0.9); }
        .palette-inspector.light-bg .palette-inspector-close { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.6); }
        .palette-inspector.light-bg .palette-inspector-close:hover { background: rgba(0,0,0,0.15); color: rgba(0,0,0,0.9); }
        .palette-inspector.light-bg .pantone-hex-section { border-top-color: rgba(0,0,0,0.1); }
        .palette-inspector.light-bg .palette-suggestions-label { color: rgba(0,0,0,0.5); }
        .pantone-header-row { display: flex; align-items: center; justify-content: center; gap: 10px; padding: 0; margin-bottom: 14px; }
        .pantone-fav-btn { width: 32px; height: 32px; border: none; background: rgba(255,255,255,0.15); border-radius: 50%; font-size: 16px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .pantone-fav-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        .pantone-fav-btn.favorited { background: rgba(255,107,138,0.3); color: #ff6b8a; }
        .pantone-hex-toggle { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.7); padding: 6px 12px; font-size: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px); }
        .pantone-hex-toggle:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); color: #fff; }
        .pantone-hex-toggle.active { background: rgba(255,255,255,0.9); border-color: rgba(255,255,255,0.9); color: #333; }
        .pantone-info { background: transparent; padding: 0; text-align: center; }
        .pantone-meta { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; justify-content: center; }
        .pantone-meta-item { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: rgba(255,255,255,0.5); }
        .pantone-meta-item span { color: rgba(255,255,255,0.9); font-weight: 700; margin-left: 4px; }
        /* Color category sections */
        .pantone-category { margin-bottom: 14px; }
        .pantone-category-label { font-size: 7px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.12em; color: rgba(255,255,255,0.4); margin-bottom: 8px; }
        .pantone-color-row { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        .pantone-color-chip { width: 34px; height: 34px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.25s ease; position: relative; box-shadow: 0 3px 10px rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.1); }
        .pantone-color-chip:hover { transform: scale(1.2); z-index: 2; box-shadow: 0 6px 20px rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.3); }
        .pantone-color-chip .chip-hex { position: absolute; bottom: -24px; left: 50%; transform: translateX(-50%); font-size: 8px; font-weight: 700; font-family: monospace; white-space: nowrap; opacity: 0; transition: all 0.25s ease; padding: 4px 8px; border-radius: 4px; background: rgba(0,0,0,0.7); color: #fff; }
        .pantone-color-chip:hover .chip-hex { opacity: 1; }
        /* Hex visible mode: circles become pills with hex codes inside */
        .hex-visible .pantone-color-chip { width: auto; height: 34px; border-radius: 17px; padding: 0 12px; gap: 0; }
        .hex-visible .pantone-color-chip:hover { transform: scale(1.08); }
        .hex-visible .pantone-color-chip .chip-hex { position: static; transform: none; opacity: 1; background: transparent; padding: 0; border-radius: 0; font-size: 10px; font-weight: 800; line-height: 34px; }
        .hex-visible .pantone-color-row { gap: 8px; }
        /* Hex codes display - hidden by default */
        .pantone-hex-section { border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; margin-top: 12px; display: none; }
        .pantone-hex-section.visible { display: block; }
        .pantone-hex-section .pantone-category-label { color: rgba(255,255,255,0.4); }
        .pantone-hex-row { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .pantone-hex-chip { padding: 6px 10px; border-radius: 6px; font-size: 9px; font-weight: 800; font-family: monospace; cursor: pointer; transition: all 0.15s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.2); letter-spacing: 0.03em; }
        .pantone-hex-chip:hover { transform: scale(1.08); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        /* Palette fan navigation */
        .palette-fan-container { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 24px; }
        .palette-fan { position: relative; width: 160px; height: 60px; perspective: 600px; }
        .palette-fan-chip { width: 36px; height: 50px; border-radius: 5px; cursor: pointer; transition: all 0.35s ease; box-shadow: 0 4px 16px rgba(0,0,0,0.3); position: absolute; top: 50%; left: 50%; transform-origin: center center; }
        .palette-fan-chip.fan-pos-0 { transform: translate(-50%, -50%) scale(1); z-index: 10; opacity: 1; box-shadow: 0 6px 24px rgba(0,0,0,0.4); }
        .palette-fan-chip.fan-pos--1 { transform: translate(calc(-50% - 38px), -50%) scale(0.82) rotateY(8deg); z-index: 8; opacity: 0.55; }
        .palette-fan-chip.fan-pos-1 { transform: translate(calc(-50% + 38px), -50%) scale(0.82) rotateY(-8deg); z-index: 8; opacity: 0.55; }
        .palette-fan-chip.fan-pos--2 { transform: translate(calc(-50% - 64px), -50%) scale(0.65) rotateY(14deg); z-index: 6; opacity: 0.25; }
        .palette-fan-chip.fan-pos-2 { transform: translate(calc(-50% + 64px), -50%) scale(0.65) rotateY(-14deg); z-index: 6; opacity: 0.25; }
        .palette-fan-chip.fan-hidden { transform: translate(-50%, -50%) scale(0.4); z-index: 1; opacity: 0; pointer-events: none; }
        .palette-fan-chip .fan-label { display: none; }
        .palette-fan-arrow { width: 28px; height: 28px; border-radius: 50%; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); color: rgba(255,255,255,0.5); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 12px; flex-shrink: 0; }
        .palette-fan-arrow:hover { background: rgba(255,255,255,0.15); color: #fff; }
        .palette-fan-arrow:disabled, .palette-fan-arrow.disabled { opacity: 0.2; cursor: default; pointer-events: none; }
        /* Palette suggestions */
        .palette-inspector-similar { margin-top: 16px; }
        .palette-suggestions-section { margin-bottom: 10px; }
        .palette-suggestions-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.4); margin-bottom: 6px; }
        .similar-palettes-row { display: flex; gap: 5px; justify-content: center; flex-wrap: wrap; }
        .similar-palette-chip { padding: 5px 10px; border-radius: 14px; font-size: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.03em; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .similar-palette-chip:hover { transform: scale(1.08); box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
        .palette-inspector-close { background: var(--bg-input); border: none; color: var(--text-dim); padding: 12px 28px; border-radius: 50px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; transition: all 0.3s ease; margin-top: 18px; }
        /* Sidebar inspect palette button */
        .sidebar-inspect-btn { display: flex; align-items: center; justify-content: center; gap: 6px; width: 100%; padding: 10px 14px; margin-bottom: 6px; background: transparent; border: 1px solid var(--border); color: var(--text-muted); font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; position: relative; }
        .sidebar-inspect-btn:hover { border-color: var(--text-muted); }
        .sidebar-inspect-btn:hover .inspect-icon { transform: scale(1.15); }
        .sidebar-inspect-btn:hover .inspect-dots { opacity: 0; transform: scale(0.8); }
        .sidebar-inspect-btn:hover .inspect-icon { opacity: 0; transform: scale(0.8); }
        .sidebar-inspect-btn .inspect-hover-label { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; transition: all 0.3s ease; font-size: 9px; font-weight: 700; letter-spacing: 0.08em; color: var(--text-dim); }
        .sidebar-inspect-btn:hover .inspect-hover-label { opacity: 1; }
        .inspect-dots { display: flex; gap: 3px; align-items: center; transition: all 0.3s ease; }
        .inspect-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; transition: transform 0.2s ease; }
        .sidebar-inspect-btn:hover .inspect-dot { transform: scale(1.15); }
        .inspect-icon { flex-shrink: 0; transition: all 0.3s ease; line-height: 1; display: flex; align-items: center; }
        .palette-inspector-close:hover { background: var(--bg-card); color: var(--text); }
        /* Palette inspector prev/next arrows - subtle edge nav like wall view */
        .palette-nav-arrow { display: none; }
        /* Palette inspector gradient navigation strip */
        .palette-gradient-nav { position: absolute; bottom: 0; left: 0; right: 0; height: 36px; z-index: 5; }
        .palette-gradient-strip { width: 100%; height: 100%; cursor: pointer; position: relative; touch-action: none; }
        .palette-gradient-strip::after { content: ''; position: absolute; inset: 0; box-shadow: inset 0 1px 3px rgba(0,0,0,0.15); pointer-events: none; }
        .palette-gradient-marker { position: absolute; width: 2px; height: 100%; background: rgba(255,255,255,0.9); top: 0; transform: translateX(-50%); box-shadow: 0 0 6px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        .palette-gradient-strip:hover .palette-gradient-marker, .palette-gradient-strip.active .palette-gradient-marker { opacity: 1; }
        .palette-inspector.light-bg .palette-gradient-marker { background: rgba(0,0,0,0.7); }
        .btn-inspect { background: transparent; border: 1px solid var(--border); color: var(--text-dim); }
        .btn-inspect:hover { border-color: var(--teal); color: var(--teal); }

        /* About Modal */
        .about-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.98); z-index: 2550; display: none; align-items: flex-start; justify-content: center; overflow-y: auto; padding: 40px 20px 80px; cursor: pointer; opacity: 0; transition: opacity 0.15s ease; content-visibility: auto; }
        .about-modal.open { display: flex; opacity: 1; }
        .about-close { position: fixed; top: 20px; right: 20px; background: none; border: 1px solid rgba(255,255,255,0.3); color: rgba(255,255,255,0.6); width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; z-index: 10; }
        .about-close:hover { background: #fff; border-color: #fff; color: #000; }
        .about-content { max-width: 800px; width: 100%; text-align: left; cursor: default; }
        .about-sections-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0 32px; }
        @media (max-width: 768px) { .about-sections-grid { grid-template-columns: 1fr; } }
        .about-title { font-size: 36px; font-weight: 700; text-transform: none; letter-spacing: 0.02em; margin-bottom: 8px; color: #fff; font-family: Helvetica, Arial, sans-serif; }
        .about-collab { font-size: 11px; color: var(--text-muted); margin-bottom: 28px; letter-spacing: 0.05em; text-transform: uppercase; position: relative; cursor: default; }
        .about-collab a { color: var(--warm); text-decoration: none; transition: color 0.2s ease; }
        .about-collab a:hover { color: var(--orange); }
        .about-collab-short { transition: opacity 0.25s ease; }
        .about-collab-full { position: absolute; left: 0; right: 0; top: 0; opacity: 0; pointer-events: none; transition: opacity 0.25s ease; }
        .about-collab:hover .about-collab-short { opacity: 0; }
        .about-collab:hover .about-collab-full { opacity: 1; pointer-events: auto; }
        .about-intro { font-size: 15px; line-height: 1.8; color: var(--text-dim); margin-bottom: 12px; max-width: 100%; }
        .about-journey-link { margin-bottom: 28px; }
        .about-journey-link a { font-size: 12px; color: var(--text-muted); text-decoration: none; transition: color 0.2s ease; letter-spacing: 0.02em; }
        .about-journey-link a:hover { color: var(--warm); }
        .about-highlight { font-weight: 600; }
        .about-highlight.teal { color: var(--teal); }
        .about-highlight.warm { color: var(--warm); }
        .about-highlight.pink { color: var(--pink); }
        .about-highlight.purple { color: var(--purple); }
        .about-highlight.yellow { color: var(--yellow); }
        .about-highlight.orange { color: var(--orange); }
        .about-video { position: relative; width: 100%; padding-bottom: 56.25%; margin-bottom: 28px; border-radius: 8px; overflow: hidden; }
        .about-video iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .about-section { border-top: 1px solid var(--border); }
        .about-section-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 0; cursor: pointer; transition: color 0.2s ease; }
        .about-section-header:hover { color: var(--text); }
        .about-section-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: inherit; }
        .about-section-arrow { font-size: 10px; color: var(--text-muted); transition: transform 0.2s ease; }
        .about-section.open .about-section-arrow { transform: rotate(180deg); }
        .about-section-content { display: none; padding-bottom: 18px; font-size: 14px; line-height: 1.7; color: var(--text-dim); }
        .about-section.open .about-section-content { display: block; }
        /* About page set type examples */
        .about-set-types { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 8px; }
        .about-set-type { display: flex; align-items: center; gap: 10px; padding: 12px 14px; background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius: 10px; }
        .about-set-icon { font-size: 18px; line-height: 1; flex-shrink: 0; }
        .about-set-info { display: flex; flex-direction: column; gap: 2px; }
        .about-set-name { font-size: 11px; font-weight: 700; color: var(--text); line-height: 1.2; }
        .about-set-desc { font-size: 9px; color: var(--text-muted); line-height: 1.3; }
        @media (max-width: 600px) {
            .about-set-types { grid-template-columns: 1fr; }
        }
        .about-stats { display: flex; justify-content: center; gap: 8px; margin: 16px 0 20px; font-size: 12px; color: var(--text-muted); flex-wrap: wrap; }
        .about-stat { white-space: nowrap; }
        .about-stat strong { color: var(--text); font-weight: 700; }
        .about-stat-sep { color: var(--text-muted); opacity: 0.4; }
        .about-artist { margin-bottom: 16px; }
        .about-artist:last-child { margin-bottom: 0; }
        .about-artist a { color: var(--teal); text-decoration: none; }
        .about-artist a:hover { text-decoration: underline; }
        .about-artist-links { margin-top: 8px; display: flex; gap: 12px; }
        .about-artist-links a { font-size: 11px; color: rgba(232, 184, 109, 0.5); text-decoration: none; text-transform: uppercase; letter-spacing: 0.05em; transition: color 0.2s ease; }
        .about-artist-links a:hover { color: var(--warm); }
        .about-shortcuts { text-align: center; margin: 20px 0; padding: 12px; background: var(--bg-input); border-radius: 8px; }
        .about-shortcut-hint { font-size: 11px; color: var(--text-muted); }
        .about-shortcut-hint kbd { display: inline-block; padding: 2px 8px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; font-family: monospace; font-size: 12px; color: var(--text); }
        .about-collab-cta { margin-top: 32px; padding: 28px 24px; border: 1px solid var(--border); border-radius: 12px; background: rgba(255, 255, 255, 0.02); text-align: center; }
        .about-collab-title { font-size: 16px; font-weight: 700; margin-bottom: 8px; }
        .about-collab-desc { font-size: 12px; color: var(--text-dim); line-height: 1.6; margin-bottom: 16px; max-width: 320px; margin-left: auto; margin-right: auto; }
        .about-collab-btn { display: inline-block; font-size: 10px; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; padding: 10px 24px; border-radius: 50px; border: 1px solid var(--text-muted); background: none; color: var(--text-dim); cursor: pointer; transition: all 0.3s ease; text-decoration: none; }
        .about-collab-btn:hover { border-color: var(--warm); color: var(--warm); background: rgba(232, 184, 109, 0.08); }
        .say-hey-form { display: none; flex-direction: column; gap: 10px; margin-top: 16px; max-width: 320px; margin-left: auto; margin-right: auto; width: 100%; }
        .say-hey-input { background: var(--bg-input); border: none; border-radius: 8px; padding: 12px 16px; color: var(--text); font-size: 13px; font-family: inherit; text-align: left; }
        .say-hey-input::placeholder { color: var(--text-muted); }
        .say-hey-input:focus { outline: none; box-shadow: 0 0 0 2px rgba(232, 184, 109, 0.3); }
        .say-hey-textarea { min-height: 70px; resize: vertical; }
        .say-hey-submit { background: none; border: 1px solid var(--text-muted); border-radius: 50px; padding: 10px 24px; color: var(--text-dim); font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; }
        .say-hey-submit:hover { border-color: var(--warm); color: var(--warm); background: rgba(232, 184, 109, 0.08); }
        .say-hey-success { color: var(--teal); font-size: 13px; margin-top: 16px; }
        .about-footer { margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); text-align: center; }
        .about-footer-text { font-size: 14px; font-style: italic; color: var(--text-muted); margin-bottom: 16px; line-height: 1.6; }
        .about-countdown { margin-top: 20px; text-align: center; }
        .countdown-cells { display: flex; justify-content: center; gap: 16px; }
        .countdown-cell { display: flex; flex-direction: column; align-items: center; min-width: 36px; }
        .countdown-value { font-family: 'Nunito', sans-serif; font-size: 16px; font-weight: 600; color: #666; letter-spacing: 0.02em; }
        .countdown-label { font-family: 'Nunito', sans-serif; font-size: 8px; font-weight: 500; color: #888; text-transform: lowercase; letter-spacing: 0.05em; margin-top: 2px; }
        .about-countdown.expired { display: none; }
        .about-buttons { display: flex; gap: 16px; justify-content: center; align-items: center; }
        .about-btn-essay, .about-btn-explore, .about-btn-origins { font-size: 11px; font-weight: 600; letter-spacing: 0.1em; cursor: pointer; transition: all 0.3s ease; text-decoration: none; text-transform: uppercase; background: none; border: 0.5px dashed var(--text-muted); padding: 10px 24px; color: var(--text-muted); border-radius: 50px; height: 38px; display: flex; align-items: center; }
        .about-btn-essay:hover, .about-btn-explore:hover, .about-btn-origins:hover { color: var(--text); border-color: var(--text); }
        .about-mint-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; }
        .about-mint-btn { --ch: 26px; --cw: calc(var(--ch) * 3.985); display: flex; align-items: center; height: var(--ch); padding: 0 12px; gap: 0; opacity: 0.8; transition: opacity 0.3s ease; background: transparent; border: none; cursor: pointer; overflow: visible; }
        .about-mint-btn:hover { opacity: 1; }
        .about-mint-btn .collect-seg { background-size: var(--cw) var(--ch); }
        .about-mint-btn:hover .collect-seg { animation: segVibrate 0.35s ease-in-out infinite; }
        .about-mint-btn:hover .cs-1 { animation-delay: 0s; }
        .about-mint-btn:hover .cs-2 { animation-delay: 0.06s; }
        .about-mint-btn:hover .cs-3 { animation-delay: 0.12s; }
        .about-mint-btn:hover .cs-4 { animation-delay: 0.18s; }
        .about-mint-btn:hover .cs-5 { animation-delay: 0.24s; }
        .about-mint-tooltip { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); font-size: 10px; font-style: italic; color: var(--text-muted); white-space: nowrap; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; margin-top: 4px; }
        .about-mint-wrapper:hover .about-mint-tooltip { opacity: 0.7; }

        /* Collect popover menu */
        .collect-popover { position: absolute; top: calc(100% + 8px); right: 0; transform: scale(0.95); background: var(--bg-panel); border: 1px solid var(--border); border-radius: 10px; padding: 6px 0; min-width: 160px; opacity: 0; visibility: hidden; transition: all 0.15s ease; z-index: 100; box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
        .collect-popover.open { opacity: 1; visibility: visible; transform: scale(1); }
        .collect-popover-option { display: block; width: 100%; padding: 10px 16px; font-size: 12px; font-weight: 600; color: var(--text-dim); text-decoration: none; text-align: left; background: none; border: none; cursor: pointer; transition: all 0.15s ease; font-family: inherit; white-space: nowrap; }
        .collect-popover-option:hover { background: rgba(255,255,255,0.05); color: var(--text); }
        .collect-popover-option span { opacity: 0.5; font-weight: 400; margin-left: 4px; }
        .collect-btn-wrapper { position: relative; display: inline-flex; overflow: visible; flex-shrink: 0; }
        /* Light mode popover (for wall view gray mode) */
        .wall-view-modal.wall-gray .collect-popover { background: #fff; border-color: #ddd; box-shadow: 0 8px 24px rgba(0,0,0,0.15); }
        .wall-view-modal.wall-gray .collect-popover-option { color: #666; }
        .wall-view-modal.wall-gray .collect-popover-option:hover { background: rgba(0,0,0,0.05); color: #333; }

        /* Origins section - hover reveal effect */
        /* Origins button in About */
        .origins-title { position: relative; display: inline-flex; align-items: center; }
        .origins-base { display: inline; }
        .origins-reveal { display: inline; max-width: 0; overflow: hidden; transition: max-width 0.3s ease, opacity 0.3s ease; opacity: 0; }
        .origins-s { display: inline; }
        .origins-efdot { position: absolute; right: 100%; margin-right: 8px; font-size: 9px; letter-spacing: 0.15em; color: var(--warm); opacity: 0; transform: translateX(10px); transition: opacity 0.3s ease, transform 0.3s ease; white-space: nowrap; }
        .origins-header:hover .origins-reveal { max-width: 20px; opacity: 1; }
        .origins-header:hover .origins-efdot { opacity: 1; transform: translateX(0); }
        .origins-header { cursor: pointer; }

        /* Timeline View - Full Screen */
        .timeline-view { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-deep); z-index: 2500; display: none; overflow-y: auto; overflow-x: hidden; }
        .timeline-view.open { display: block; }

        .timeline-header { text-align: center; padding: 100px 40px 60px; max-width: 500px; margin: 0 auto; }
        .timeline-logo { font-size: 42px; font-weight: 700; font-family: Helvetica, Arial, sans-serif; color: var(--text); margin: 0 0 16px; line-height: 1; letter-spacing: -0.02em; }
        .timeline-tagline { font-size: 22px; font-weight: 400; color: var(--text); line-height: 1.5; margin: 0 0 12px; font-style: italic; }
        .timeline-tagline em { font-style: normal; color: var(--warm); }
        .timeline-collab { font-size: 10px; color: var(--text-dim); margin-bottom: 0; letter-spacing: 0.05em; text-transform: uppercase; opacity: 0.6; }
        .timeline-collab a { color: var(--text-dim); text-decoration: none; }
        .timeline-collab a:hover { color: var(--warm); }
        /* Video now immediately after title */
        .timeline-video-hero { position: relative; width: calc(100% + 80px); margin-left: -40px; padding-bottom: 56.25%; margin-bottom: 28px; overflow: hidden; border-radius: 0; }
        .timeline-video-hero iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .timeline-video-hero::after { content: ''; position: absolute; inset: 0; background: linear-gradient(to bottom, rgba(10,9,16,0.15) 0%, transparent 20%, transparent 80%, rgba(10,9,16,0.3) 100%); pointer-events: none; }
        .timeline-subhead { display: none; }
        /* Timeline expandable sections - Level 1 */
        .timeline-section { border-top: 1px solid var(--border); }
        .timeline-section-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; cursor: pointer; transition: color 0.2s ease; color: var(--text-muted); }
        .timeline-section-header:hover { color: var(--text); }
        .timeline-section-title { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: inherit; }
        .timeline-section-arrow { font-size: 10px; color: var(--text-muted); transition: transform 0.2s ease; }
        .timeline-section.open .timeline-section-arrow { transform: rotate(180deg); }
        .timeline-section-content { display: none; padding-bottom: 16px; font-size: 13px; line-height: 1.7; color: var(--text-dim); }
        .timeline-section.open .timeline-section-content { display: block; }
        /* Timeline expandable sections - Level 2 (nested) */
        .timeline-subsection { margin-top: 12px; margin-left: 12px; border-left: 2px solid var(--border); padding-left: 16px; }
        .timeline-subsection-header { display: flex; align-items: center; gap: 8px; padding: 10px 0; cursor: pointer; transition: color 0.2s ease; color: var(--text-muted); }
        .timeline-subsection-header:hover { color: var(--text); }
        .timeline-subsection-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: inherit; }
        .timeline-subsection-arrow { font-size: 8px; color: var(--text-muted); transition: transform 0.2s ease; }
        .timeline-subsection.open .timeline-subsection-arrow { transform: rotate(90deg); }
        .timeline-subsection-content { display: none; padding: 8px 0 12px; font-size: 12px; line-height: 1.6; color: var(--text-dim); opacity: 0.85; }
        .timeline-subsection.open .timeline-subsection-content { display: block; }
        /* Video section before culmination */
        .timeline-video-section { position: relative; width: 100%; max-width: 800px; margin: 60px auto 40px; padding-bottom: 56.25%; }
        .timeline-video-section iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 8px; }
        .video-controls { position: absolute; bottom: 16px; left: 16px; display: flex; gap: 8px; z-index: 10; }
        .video-control-btn { width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; backdrop-filter: blur(4px); }
        .video-control-btn:hover { background: rgba(0, 0, 0, 0.8); border-color: rgba(255, 255, 255, 0.4); }
        .video-control-btn.active { background: rgba(232, 184, 109, 0.3); border-color: var(--warm); }
        .volume-indicator { font-size: 10px; position: absolute; top: -20px; left: 50%; transform: translateX(-50%); color: var(--text-muted); opacity: 0; transition: opacity 0.2s ease; white-space: nowrap; }
        .video-control-btn:hover .volume-indicator { opacity: 1; }
        /* Legacy video - no longer used */
        .timeline-video { display: none; }
        .timeline-video-hero { display: none; }
        .timeline-close { position: fixed; top: 24px; right: 28px; font-size: 36px; color: var(--text-muted); cursor: pointer; transition: color 0.2s ease; background: none; border: none; z-index: 2600; }
        .timeline-close:hover { color: var(--text); }
        .timeline-grid-btn { position: fixed; top: 24px; right: 80px; width: 40px; height: 40px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; color: var(--text-muted); font-size: 16px; cursor: pointer; transition: all 0.2s ease; z-index: 2600; display: flex; align-items: center; justify-content: center; }
        .timeline-grid-btn:hover { background: rgba(255,255,255,0.1); color: var(--text); border-color: rgba(255,255,255,0.2); }
        .timeline-container { position: relative; max-width: 900px; margin: 0 auto; padding: 60px 40px 120px; }
        .timeline-line { position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: var(--border); transform: translateX(-50%); z-index: 0; pointer-events: none; opacity: 0.3; mask-image: linear-gradient(to bottom, transparent 0%, black 5%, black 95%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 5%, black 95%, transparent 100%); }
        .timeline-content { position: relative; z-index: 2; }
        .timeline-item img, .timeline-item video { position: relative; z-index: 3; }

        /* Year markers - pill shaped, in front - more prominent */
        .timeline-year { text-align: center; font-size: 13px; font-weight: 800; letter-spacing: 0.18em; color: var(--text); padding: 10px 24px; margin: 60px auto 20px; position: relative; z-index: 10; background: var(--bg-panel); border: 1px solid rgba(255,255,255,0.15); border-radius: 50px; display: inline-block; left: 50%; transform: translateX(-50%); box-shadow: 0 2px 12px rgba(0,0,0,0.3); }

        /* Timeline story one-liners - more legible */
        .timeline-story { text-align: center; font-size: 14px; font-style: italic; color: var(--text-dim); max-width: 440px; margin: 0 auto 36px; padding: 0 24px; line-height: 1.7; opacity: 0.9; }

        /* Timeline items - condensed vertical spacing */
        .timeline-item { position: relative; margin: 40px 0; cursor: pointer; transition: transform 0.4s ease; }
        .timeline-item.left { width: 52%; margin-right: auto; padding-right: 40px; text-align: right; }
        .timeline-item.right { width: 52%; margin-left: auto; padding-left: 40px; text-align: left; }
        .timeline-item.center { width: 70%; margin: 50px auto; text-align: center; }
        .timeline-item.wide { width: 50%; }

        .timeline-item img, .timeline-item video { width: 100%; border-radius: 0; transition: transform 0.4s ease, box-shadow 0.4s ease, border-radius 0.4s ease; }
        .timeline-item video { display: block; }
        .timeline-item:hover img, .timeline-item:hover video { transform: scale(1.02); box-shadow: 0 20px 60px rgba(0,0,0,0.5); border-radius: 12px; }
        .timeline-item:hover { transform: translateY(-4px); }

        .timeline-item-info { margin-top: 12px; }
        .timeline-item-title { display: block; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; color: var(--text); }
        .timeline-item-year { display: block; font-size: 11px; color: var(--text-muted); margin-bottom: 8px; letter-spacing: 0.05em; }
        .timeline-item-subtitle { display: block; font-size: 10px; color: var(--text-muted); margin-top: 6px; opacity: 0.8; }
        /* Expandable description with "more" button */
        .timeline-desc-wrapper { margin-top: 8px; }
        .timeline-more-btn { display: inline-block; font-size: 9px; color: var(--text-muted); opacity: 0.5; cursor: pointer; letter-spacing: 0.1em; text-transform: uppercase; transition: opacity 0.3s ease, color 0.3s ease; background: none; border: none; padding: 0; }
        .timeline-more-btn:hover { opacity: 1; color: var(--text); }
        .timeline-more-btn::before { content: '+ '; }
        .timeline-desc-wrapper.expanded .timeline-more-btn::before { content: 'âˆ’ '; }
        .timeline-item-desc { display: none; font-size: 10px; color: var(--text-muted); line-height: 1.6; margin-top: 6px; max-width: 280px; opacity: 0.7; }
        .timeline-desc-wrapper.expanded .timeline-item-desc { display: block; }
        .timeline-item.left .timeline-item-desc { margin-left: auto; text-align: right; }
        .timeline-item.right .timeline-item-desc { margin-right: auto; text-align: left; }
        .timeline-item.center .timeline-item-desc, .timeline-item.featured .timeline-item-desc { margin: 6px auto; text-align: center; }
        .timeline-item.left .timeline-desc-wrapper { text-align: right; }
        .timeline-item.right .timeline-desc-wrapper { text-align: left; }
        .timeline-item.center .timeline-desc-wrapper, .timeline-item.featured .timeline-desc-wrapper { text-align: center; }
        .timeline-item-status { display: block; font-size: 12px; color: var(--warm); margin-top: 8px; font-weight: 500; }
        .timeline-item-medium { display: inline-block; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-muted); background: var(--bg-input); padding: 4px 10px; border-radius: 20px; margin-top: 10px; opacity: 0.7; }
        .timeline-item.physical { opacity: 0.9; }
        .timeline-item.physical img { filter: saturate(0.95); }

        /* Provenance inline */
        .timeline-provenance { margin-top: 8px; font-size: 10px; font-weight: 400; letter-spacing: 0.08em; color: var(--text-muted); }
        .timeline-provenance::before { content: 'collected by '; opacity: 0.5; }
        .timeline-provenance .provenance-link { margin-right: 6px; font-size: 11px; opacity: 0.5; text-decoration: none; color: var(--text-muted); cursor: pointer; transition: opacity 0.6s ease, color 0.6s ease; }
        .timeline-provenance .provenance-link:hover { opacity: 1; color: var(--warm); }
        .timeline-provenance .provenance-name { text-transform: uppercase; }

        /* Timeline item actions - share/download on hover */
        .timeline-item-actions { position: absolute; top: 12px; right: 12px; display: flex; gap: 6px; opacity: 0; transition: opacity 0.3s ease; z-index: 5; }
        .timeline-item.left .timeline-item-actions { right: auto; left: 12px; }
        .timeline-item:hover .timeline-item-actions { opacity: 1; }
        .timeline-action-btn { width: 32px; height: 32px; border-radius: 50%; background: rgba(10, 9, 16, 0.8); backdrop-filter: blur(8px); border: none; color: var(--text-dim); font-size: 13px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .timeline-action-btn:hover { background: var(--warm); color: var(--bg-deep); transform: scale(1.1); }

        /* Inline action buttons for all timeline pieces */
        .timeline-item-actions-inline { display: inline-flex; gap: 6px; margin-top: 10px; align-items: center; }
        .timeline-action-inline { width: 28px; height: 28px; border-radius: 50%; background: var(--bg-input); border: none; color: var(--text-muted); font-size: 12px; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; justify-content: center; text-decoration: none; opacity: 0.7; }
        .timeline-action-inline:hover { background: var(--warm); color: var(--bg-deep); transform: scale(1.1); opacity: 1; }
        .timeline-action-inline.download-btn { font-size: 14px; }
        .timeline-action-inline.share-btn { font-family: Arial, sans-serif; font-weight: 700; font-size: 11px; }
        .timeline-print-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); opacity: 0.6; margin-left: 8px; }
        .timeline-print-remaining { font-size: 7px; color: var(--text-muted); opacity: 0; transition: opacity 0.2s ease; margin-left: 4px; }
        .timeline-item:hover .timeline-print-remaining { opacity: 0.5; }

        /* Thank You section */
        /* Explore More Section - simplified black on black */
        .timeline-explore-more { text-align: center; padding: 80px 40px 100px; max-width: 500px; margin: 0 auto; }
        .timeline-explore-headline { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-muted); margin: 0 0 24px; opacity: 0.5; }
        .timeline-explore-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .timeline-explore-btn { display: flex; flex-direction: column; align-items: center; padding: 14px 12px; background: transparent; border: 1px solid rgba(255, 255, 255, 0.06); border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-decoration: none; }
        .timeline-explore-btn:hover { border-color: rgba(255, 255, 255, 0.15); background: rgba(255, 255, 255, 0.02); }
        .explore-btn-icon { display: none; }
        .explore-btn-label { font-size: 11px; font-weight: 600; color: var(--text-muted); margin-bottom: 2px; transition: color 0.3s ease; }
        .timeline-explore-btn:hover .explore-btn-label { color: var(--text); }
        .explore-btn-desc { font-size: 9px; color: var(--text-muted); opacity: 0.4; transition: opacity 0.3s ease; }
        .timeline-explore-btn:hover .explore-btn-desc { opacity: 0.7; }

        /* Timeline Year Nav - sticky sidebar on large screens */
        .timeline-year-nav { display: none; position: fixed; left: 28px; top: 50%; transform: translateY(-50%); z-index: 2550; }
        @media (min-width: 1200px) {
            .timeline-year-nav { display: flex; flex-direction: column; gap: 8px; }
        }
        .timeline-year-nav-item { font-size: 10px; font-weight: 600; color: var(--text-muted); opacity: 0.3; cursor: pointer; padding: 4px 0; transition: all 0.2s ease; text-decoration: none; }
        .timeline-year-nav-item:hover { opacity: 0.8; color: var(--text); }
        .timeline-year-nav-item.active { opacity: 1; color: var(--warm); }

        /* Featured/bookend pieces - centered and larger */
        .timeline-item.featured { width: 70%; margin: 80px auto; text-align: center; }
        .timeline-item.featured img { max-width: 100%; }

        /* Hero centered item - larger with line fadeout */
        .timeline-item.hero-center { width: 80%; max-width: 500px; margin: 80px auto; text-align: center; position: relative; z-index: 5; }
        .timeline-item.hero-center img { max-width: 100%; border-radius: 8px; }
        .timeline-item.hero-center .timeline-item-info { opacity: 1; transform: translateY(0); }
        /* Fade out the timeline line around hero items */
        .timeline-item.hero-center::before { content: ''; position: absolute; left: 50%; top: -60px; bottom: -60px; width: 80px; transform: translateX(-50%); background: var(--bg-deep); z-index: -1; }

        /* City in Bloom - dual image with hover swap */
        .timeline-item.bloom-dual { width: 70%; max-width: 450px; margin: 80px auto; text-align: center; position: relative; z-index: 5; }
        .timeline-item.bloom-dual::before { content: ''; position: absolute; left: 50%; top: -60px; bottom: -60px; width: 80px; transform: translateX(-50%); background: var(--bg-deep); z-index: -1; }
        .bloom-dual-container { position: relative; overflow: hidden; border-radius: 8px; }
        .bloom-dual-container img { width: 100%; display: block; transition: opacity 0.4s ease; }
        .bloom-dual-container .bloom-mural { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; }
        .bloom-dual-container:hover .bloom-mural { opacity: 1; }
        .bloom-dual-container:hover .bloom-digital { opacity: 0; }
        .bloom-hover-hint { font-size: 9px; color: var(--text-muted); margin-top: 8px; opacity: 0.6; letter-spacing: 0.05em; }

        /* Over the Bridge - hover animation swap */
        .over-bridge-img-container { position: relative; overflow: hidden; border-radius: 8px; }
        .over-bridge-img-container img { width: 100%; display: block; transition: opacity 0.4s ease; }
        .over-bridge-img-container .over-bridge-animated { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; }
        .over-bridge-img-container:hover .over-bridge-animated { opacity: 1; }
        .over-bridge-img-container:hover .over-bridge-static { opacity: 0; }

        /* Desert Grid - side by side day/night */
        .timeline-item.desert-grid-dual { width: 80%; max-width: 600px; margin: 80px auto; text-align: center; position: relative; z-index: 5; }
        .timeline-item.desert-grid-dual::before { content: ''; position: absolute; left: 50%; top: -60px; bottom: -60px; width: 80px; transform: translateX(-50%); background: var(--bg-deep); z-index: -1; }
        .desert-grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; border-radius: 8px; overflow: hidden; }
        .desert-grid-container img { width: 100%; display: block; transition: transform 0.3s ease, filter 0.3s ease; border-radius: 6px; }
        .desert-grid-container img:hover { transform: scale(1.02); filter: brightness(1.1); }
        .desert-grid-hint { font-size: 9px; color: var(--text-muted); margin-top: 8px; opacity: 0.6; letter-spacing: 0.05em; display: block; }

        /* Marfa Community Mural Video */
        .marfa-video-section { width: 90%; max-width: 700px; margin: 80px auto; }
        .marfa-video-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; }
        .marfa-video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .marfa-video-controls { display: flex; justify-content: center; gap: 8px; margin-top: 12px; }
        .marfa-control-btn { background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-muted); width: 36px; height: 36px; border-radius: 50%; cursor: pointer; font-size: 12px; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .marfa-control-btn:hover { background: var(--bg-input); color: var(--text); border-color: var(--text-muted); }

        /* Available item highlight */
        .timeline-item.available img { box-shadow: 0 0 0 2px var(--warm); }
        .timeline-item.available .timeline-item-info { opacity: 1; transform: translateY(0); }

        /* Grouped timeline items - murals, open minds, city pairs */
        .timeline-group { width: 90%; max-width: 700px; margin: 60px auto; text-align: center; position: relative; z-index: 5; }
        .timeline-group::before { content: ''; position: absolute; left: 50%; top: -40px; bottom: -40px; width: 100px; transform: translateX(-50%); background: var(--bg-deep); z-index: -1; }
        .timeline-group-title { font-size: 18px; font-weight: 600; color: var(--text); margin-bottom: 8px; }
        .timeline-group-subtitle { font-size: 11px; color: var(--text-muted); margin-bottom: 20px; letter-spacing: 0.05em; line-height: 1.7; }
        .timeline-group-grid { display: grid; gap: 12px; }
        .timeline-group-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .timeline-group-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .timeline-group-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .timeline-group-item { position: relative; cursor: pointer; }
        .timeline-group-item-img { overflow: hidden; border-radius: 6px; }
        .timeline-group-item img { width: 100%; display: block; transition: transform 0.3s ease, filter 0.3s ease; }
        .timeline-group-item:hover img { transform: scale(1.05); filter: brightness(1.1); }
        .timeline-group-item-info { padding: 10px 4px 0; text-align: center; }
        .timeline-group-item-title { font-size: 10px; font-weight: 600; color: var(--text-dim); display: block; }
        .timeline-group-item-year { font-size: 9px; color: var(--text-muted); display: block; margin-top: 2px; }
        .timeline-group-item-collector { font-size: 8px; color: var(--text-muted); display: block; margin-top: 3px; opacity: 0.6; }
        .timeline-group-collectors { font-size: 10px; color: var(--text-muted); margin-top: 16px; letter-spacing: 0.03em; }
        /* Vertical pair layout for portrait cities */
        .timeline-group-grid.vertical-pair { grid-template-columns: repeat(2, 1fr); max-width: 500px; margin: 0 auto; }
        .timeline-group-grid.vertical-pair .timeline-group-item img { aspect-ratio: 9/16; object-fit: cover; }

        /* Murals grid - crop all to same aspect ratio */
        .timeline-group-grid.murals-grid .timeline-group-item img { aspect-ratio: 4/3; object-fit: cover; }
        .timeline-group-item.mural-crop img { object-position: center; }

        /* Open Minds 2x2 grid */
        .timeline-group-grid.openminds-grid { max-width: 500px; margin: 0 auto; }
        .timeline-group-grid.openminds-grid .timeline-group-item img { aspect-ratio: 1/1; object-fit: cover; }

        /* Italy 3x3 grid - no hover/scroll effects, plain static images */
        .timeline-item.italy { transition: none; opacity: 1; transform: none; }
        .timeline-item.italy:hover { transform: none; }
        .timeline-item.italy:hover img { transform: none; box-shadow: none; border-radius: 0; }
        .timeline-italy-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; overflow: hidden; }
        .timeline-italy-grid img { width: 100%; aspect-ratio: 9/16; object-fit: cover; display: block; transition: none; }
        .timeline-italy-collectors { font-size: 10px; color: var(--text-muted); margin-top: 12px; letter-spacing: 0.03em; }
        .timeline-italy-collectors .collector-link { cursor: pointer; transition: color 0.2s ease; }
        .timeline-italy-collectors .collector-link:hover { color: var(--yellow); }

        /* Culmination - generative collection */
        .timeline-item.culmination { margin: 80px auto; }
        .timeline-culmination { padding: 60px 40px; border: 1px solid var(--border); border-radius: 16px; background: rgba(232, 184, 109, 0.03); }
        .timeline-culmination-title { font-size: 28px; font-weight: 700; font-family: Helvetica, Arial, sans-serif; margin-bottom: 8px; }
        .timeline-culmination-subtitle { font-size: 12px; color: var(--warm); letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 16px; }
        .timeline-culmination-desc { font-size: 14px; color: var(--text-dim); margin-bottom: 24px; }
        .timeline-preview-grid { display: flex; flex-direction: column; gap: 4px; margin-bottom: 32px; overflow: hidden; margin-left: -40px; margin-right: -40px; }
        .preview-row { display: flex; gap: 4px; }
        .preview-row-1 { animation-direction: normal; }
        .preview-row-2 { animation-direction: reverse; animation-duration: 50s; }
        .preview-row-3 { animation-direction: normal; animation-duration: 45s; }
        @keyframes scrollBricks { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
        .timeline-preview-grid img { width: 45px; height: 80px; aspect-ratio: 9/16; object-fit: cover; flex-shrink: 0; transition: transform 0.3s ease, filter 0.3s ease; cursor: pointer; border-radius: 4px; }
        .timeline-preview-grid img:hover { transform: scale(1.1); filter: brightness(1.15); z-index: 1; }
        .timeline-culmination-btn { display: inline-block; font-size: 11px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; padding: 14px 32px; border-radius: 50px; border: 1px solid var(--warm); background: none; color: var(--warm); cursor: pointer; transition: all 0.3s ease; text-decoration: none; }
        .timeline-culmination-btn:hover { background: var(--warm); color: var(--bg-deep); }

        /* What City Next? */
        .whats-next-section { margin: 80px auto; width: 100%; display: flex; justify-content: center; }
        .whats-next { text-align: center; padding: 50px 40px; border: 1px solid var(--border); border-radius: 16px; background: rgba(255, 255, 255, 0.02); max-width: 450px; margin: 0 auto; }

        /* O.M.A.G.E. Inquiry link */
        .timeline-inquiry-link { display: inline-block; margin-top: 12px; font-size: 10px; color: var(--text-muted); text-decoration: none; letter-spacing: 0.03em; transition: color 0.2s ease; }
        .timeline-inquiry-link:hover { color: var(--warm); }
        .whats-next-title { font-size: 22px; font-weight: 700; margin-bottom: 12px; }
        .whats-next-desc { font-size: 13px; color: var(--text-dim); line-height: 1.7; margin-bottom: 24px; max-width: 340px; margin-left: auto; margin-right: auto; }
        .whats-next-btn { display: inline-block; font-size: 11px; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; padding: 12px 28px; border-radius: 50px; border: 1px solid var(--text-muted); background: none; color: var(--text-dim); cursor: pointer; transition: all 0.3s ease; text-decoration: none; }
        .whats-next-btn:hover { border-color: var(--warm); color: var(--warm); background: rgba(232, 184, 109, 0.08); }

        .timeline-mint-btn { position: relative; overflow: hidden; }
        .timeline-mint-btn .mint-animation { position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(232, 184, 109, 0.3), transparent); }
        @keyframes mintShimmer { 0% { left: -100%; } 50%, 100% { left: 100%; } }

        /* Timeline entrance animations */
        .timeline-item { opacity: 0; transform: translateY(30px); transition: opacity 0.6s ease, transform 0.6s ease; }
        .timeline-item.visible { opacity: 1; transform: translateY(0); }
        .timeline-item.left.visible { animation: slideInLeft 0.6s ease forwards; }
        .timeline-item.right.visible { animation: slideInRight 0.6s ease forwards; }
        @keyframes slideInLeft { from { opacity: 0; transform: translateX(-30px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(30px); } to { opacity: 1; transform: translateX(0); } }

        /* Collect section - simplified physical/digital choice */
        .timeline-item.collect-section { margin: 60px auto; cursor: default; }
        .timeline-item.collect-section:hover { transform: none; }
        .timeline-collect { text-align: center; padding: 40px 30px; }
        .timeline-collect-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-muted); margin-bottom: 24px; }
        .timeline-collect-buttons { display: flex; gap: 16px; justify-content: center; }
        .timeline-collect-btn { display: flex; flex-direction: column; align-items: center; padding: 20px 28px; background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 12px; text-decoration: none; transition: all 0.3s ease; min-width: 140px; }
        .timeline-collect-btn:hover { border-color: rgba(255, 255, 255, 0.2); background: rgba(255, 255, 255, 0.06); transform: translateY(-2px); }
        .collect-btn-icon { font-size: 18px; margin-bottom: 8px; opacity: 0.5; }
        .timeline-collect-btn:hover .collect-btn-icon { opacity: 0.8; }
        .collect-btn-label { font-size: 13px; font-weight: 600; color: var(--text-dim); margin-bottom: 4px; }
        .collect-btn-desc { font-size: 9px; color: var(--text-muted); opacity: 0.7; }

        @media (max-width: 768px) {
            .timeline-collect { padding: 30px 20px; }
            .timeline-collect-buttons { flex-direction: column; gap: 12px; }
            .timeline-collect-btn { min-width: 100%; }
        }

        /* Origins Lightbox */
        .origins-lightbox { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; padding: 40px; }
        .origins-lightbox.open { display: flex; }
        .origins-lightbox-close { position: absolute; top: 20px; right: 24px; font-size: 32px; color: var(--text-muted); cursor: pointer; transition: color 0.2s ease; background: none; border: none; }
        .origins-lightbox-close:hover { color: var(--text); }
        .origins-lightbox-img { max-width: 80vw; max-height: 70vh; object-fit: contain; border-radius: 8px; margin-bottom: 24px; }
        .origins-lightbox-title { font-size: 18px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; }
        .origins-lightbox-year { font-size: 12px; color: var(--text-muted); margin-bottom: 16px; }
        .origins-lightbox-price { font-size: 14px; color: var(--warm); margin-bottom: 16px; }
        .origins-lightbox-btn { font-size: 11px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; padding: 12px 28px; border-radius: 50px; border: 1px solid var(--text-muted); background: none; color: var(--text); cursor: pointer; transition: all 0.3s ease; text-decoration: none; }
        .origins-lightbox-btn:hover { background: var(--text); color: var(--bg-deep); }

        @media (max-width: 768px) {
            .about-modal { padding: 24px 16px; }
            .about-title { font-size: 28px; }
            .about-collab-short { display: none; }
            .about-collab-full { position: static; opacity: 1; pointer-events: auto; }
            .about-intro, .about-section-content, .about-footer-text { font-size: 13px; }
            .timeline-header { padding: 40px 20px 30px; }
            .timeline-headline { font-size: 28px; }
            .timeline-collab { font-size: 10px; }
            .timeline-video-hero { width: calc(100% + 40px); margin-left: -20px; }
            .timeline-subhead { font-size: 13px; }
            .timeline-section-content { font-size: 12px; }
            .timeline-subsection { margin-left: 8px; padding-left: 12px; }
            .timeline-subsection-content { font-size: 11px; }
            .timeline-container { padding: 40px 16px 100px; }
            .timeline-line { display: none; }
            .timeline-item.left, .timeline-item.right, .timeline-item.featured { width: 100%; padding: 0; text-align: center; margin: 32px auto; }
            .timeline-item.center { width: 100%; }
            .timeline-item.hero-center, .timeline-item.bloom-dual, .timeline-item.desert-grid-dual { width: 100%; max-width: 100%; margin: 40px auto; }
            .timeline-item.hero-center::before, .timeline-item.bloom-dual::before, .timeline-item.desert-grid-dual::before { display: none; }
            .timeline-group { width: 100%; max-width: 100%; margin: 40px auto; }
            .timeline-group::before { display: none; }
            .timeline-group-grid.cols-3, .timeline-group-grid.cols-4 { grid-template-columns: repeat(2, 1fr); }
            .timeline-group-grid.murals-grid .timeline-group-item:last-child { grid-column: 1 / -1; justify-self: center; max-width: calc(50% - 6px); }
            .timeline-group-title { font-size: 16px; }
            .timeline-group-subtitle { font-size: 10px; }
            .bloom-hover-hint { display: none; }
            .timeline-year { margin: 40px auto; }
            .timeline-item-info { opacity: 1; transform: translateY(0); }
            .timeline-preview-grid { margin-left: -16px; margin-right: -16px; }
            .timeline-preview-grid img { width: 34px; height: 60px; }
            .timeline-culmination { padding: 40px 20px; }
            .timeline-culmination-title { font-size: 22px; }
            .timeline-explore-more { padding: 60px 20px 80px; }
            .timeline-explore-grid { grid-template-columns: 1fr; gap: 12px; }
            .timeline-explore-btn { padding: 16px 12px; border-radius: 10px; width: 100%; }
            .origins-lightbox-img { max-width: 95vw; max-height: 60vh; }
        }

        /* Timeline Zoom/Focus View */
        .timeline-zoom { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-deep); z-index: 2600; display: none; }
        .timeline-zoom.open { display: flex; }
        .timeline-zoom-main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; }
        .timeline-zoom-artwork { max-width: 70vw; max-height: 60vh; object-fit: contain; border-radius: 0; transition: opacity 0.4s ease; }
        .timeline-zoom-info { text-align: center; margin-top: 32px; max-width: 500px; display: flex; flex-direction: column; align-items: center; }
        .timeline-zoom-title { font-size: 20px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; }
        .timeline-zoom-year { font-size: 11px; color: var(--text-muted); margin-bottom: 12px; }
        .timeline-zoom-desc { font-size: 14px; color: var(--text-muted); line-height: 1.8; font-style: italic; margin-bottom: 20px; max-width: 450px; }
        .timeline-zoom-provenance { font-size: 10px; color: var(--text-dim); opacity: 0.6; }
        .timeline-zoom-provenance a { color: var(--text-dim); text-decoration: none; transition: color 0.3s ease; }
        .timeline-zoom-provenance a:hover { color: var(--warm); }
        .timeline-zoom-buttons { display: flex; gap: 10px; justify-content: center; align-items: center; margin-top: 16px; flex-wrap: wrap; width: 100%; }
        .timeline-zoom-print-btn, .timeline-zoom-offer-btn { display: none; font-size: 10px; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; padding: 10px 20px; border-radius: 50px; border: 1px solid var(--text-muted); background: none; color: var(--text-dim); text-decoration: none; transition: all 0.3s ease; }
        .timeline-zoom-print-btn.visible, .timeline-zoom-offer-btn.visible { display: inline-flex; align-items: center; justify-content: center; }
        .timeline-zoom-print-btn:hover { border-color: var(--warm); color: var(--warm); background: rgba(232, 184, 109, 0.1); }
        .timeline-zoom-offer-btn { font-size: 9px; padding: 8px 16px; opacity: 0.6; }
        .timeline-zoom-offer-btn:hover { opacity: 1; border-color: var(--text); color: var(--text); }
        .timeline-zoom-nav { position: absolute; top: 50%; transform: translateY(-50%); font-size: 32px; color: var(--text-muted); background: none; border: none; cursor: pointer; padding: 20px; opacity: 0.4; transition: opacity 0.3s ease; }
        .timeline-zoom-nav:hover { opacity: 1; }
        .timeline-zoom-nav.prev { left: 20px; }
        .timeline-zoom-nav.next { right: 20px; }
        .timeline-zoom-close { position: absolute; top: 24px; right: 28px; font-size: 32px; color: var(--text-muted); background: none; border: none; cursor: pointer; transition: color 0.3s ease; }
        .timeline-zoom-close:hover { color: var(--text); }
        .timeline-zoom-actions { position: absolute; top: 24px; left: 28px; display: flex; gap: 8px; }
        .timeline-zoom-action-btn { width: 40px; height: 40px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 1px solid var(--border); color: var(--text-dim); font-size: 16px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .timeline-zoom-action-btn:hover { background: var(--warm); color: var(--bg-deep); border-color: var(--warm); transform: scale(1.05); }
        .timeline-zoom-strip { position: absolute; bottom: 0; left: 0; right: 0; height: 80px; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; gap: 8px; padding: 0 60px; overflow-x: auto; }
        .timeline-zoom-thumb { width: 36px; height: 64px; aspect-ratio: 9/16; object-fit: cover; border-radius: 4px; cursor: pointer; opacity: 0.4; transition: opacity 0.3s ease, transform 0.3s ease; flex-shrink: 0; }
        .timeline-zoom-thumb:hover { opacity: 0.8; }
        .timeline-zoom-thumb.active { opacity: 1; transform: scale(1.1); box-shadow: 0 0 0 2px var(--warm); }

        /* Italy Gallery View */
        .italy-gallery { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-deep); z-index: 2600; display: none; overflow-y: auto; }
        .italy-gallery.open { display: block; }
        .italy-gallery-close { display: none; }
        .italy-gallery-header { text-align: center; padding: 80px 40px 40px; }
        .italy-gallery-title { font-size: 28px; font-weight: 700; margin-bottom: 8px; }
        .italy-gallery-subtitle { font-size: 12px; color: var(--text-muted); letter-spacing: 0.1em; text-transform: uppercase; }
        .italy-gallery-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 32px; max-width: 900px; margin: 0 auto; padding: 0 40px 80px; }
        .italy-gallery-item { text-align: center; }
        .italy-gallery-frame { border-radius: 2px; }
        .italy-gallery-frame img { width: 100%; display: block; }
        .italy-gallery-info { margin-top: 16px; }
        .italy-gallery-name { font-size: 12px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
        .italy-gallery-collector { font-size: 10px; color: var(--text-muted); }
        .italy-gallery-link { display: inline-block; margin-top: 40px; font-size: 11px; color: var(--text-muted); text-decoration: none; letter-spacing: 0.05em; transition: color 0.2s ease; }
        .italy-gallery-link:hover { color: var(--warm); }
        @media (max-width: 768px) {
            .italy-gallery-grid { grid-template-columns: repeat(2, 1fr); gap: 20px; padding: 0 20px 60px; }
            .italy-gallery-header { padding: 60px 20px 30px; }
            .italy-gallery-title { font-size: 22px; }
        }
        @media (max-width: 480px) {
            .italy-gallery-grid { grid-template-columns: 1fr; max-width: 280px; }
        }

        /* Magnifying Loupe */
        .loupe-btn { opacity: 0.5; }
        .loupe-btn.active { opacity: 1; background: var(--warm); color: var(--bg-deep); border-color: var(--warm); }
        .loupe-container { position: relative; cursor: crosshair; }
        .loupe-container.loupe-active { cursor: none; }
        .loupe { position: fixed; width: 180px; height: 180px; border-radius: 50%; border: 2px solid var(--warm); background: var(--bg-deep); overflow: hidden; pointer-events: none; opacity: 0; transition: opacity 0.15s ease; z-index: 2700; box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(255,255,255,0.1); }
        .loupe.visible { opacity: 1; }
        .loupe-inner { position: absolute; width: 100%; height: 100%; background-size: cover; background-repeat: no-repeat; image-rendering: auto; }
        .loupe-crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; pointer-events: none; }
        .loupe-crosshair::before, .loupe-crosshair::after { content: ''; position: absolute; background: rgba(232, 184, 109, 0.3); }
        .loupe-crosshair::before { width: 1px; height: 100%; left: 50%; top: 0; }
        .loupe-crosshair::after { width: 100%; height: 1px; top: 50%; left: 0; }
        .loupe-zoom-label { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); font-size: 9px; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; color: var(--warm); background: rgba(10, 9, 16, 0.8); padding: 3px 8px; border-radius: 10px; }

        @media (max-width: 768px) {
            .timeline-zoom-main { padding: 20px; }
            .timeline-zoom-artwork { max-width: 90vw; max-height: 50vh; }
            .timeline-zoom-info { margin-top: 20px; }
            .timeline-zoom-title { font-size: 16px; }
            .timeline-zoom-desc { font-size: 12px; }
            .timeline-zoom-nav { font-size: 24px; padding: 10px; }
            .timeline-zoom-strip { height: 70px; gap: 6px; }
            .timeline-zoom-thumb { width: 28px; height: 50px; }
            /* Timeline frame on mobile */
            .timeline-frame-wrapper { max-width: 90vw; max-height: 55vh; padding: 8px; }
            .timeline-frame-inner img { max-height: 50vh; }
            .timeline-frame-info { margin-top: 20px; }
            .timeline-frame-title { font-size: 14px; }
            .timeline-frame-nav { width: 36px; height: 36px; font-size: 16px; }
            .timeline-frame-nav.prev { left: 12px; }
            .timeline-frame-nav.next { right: 12px; }
            .timeline-frame-close, .timeline-frame-mode { width: 36px; height: 36px; font-size: 16px; }
            .timeline-frame-view-btn { bottom: 24px; padding: 10px 20px; font-size: 9px; }
            /* Timeline header on mobile */
            .timeline-header { padding: 60px 24px 40px; }
            .timeline-logo { font-size: 32px; }
            .timeline-tagline { font-size: 18px; }
        }

        /* Framed Mockup View - off-white wall with floater frame */
        .frame-mockup {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            /* Off-white warm wall */
            background: #f5f3f0;
            z-index: 2100; display: none; align-items: center; justify-content: center;
        }
        .frame-mockup.open { display: flex; }
        /* Subtle lighting on wall - soft gray shadow rectangles */
        .frame-mockup::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Top-left light source glow */
                radial-gradient(ellipse 80% 60% at 25% 25%, rgba(255,255,255,0.6) 0%, transparent 50%),
                /* Subtle bottom-right shadow */
                radial-gradient(ellipse 70% 50% at 80% 85%, rgba(0,0,0,0.04) 0%, transparent 40%);
            pointer-events: none;
        }
        .frame-mockup-content { display: flex; align-items: center; justify-content: center; padding: 60px; width: 100%; height: 100%; position: relative; }
        /* Light wood floater frame */
        .frame-wrapper {
            position: relative;
            background: #c4a47a; /* Light wood frame */
            padding: 6px; /* Thin frame face */
            max-width: 80vw;
            max-height: 80vh;
            /* Frame shadow on wall - blurry gray rectangles */
            box-shadow:
                /* Main drop shadow - blurry */
                8px 12px 30px rgba(0,0,0,0.18),
                15px 20px 50px rgba(0,0,0,0.12),
                /* Tighter shadow for depth */
                3px 4px 10px rgba(0,0,0,0.1);
        }
        /* White mat between frame and art */
        .frame-inner {
            position: relative;
            background: #ffffff;
            padding: 8px; /* Mat width */
            box-shadow:
                inset 0 0 2px rgba(0,0,0,0.08),
                inset 0 1px 1px rgba(0,0,0,0.05);
        }
        /* The art floats above the shadow */
        .frame-inner img {
            display: block;
            width: 100%;
            height: auto;
            max-height: calc(80vh - 34px);
            object-fit: contain;
            position: relative;
            /* Art lifts slightly from the dark recess */
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .frame-mockup-close { position: absolute; top: 24px; right: 24px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.95); color: #555; font-size: 20px; cursor: pointer; border-radius: 50%; box-shadow: 0 2px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .frame-mockup-close:hover { background: #333; color: #fff; transform: scale(1.05); }
        .frame-mockup-download { position: absolute; top: 24px; right: 80px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.95); color: #555; font-size: 20px; cursor: pointer; border-radius: 50%; box-shadow: 0 2px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; font-weight: bold; }
        .frame-mockup-download:hover { background: var(--teal); color: #000; transform: scale(1.05); }
        .frame-mockup-order { position: absolute; top: 24px; right: 136px; height: 44px; border: none; background: rgba(255,255,255,0.95); color: #555; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.06em; cursor: pointer; border-radius: 22px; padding: 0 18px; box-shadow: 0 2px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; text-decoration: none; white-space: nowrap; }
        .frame-mockup-order:hover { background: var(--warm); color: #000; transform: scale(1.05); }
        /* Frame mockup navigation */
        .frame-mockup-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.9); color: #555; font-size: 18px; cursor: pointer; border-radius: 50%; box-shadow: 0 2px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .frame-mockup-nav:hover { background: #333; color: #fff; transform: translateY(-50%) scale(1.05); }
        .frame-mockup-nav.prev { left: 24px; }
        .frame-mockup-nav.next { right: 24px; }
        .frame-mockup-nav:disabled { opacity: 0.3; cursor: default; }
        .frame-mockup-nav:disabled:hover { background: rgba(255,255,255,0.9); color: #555; transform: translateY(-50%); }
        /* Frame mockup dark mode toggle */
        .frame-mockup-mode { position: absolute; top: 24px; left: 24px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.95); color: #555; font-size: 16px; cursor: pointer; border-radius: 50%; box-shadow: 0 2px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .frame-mockup-mode:hover { background: #333; color: #fff; transform: scale(1.05); }
        /* Dark mode styles */
        .frame-mockup.dark-mode { background: #0a0a0a; }
        .frame-mockup.dark-mode::before { background: radial-gradient(ellipse 80% 60% at 25% 25%, rgba(255,255,255,0.03) 0%, transparent 50%), radial-gradient(ellipse 70% 50% at 80% 85%, rgba(0,0,0,0.2) 0%, transparent 40%); }
        .frame-mockup.dark-mode .frame-wrapper { background: #1a1a1a; box-shadow: 8px 12px 30px rgba(0,0,0,0.5), 15px 20px 50px rgba(0,0,0,0.4), 3px 4px 10px rgba(0,0,0,0.3); }
        .frame-mockup.dark-mode .frame-inner { background: #e8e6e2; }
        .frame-mockup.dark-mode .frame-mockup-close, .frame-mockup.dark-mode .frame-mockup-download, .frame-mockup.dark-mode .frame-mockup-nav, .frame-mockup.dark-mode .frame-mockup-mode, .frame-mockup.dark-mode .frame-mockup-order { background: rgba(30,30,30,0.9); color: #888; }
        .frame-mockup.dark-mode .frame-mockup-close:hover, .frame-mockup.dark-mode .frame-mockup-download:hover, .frame-mockup.dark-mode .frame-mockup-nav:hover, .frame-mockup.dark-mode .frame-mockup-mode:hover, .frame-mockup.dark-mode .frame-mockup-order:hover { background: #fff; color: #000; }
        .frame-mockup.dark-mode .frame-mockup-mode { background: rgba(255,255,255,0.1); color: #c9a227; }
        /* Frame color picker */
        .frame-mockup-colors { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; gap: 6px; z-index: 10; background: rgba(255,255,255,0.6); padding: 4px 10px; border-radius: 10px 10px 0 0; box-shadow: none; }
        .frame-mockup.dark-mode .frame-mockup-colors { background: rgba(30,30,30,0.5); }
        .frame-color-btn { width: 14px; height: 14px; border-radius: 50%; border: 1.5px solid transparent; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
        .frame-color-btn:hover { transform: scale(1.15); }
        .frame-color-btn.active { border-color: var(--warm); box-shadow: 0 0 0 1.5px rgba(201, 162, 39, 0.3); }
        .frame-color-btn[data-color="light-wood"] { background: #c4a47a; }
        .frame-color-btn[data-color="white"] { background: #f5f3f0; }
        .frame-color-btn[data-color="black"] { background: #1a1a1a; }
        .frame-color-btn[data-color="dark-wood"] { background: #5a3d2b; }
        .frame-mockup-artwork { display: flex; flex-direction: column; align-items: center; gap: 16px; }
        .frame-mockup-label { font-size: 12px; font-weight: 600; color: #666; letter-spacing: 0.1em; margin-bottom: -10px; }
        .frame-mockup.dark-mode .frame-mockup-label { color: #888; }
        .frame-mockup-collector { font-size: 10px; font-weight: 500; color: #999; letter-spacing: 0.08em; text-transform: uppercase; margin-bottom: -8px; }
        .frame-mockup.dark-mode .frame-mockup-collector { color: #555; }
        /* Frame color overrides */
        .frame-mockup .frame-wrapper.frame-white { background: #faf9f7; }
        .frame-mockup .frame-wrapper.frame-white .frame-inner { background: #ffffff; }
        .frame-mockup .frame-wrapper.frame-black { background: #1a1a1a; }
        .frame-mockup .frame-wrapper.frame-black .frame-inner { background: #f5f3f0; }
        .frame-mockup .frame-wrapper.frame-dark-wood { background: #5a3d2b; }
        .frame-mockup .frame-wrapper.frame-dark-wood .frame-inner { background: #faf9f7; }
        /* Frame mockup responsive */
        @media (max-width: 768px) {
            .frame-mockup-content { padding: 20px; }
            .frame-wrapper { padding: 5px; max-width: 85vw; max-height: 70vh; }
            .frame-inner { padding: 2px; }
            .frame-inner img { max-height: calc(70vh - 24px); }
            .frame-mockup-close { top: 12px; right: 12px; width: 36px; height: 36px; font-size: 18px; }
            .frame-mockup-download { top: 12px; right: 56px; width: 36px; height: 36px; font-size: 16px; }
            .frame-mockup-order { top: 12px; right: 100px; height: 36px; font-size: 9px; padding: 0 14px; border-radius: 18px; }
            .frame-mockup-mode { top: 12px; left: 12px; width: 36px; height: 36px; font-size: 14px; }
            .frame-mockup-nav { width: 36px; height: 36px; font-size: 16px; }
            .frame-mockup-nav.prev { left: 12px; }
            .frame-mockup-nav.next { right: 12px; }
            .frame-mockup-colors { bottom: 12px; padding: 5px 10px; gap: 8px; }
            .frame-color-btn { width: 20px; height: 20px; }
            .frame-mockup-label { font-size: 10px; }
            .frame-mockup .view-back-btn { top: 56px; left: 12px; font-size: 9px; padding: 5px 12px; }
        }
        @media (max-width: 480px) {
            .frame-mockup-order { display: none; }
            .frame-mockup-download { right: 56px; }
        }

        /* Timeline Framed View - starts in dark mode */
        .timeline-frame { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #0a0a0a; z-index: 2700; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .timeline-frame.open { display: flex; }
        .timeline-frame-content { display: flex; align-items: center; justify-content: center; flex-direction: column; padding: 60px; width: 100%; height: 100%; position: relative; }
        .timeline-frame-wrapper { position: relative; background: #1a1a1a; padding: 12px; max-width: 70vw; max-height: 65vh; box-shadow: 8px 12px 30px rgba(0,0,0,0.5), 15px 20px 50px rgba(0,0,0,0.4); }
        .timeline-frame-inner { position: relative; background: #0a0a0a; padding: 3px; }
        .timeline-frame-inner img { display: block; max-width: 100%; max-height: 60vh; width: auto; height: auto; }
        .timeline-frame-info { text-align: center; margin-top: 32px; }
        .timeline-frame-title { font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text); margin-bottom: 6px; }
        .timeline-frame-year { font-size: 10px; color: var(--text-muted); letter-spacing: 0.1em; }
        .timeline-frame-close { position: absolute; top: 24px; right: 24px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.1); color: #888; font-size: 20px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .timeline-frame-close:hover { background: #fff; color: #000; }
        .timeline-frame-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.1); color: #888; font-size: 18px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .timeline-frame-nav:hover { background: #fff; color: #000; }
        .timeline-frame-nav.prev { left: 24px; }
        .timeline-frame-nav.next { right: 24px; }
        .timeline-frame-nav:disabled { opacity: 0.2; cursor: default; }
        .timeline-frame-nav:disabled:hover { background: rgba(255,255,255,0.1); color: #888; }
        .timeline-frame-view-btn { position: absolute; bottom: 32px; left: 50%; transform: translateX(-50%); padding: 12px 28px; background: transparent; border: 1px solid var(--warm); color: var(--warm); font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; border-radius: 30px; cursor: pointer; transition: all 0.2s ease; }
        .timeline-frame-view-btn:hover { background: var(--warm); color: #000; }
        /* Light mode */
        .timeline-frame.light-mode { background: #f5f3f0; }
        .timeline-frame.light-mode::before { content: ''; position: absolute; inset: 0; background: radial-gradient(ellipse 80% 60% at 25% 25%, rgba(255,255,255,0.6) 0%, transparent 50%); pointer-events: none; }
        .timeline-frame.light-mode .timeline-frame-wrapper { background: #faf9f7; box-shadow: 8px 12px 30px rgba(0,0,0,0.18), 15px 20px 50px rgba(0,0,0,0.12); }
        .timeline-frame.light-mode .timeline-frame-inner { background: #4a4846; }
        .timeline-frame.light-mode .timeline-frame-title { color: #333; }
        .timeline-frame.light-mode .timeline-frame-year { color: #666; }
        .timeline-frame.light-mode .timeline-frame-close, .timeline-frame.light-mode .timeline-frame-nav { background: rgba(0,0,0,0.1); color: #555; }
        .timeline-frame.light-mode .timeline-frame-close:hover, .timeline-frame.light-mode .timeline-frame-nav:hover { background: #333; color: #fff; }
        .timeline-frame-mode { position: absolute; top: 24px; left: 24px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.1); color: #c9a227; font-size: 16px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .timeline-frame-mode:hover { background: #fff; color: #000; }
        .timeline-frame.light-mode .timeline-frame-mode { background: rgba(0,0,0,0.1); color: #555; }

        /* Origins Frame View - dark gallery wall with dark frame */
        .origins-frame { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #0a0910; z-index: 2800; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .origins-frame.open { display: flex; }
        .origins-frame-content { display: flex; align-items: center; justify-content: center; flex-direction: column; padding: 60px; width: 100%; height: 100%; position: relative; }
        .origins-frame-wrapper { position: relative; background: #1a1a1a; padding: 16px; max-width: 70vw; max-height: 65vh; box-shadow: 8px 12px 40px rgba(0,0,0,0.6), 20px 30px 60px rgba(0,0,0,0.4); cursor: pointer; transition: transform 0.2s ease; }
        .origins-frame-wrapper:hover { transform: scale(1.01); }
        .origins-frame-inner { position: relative; background: #0a0a0a; padding: 4px; }
        .origins-frame-inner img { display: block; max-width: 100%; max-height: 58vh; width: auto; height: auto; }
        .origins-frame-info { text-align: center; margin-top: 32px; }
        .origins-frame-title { font-size: 18px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text); margin-bottom: 6px; }
        .origins-frame-year { font-size: 10px; color: var(--text-muted); letter-spacing: 0.1em; margin-bottom: 4px; }
        .origins-frame-collection { font-size: 9px; color: var(--warm); letter-spacing: 0.08em; text-transform: uppercase; opacity: 0.7; }
        .origins-frame-close { position: absolute; top: 24px; right: 24px; width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.08); color: #666; font-size: 20px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .origins-frame-close:hover { background: #fff; color: #000; }
        .origins-frame-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; border: none; background: rgba(255,255,255,0.08); color: #666; font-size: 18px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .origins-frame-nav:hover { background: #fff; color: #000; }
        .origins-frame-nav.prev { left: 24px; }
        .origins-frame-nav.next { right: 24px; }
        .origins-frame-nav:disabled { opacity: 0.2; cursor: default; }
        .origins-frame-hint { position: absolute; bottom: 28px; left: 50%; transform: translateX(-50%); font-size: 9px; color: var(--text-muted); letter-spacing: 0.05em; opacity: 0.5; }
        @media (max-width: 768px) {
            .origins-frame-wrapper { max-width: 90vw; max-height: 55vh; padding: 10px; }
            .origins-frame-inner img { max-height: 48vh; }
            .origins-frame-info { margin-top: 20px; }
            .origins-frame-title { font-size: 14px; }
            .origins-frame-nav { width: 36px; height: 36px; font-size: 16px; }
            .origins-frame-nav.prev { left: 12px; }
            .origins-frame-nav.next { right: 12px; }
            .origins-frame-close { width: 36px; height: 36px; font-size: 16px; top: 16px; right: 16px; }
        }

        hr { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 6px 0; }

        .main-content { position: fixed; top: 0; left: 300px; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; z-index: 5; pointer-events: none; box-sizing: border-box; }
        .main-content > * { pointer-events: auto; }
        .frame-container { position: relative; overflow: hidden; cursor: pointer; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), border-radius 0.3s ease-out; display: flex; align-items: center; justify-content: center; }
        .frame-container:hover { transform: scale(1.02); border-radius: 24px; }
        .preview-image { max-height: calc(100vh - 280px); max-width: 100%; width: auto; height: auto; display: block; transition: opacity 0.3s ease-out; object-fit: contain; }
        .bottom-info { margin-top: 12px; display: flex; flex-direction: column; align-items: center; gap: 6px; width: 100%; }
        .preview-image.fade-out { opacity: 0; }

        /* Explore fullscreen button - hidden, exit via ESC/space */
        .explore-fullscreen-btn { display: none !important; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* Fullscreen mode */
        body.fullscreen-mode .sidebar, body.fullscreen-mode .gallery-toggle, body.fullscreen-mode .collectors-toggle, body.fullscreen-mode .mint-toggle,
        body.fullscreen-mode .mobile-menu-toggle, body.fullscreen-mode .bottom-info, body.fullscreen-mode .top-nav-fixed, body.fullscreen-mode .mobile-bottom-bar,
        body.fullscreen-mode .pull-refresh-indicator { display: none !important; }
        body.fullscreen-mode .main-content { padding: 0; left: 0; }
        body.fullscreen-mode .frame-container { width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; border-radius: 0; background: var(--bg-deep); }
        body.fullscreen-mode .preview-image { max-height: 100vh; max-width: 100vw; width: auto; height: auto; object-fit: contain; opacity: 0; transition: opacity 0.3s ease-out; }
        body.fullscreen-mode .preview-image.loaded { opacity: 1; }
        body.fullscreen-mode .click-to-view { display: none; }
        .fullscreen-exit-hint { display: none !important; }

        /* City note section - minimal, floats on background */
        .city-note { margin: 12px 0; display: none; }
        .city-note.visible { display: block; }
        .city-note textarea { width: 100%; padding: 4px 0; background: transparent; border: none; border-bottom: 1px solid var(--border); color: var(--text-muted); font-size: 9px; font-family: inherit; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; resize: none; transition: all 0.3s ease; line-height: 1.4; overflow: hidden; }
        .city-note textarea:focus { outline: none; border-bottom-color: var(--text-muted); color: var(--text); }
        .city-note textarea::placeholder { color: var(--text-muted); font-style: italic; text-transform: none; letter-spacing: 0; opacity: 0.5; }
        .city-note.has-note textarea { color: var(--text-dim); border-bottom-color: var(--text-muted); }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-card); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; transition: opacity 0.3s; }
        .loading-overlay.hidden { opacity: 0; pointer-events: none; }
        .spinner { width: 32px; height: 32px; border: 3px solid var(--bg-input); border-top-color: var(--teal); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { color: var(--text-muted); font-size: 12px; font-weight: 400; letter-spacing: 0.02em; font-family: Helvetica, Arial, sans-serif; text-transform: none; }
        .click-to-view { position: absolute; bottom: 0; left: 0; right: 0; padding: 40px 12px 12px; background: linear-gradient(transparent 0%, rgba(10, 9, 16, 0.5) 70%); text-align: center; color: var(--teal); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; opacity: 0; transition: opacity 0.35s ease; pointer-events: none; border-radius: 0 0 8px 8px; }
        .click-to-view.visible { opacity: 1; pointer-events: auto; cursor: pointer; }

        .info-display { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-muted); text-align: center; padding: 8px 16px; background: var(--bg-panel); border-radius: 12px; }
        .info-display .token-id { color: var(--teal); }
        .info-display .token-line { margin-bottom: 4px; }
        .owner-display { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-top: 4px; margin-bottom: 2px; }
        .owner-display a { color: var(--warm); text-decoration: none; font-weight: 700; cursor: pointer; transition: all 0.2s ease; }
        .owner-display a:hover { color: var(--yellow); }
        .owner-display .collector-link-inline { border-bottom: 1px dashed rgba(255,179,71,0.4); padding-bottom: 1px; }
        .owner-display .collector-link-inline:hover { border-bottom-color: var(--yellow); }

        /* Similar outputs */
        .similar-outputs { padding: 0; width: 100%; display: flex; flex-direction: column; align-items: center; opacity: 0.5; transition: opacity 0.3s ease; }
        .similar-outputs:hover { opacity: 0.85; }
        .similar-outputs-label { font-size: 7px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-muted); margin-bottom: 8px; opacity: 0.5; }
        .similar-outputs-grid { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; max-width: 320px; }
        .similar-output { width: 48px; height: 85px; border-radius: 6px; overflow: hidden; cursor: pointer; transition: all 0.3s ease; position: relative; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .similar-output:hover { transform: scale(1.1) translateY(-4px); box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
        .similar-output img { width: 100%; height: 100%; object-fit: cover; }
        .similar-output-id { position: absolute; bottom: 0; left: 0; right: 0; padding: 6px; background: rgba(10, 9, 16, 0.85); font-size: 10px; font-weight: 700; text-align: center; color: var(--text); opacity: 0; transition: opacity 0.2s ease; }
        .similar-output:hover .similar-output-id { opacity: 1; }

        /* Same Palette Owners - inline in same palette section */
        .same-palette-owners { margin-top: 8px; font-size: 9px; color: var(--text-muted); line-height: 1.5; }
        .same-palette-owners-label { font-weight: 600; color: var(--text-dim); margin-right: 4px; }
        .same-palette-owner { cursor: pointer; transition: color 0.2s ease; }
        .same-palette-owner:hover { color: var(--warm); }

        /* Same Palette Cities section (Neighbors) - collapsible */
        .same-palette-section { margin: 6px 0; }
        .same-palette-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: #666; margin-bottom: 8px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s ease; }
        .same-palette-label:hover { color: #888; }
        .same-palette-label .expand-icon { font-size: 6px; transition: transform 0.2s ease; filter: grayscale(100%); }
        .same-palette-section.collapsed .same-palette-grid { display: none; }
        .same-palette-section:not(.collapsed) .same-palette-label .expand-icon { transform: rotate(90deg); }
        .same-palette-grid { display: flex; gap: 6px; flex-wrap: wrap; }
        .same-palette-item { width: 36px; height: 64px; border-radius: 4px; overflow: hidden; cursor: pointer; transition: all 0.2s ease; position: relative; }
        .same-palette-item:hover { transform: scale(1.08); }
        .same-palette-item img { width: 100%; height: 100%; object-fit: cover; opacity: 0.85; transition: opacity 0.2s ease; }
        .same-palette-item:hover img { opacity: 1; }
        @media (max-width: 768px) { .same-palette-item img { opacity: 1; } }

        /* Pairs Well With section - collapsible */
        .pairs-well-section { margin: 6px 0; padding-top: 6px; border-top: 1px solid var(--border); }
        .pairs-well-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: #666; margin-bottom: 8px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s ease; }
        .pairs-well-label:hover { color: #888; }
        .pairs-well-label .expand-icon { font-size: 6px; transition: transform 0.2s ease; }
        .pairs-well-section.collapsed .pairs-well-grid { display: none; }
        .pairs-well-section:not(.collapsed) .pairs-well-label .expand-icon { transform: rotate(90deg); }
        .pairs-well-grid { display: flex; gap: 6px; flex-wrap: nowrap; justify-content: flex-start; width: 100%; }
        .pairs-well-item { display: flex; flex-direction: column; gap: 3px; padding: 4px; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; background: transparent; flex: 1 1 0; min-width: 0; }
        .pairs-well-item:hover { background: var(--bg-input); }
        .pairs-well-thumb { width: 100%; height: auto; aspect-ratio: 9/16; border-radius: 4px; overflow: hidden; background: var(--bg-input); }
        .pairs-well-thumb img { width: 100%; height: 100%; object-fit: cover; opacity: 0.85; transition: opacity 0.2s ease; }
        .pairs-well-item:hover .pairs-well-thumb img { opacity: 1; }
        @media (max-width: 768px) { .pairs-well-thumb img { opacity: 1; } }
        .pairs-well-info { display: flex; flex-direction: column; align-items: center; gap: 1px; width: 100%; }
        .pairs-well-id { font-size: 8px; font-weight: 600; color: var(--text-muted); }
        .pairs-well-type { font-size: 5px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.02em; color: #555; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: center; }

        /* Stats summary */
        .stats-summary { text-align: center; padding: 10px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .stats-summary strong { color: var(--teal); }
        .grid-stats-bar { display: none; justify-content: center; gap: 16px; padding: 8px 28px; background: var(--bg-card); font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .grid-stats-bar.visible { display: flex; }
        .grid-stats-bar strong { color: var(--teal); }

        .top-nav-fixed { position: fixed; top: 24px; right: 24px; z-index: 700; display: flex; gap: 0; align-items: center; }
        .top-nav-fixed button:focus-visible, .top-nav-fixed button:focus { outline: none; box-shadow: none; }
        .view-toggle-btn { width: 40px; height: 40px; min-width: 40px; border: none; border-radius: 0; background: transparent; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-left: -4px; padding: 0; overflow: hidden; }
        .view-toggle-btn:first-child { margin-left: 0; }
        .view-toggle-btn:hover { transform: scale(1.1); }
        .view-toggle-btn .glyph-img { width: 100%; height: 100%; object-fit: contain; filter: grayscale(100%) brightness(0.7); transition: filter 0.3s ease; display: none; }
        .view-toggle-btn:hover .glyph-img { filter: grayscale(100%) brightness(1); }
        /* Single view: show blob static */
        .view-toggle-btn .glyph-blob.glyph-static { display: block; }
        /* Grid view: show textile static */
        .view-toggle-btn.grid-open .glyph-blob { display: none !important; }
        .view-toggle-btn.grid-open .glyph-textile.glyph-static { display: block; }
        /* Desktop hover: swap static for animated */
        @media (min-width: 769px) {
            .view-toggle-btn:hover .glyph-static { display: none !important; }
            .view-toggle-btn:hover .glyph-blob.glyph-animated { display: block; }
            .view-toggle-btn.grid-open:hover .glyph-blob.glyph-animated { display: none !important; }
            .view-toggle-btn.grid-open:hover .glyph-textile.glyph-animated { display: block; }
        }
        /* COLLECT image button â€” uses COLLECT.PNG split into 5 segments via CSS sprites */
        /* Segments: C | OLL | E | C | T â€” based on natural gaps in the hand-drawn lettering */
        .mint-toggle {
            --ch: 24px;
            --cw: calc(var(--ch) * 3.985);
            display: flex; align-items: center; height: var(--ch); padding: 2px 3px; flex-shrink: 0; gap: 0;
            opacity: 0.6; transition: opacity 0.3s ease; margin-right: 16px;
            background: none; border: none; cursor: pointer; overflow: visible;
        }
        .mint-toggle:hover { opacity: 1; }
        .collect-seg {
            display: block; height: 100%;
            background: url(COLLECT.PNG) no-repeat;
            background-size: var(--cw) var(--ch);
            transition: transform 0.15s ease;
        }
        .cs-1 { width: calc(var(--cw) * 0.166); background-position: 0 0; }
        .cs-2 { width: calc(var(--cw) * 0.291); background-position: calc(var(--cw) * -0.166) 0; }
        .cs-3 { width: calc(var(--cw) * 0.119); background-position: calc(var(--cw) * -0.457) 0; }
        .cs-4 { width: calc(var(--cw) * 0.118); background-position: calc(var(--cw) * -0.576) 0; }
        .cs-5 { width: calc(var(--cw) * 0.305); background-position: calc(var(--cw) * -0.695) 0; }
        /* Hover: staggered vibrate across segments */
        .mint-toggle:hover .collect-seg { animation: segVibrate 0.35s ease-in-out infinite; }
        .mint-toggle:hover .cs-1 { animation-delay: 0s; }
        .mint-toggle:hover .cs-2 { animation-delay: 0.06s; }
        .mint-toggle:hover .cs-3 { animation-delay: 0.12s; }
        .mint-toggle:hover .cs-4 { animation-delay: 0.18s; }
        .mint-toggle:hover .cs-5 { animation-delay: 0.24s; }
        /* Periodic wave animation triggered by JS */
        .collect-seg.wave { animation: segWave 0.6s ease-out !important; }
        /* Subtle C-only in single view â€” reveal full COLLECT on hover */
        body:not(.grid-open) .mint-toggle { opacity: 0.3; }
        body:not(.grid-open) .mint-toggle:hover { opacity: 0.8; }
        body:not(.grid-open) .mint-toggle .collect-seg:not(.cs-1) { width: 0; opacity: 0; transition: width 0.25s ease, opacity 0.25s ease; }
        body:not(.grid-open) .mint-toggle:hover .cs-2 { width: calc(var(--cw) * 0.291); opacity: 1; }
        body:not(.grid-open) .mint-toggle:hover .cs-3 { width: calc(var(--cw) * 0.119); opacity: 1; }
        body:not(.grid-open) .mint-toggle:hover .cs-4 { width: calc(var(--cw) * 0.118); opacity: 1; }
        body:not(.grid-open) .mint-toggle:hover .cs-5 { width: calc(var(--cw) * 0.305); opacity: 1; }
        /* Collapse COLLECT to C when collectors panel is open â€” less clutter */
        body.collectors-open .mint-toggle { opacity: 0.3; }
        body.collectors-open .mint-toggle:hover { opacity: 0.8; }
        body.collectors-open .mint-toggle .collect-seg:not(.cs-1) { width: 0; opacity: 0; transition: width 0.25s ease, opacity 0.25s ease; }
        body.collectors-open .mint-toggle:hover .cs-2 { width: calc(var(--cw) * 0.291); opacity: 1; }
        body.collectors-open .mint-toggle:hover .cs-3 { width: calc(var(--cw) * 0.119); opacity: 1; }
        body.collectors-open .mint-toggle:hover .cs-4 { width: calc(var(--cw) * 0.118); opacity: 1; }
        body.collectors-open .mint-toggle:hover .cs-5 { width: calc(var(--cw) * 0.305); opacity: 1; }
        @keyframes segWave { 0% { transform: translateY(0) rotate(0deg); } 30% { transform: translateY(-5px) rotate(-4deg); } 50% { transform: translateY(-2px) rotate(2deg); } 70% { transform: translateY(-3px) rotate(-1deg); } 100% { transform: translateY(0) rotate(0deg); } }
        @keyframes segVibrate { 0%, 100% { transform: translate(0, 0) rotate(0deg); } 20% { transform: translate(0.6px, -0.8px) rotate(0.7deg); } 40% { transform: translate(-0.4px, 0.6px) rotate(-0.6deg); } 60% { transform: translate(0.5px, -0.3px) rotate(0.4deg); } 80% { transform: translate(-0.3px, 0.5px) rotate(-0.3deg); } }

        .gallery-panel { position: fixed; top: 0; right: 0; width: 380px; height: 100vh; background: var(--bg-panel); padding: 28px 24px; overflow-y: auto; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 99; will-change: transform; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; content-visibility: auto; }
        .gallery-panel.open { transform: translateX(0); }
        .gallery-panel.dragging { transition: none; }
        .gallery-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 28px; padding-top: 20px; }
        .gallery-header h2 { font-size: 14px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.12em; color: var(--pink); }
        .gallery-title-close { cursor: pointer; transition: opacity 0.2s ease; }
        .gallery-title-close:hover { opacity: 0.7; }
        .gallery-close-arrow { margin-left: 6px; font-size: 16px; }
        .gallery-close { background: var(--bg-input); border: none; color: var(--text-dim); width: 32px; height: 32px; border-radius: 50%; font-size: 16px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; margin-top: 24px; }
        .gallery-close:hover { background: var(--bg-card); color: var(--text); }
        .gallery-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .gallery-item { position: relative; cursor: pointer; border-radius: 16px; overflow: hidden; background: var(--bg-card); aspect-ratio: 9/16; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }
        .gallery-item:hover { transform: scale(1.03); }
        .gallery-item .item-info { width: 100%; height: 100%; position: relative; background: var(--bg-card); }
        .gallery-item .item-info img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .gallery-item-id { position: absolute; bottom: 0; left: 0; right: 0; padding: 6px; background: linear-gradient(transparent, rgba(10, 9, 16, 0.9)); font-size: 10px; font-weight: 700; text-align: center; color: var(--text); }
        .gallery-item .item-actions { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; opacity: 0; transition: opacity 0.2s; }
        .gallery-item:hover .item-actions { opacity: 1; }
        .item-actions button { padding: 12px 20px; border: none; border-radius: 50px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; width: 80%; transition: all 0.3s ease; }
        .item-actions .load-btn { background: var(--teal); color: #000; }
        .item-actions .delete-btn { background: transparent; color: var(--pink); }
        .empty-gallery { grid-column: 1 / -1; text-align: center; color: var(--text-muted); padding: 60px 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; line-height: 2; }

        /* Favorited palettes section - collapsible vertical list */
        .fav-palettes-section { margin-bottom: 16px; background: var(--bg-card); border-radius: 12px; overflow: hidden; }
        .fav-palettes-header { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); padding: 12px 14px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: background 0.2s ease; }
        .fav-palettes-header:hover { background: var(--bg-input); }
        .fav-palettes-header .collapse-arrow { font-size: 10px; transition: transform 0.2s ease; }
        .fav-palettes-section.collapsed .collapse-arrow { transform: rotate(-90deg); }
        .fav-palettes-grid { display: flex; flex-direction: column; gap: 2px; padding: 0 8px 8px; max-height: 200px; overflow-y: auto; transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.2s ease; }
        .fav-palettes-section.collapsed .fav-palettes-grid { max-height: 0; padding: 0 8px; opacity: 0; overflow: hidden; }
        .fav-palettes-grid::-webkit-scrollbar { width: 3px; }
        .fav-palettes-grid::-webkit-scrollbar-track { background: transparent; }
        .fav-palettes-grid::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .fav-palette-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--bg-input); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .fav-palette-item:hover { background: var(--bg-deep); }
        .fav-palette-swatch { width: 20px; height: 20px; border-radius: 4px; flex-shrink: 0; }
        .fav-palette-name { font-size: 10px; font-weight: 600; color: var(--text); text-transform: uppercase; letter-spacing: 0.03em; flex: 1; }
        .fav-palette-count { display: none; }
        .fav-palette-remove { width: 20px; height: 20px; border: none; background: transparent; color: var(--text-muted); font-size: 12px; cursor: pointer; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
        .fav-palette-remove:hover { background: var(--bg-card); color: var(--orange); }
        .fav-divider { height: 1px; background: var(--border); margin: 16px 0; }

        .keyboard-hints { margin-top: auto; padding-top: 24px; }
        .keyboard-hints h3 { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-muted); margin-bottom: 14px; }
        .hint-row { display: flex; justify-content: space-between; align-items: center; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-dim); margin-bottom: 10px; }
        .hint-row kbd { background: var(--bg-input); padding: 5px 10px; border-radius: 8px; font-family: inherit; font-size: 9px; font-weight: 700; }

        .token-nav { display: flex; gap: 8px; align-items: center; }
        .token-nav button { padding: 10px 14px; background: var(--bg-input); border: none; color: var(--text-dim); border-radius: 50px; cursor: pointer; font-size: 14px; font-weight: 700; transition: all 0.3s ease; }
        .token-nav button:hover { background: var(--bg-card); color: var(--teal); }
        .token-input-wrapper { flex: 1; position: relative; display: flex; align-items: center; }
        .token-hash { position: absolute; left: 14px; color: var(--text-muted); font-size: 13px; font-weight: 600; pointer-events: none; z-index: 1; }
        .token-nav input { flex: 1; text-align: center; padding-left: 28px !important; }
        .back-to-previous { width: auto; margin-top: 8px; padding: 5px 10px; background: transparent; border: 1px dashed var(--border); color: var(--text-muted); border-radius: 50px; cursor: pointer; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.2s ease; }
        .back-to-previous:hover { background: var(--bg-input); border-color: var(--text-muted); color: var(--text); }

        .status-message { position: fixed; bottom: 32px; left: 50%; transform: translateX(-50%) translateY(20px); background: var(--bg-card); padding: 16px 28px; border-radius: 20px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; opacity: 0; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1000; }
        .status-message.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        .status-message.success { background: var(--teal); color: #000; }
        .status-message.error { background: var(--pink); color: #fff; }

        .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .filter-grid .control-group { margin-bottom: 0; }
        .filter-grid .control-group label { font-size: 8px; margin-bottom: 4px; }
        .filter-grid select { font-size: 8px !important; padding: 6px 10px; background-position: right 10px center; padding-right: 26px; }
        .filter-actions { display: flex; gap: 8px; margin-top: 12px; }
        .filter-actions .btn { margin-bottom: 0; padding: 10px 12px; }
        .filter-clear-link { text-align: center; margin-top: 16px; }
        .filter-clear-link span { font-size: 10px; color: var(--text-muted); cursor: pointer; text-decoration: underline; text-underline-offset: 2px; transition: color 0.2s ease; }
        .filter-clear-link span:hover { color: var(--orange); }
        /* Set Filter Button */
        .set-filter-row { display: flex; justify-content: center; margin: 16px 0 8px; }
        .set-filter-btn { background: rgba(255, 220, 120, 0.15); color: rgba(255, 220, 120, 0.7); border: 1px solid rgba(255, 220, 120, 0.3); padding: 8px 16px; border-radius: 6px; font-size: 9px; font-weight: 600; letter-spacing: 0.1em; cursor: pointer; transition: all 0.2s ease; }
        .set-filter-btn:hover { background: rgba(255, 220, 120, 0.25); color: rgba(255, 220, 120, 0.9); }
        .set-filter-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .set-filter-btn.no-match { background: rgba(255, 100, 100, 0.15); color: rgba(255, 100, 100, 0.7); border-color: rgba(255, 100, 100, 0.3); }
        /* Time of Day Color Picker */
        .time-color-picker { margin: 16px 0 12px; }
        .time-color-label { display: block; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 8px; }
        .time-color-gradient { height: 24px; border-radius: 12px; background: linear-gradient(to right, #1a1a3a 0%, #2a2a4a 10%, #ff9966 20%, #ffdd88 30%, #87ceeb 45%, #ffcc77 60%, #ff7755 75%, #6a4a7a 90%, #1a1a3a 100%); cursor: pointer; position: relative; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
        .time-color-marker { position: absolute; width: 8px; height: 32px; background: #fff; border-radius: 4px; top: -4px; transform: translateX(-50%); box-shadow: 0 2px 8px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        .time-color-gradient:hover .time-color-marker, .time-color-gradient.active .time-color-marker { opacity: 1; }
        .time-color-gradient.active { box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 0 2px var(--teal); }
        .time-color-labels { display: flex; justify-content: space-between; margin-top: 6px; font-size: 7px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        .time-color-labels span { opacity: 0.6; }
        .btn-clear { background: var(--bg-input); color: var(--text-dim); }
        .btn-clear:hover { background: var(--bg-card); color: var(--orange); }
        .btn-random-filter { background: var(--yellow); color: #000; }
        .btn-random-filter:hover { background: var(--orange); }
        .match-count { text-align: center; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin: 6px 0 4px; padding: 0; }
        .match-count:empty { display: none; margin: 0; }
        .match-count strong { color: var(--teal); font-weight: 700; }

        .traits-display { padding: 12px; background: var(--bg-input); border-radius: 14px; font-size: 10px; overflow: hidden; }
        .traits-display .trait-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em; gap: 6px; padding: 4px 6px; border-radius: 6px; transition: background 0.15s ease; }
        .traits-display .trait-row.clickable { cursor: pointer; }
        .traits-display .trait-row.clickable:hover { background: var(--bg-card); }
        .traits-display .trait-row:last-child { margin-bottom: 0; }
        .traits-display .trait-row.palette-row { background: var(--bg-card); padding: 10px 12px; border-radius: 10px; margin-bottom: 10px; flex-wrap: nowrap; }
        .traits-display .trait-row.palette-row.clickable:hover { background: var(--bg-input); outline: 1px solid var(--border); }
        .traits-display .trait-name { color: var(--text-muted); font-weight: 600; flex-shrink: 0; font-size: 9px; }
        .traits-display .trait-value { color: var(--text); font-weight: 700; text-align: right; white-space: nowrap; font-size: 10px; overflow: hidden; text-overflow: ellipsis; max-width: 120px; }
        .traits-display .palette-row { display: flex; align-items: center; gap: 8px; }
        .traits-display .palette-row .trait-name { flex-shrink: 0; }
        .traits-display .palette-row .trait-value { font-size: 10px; letter-spacing: 0.04em; margin-left: auto; }
        .traits-display .palette-row .palette-swatches { display: flex; }
        .traits-display .palette-row .palette-swatches span { display: inline-block; width: 10px; height: 10px; }
        .traits-display .palette-row .palette-swatches span:first-child { border-radius: 2px 0 0 2px; }
        .traits-display .palette-row .palette-swatches span:last-child { border-radius: 0 2px 2px 0; }
        .traits-display .digital-clock { font-family: 'Courier New', monospace; font-size: 11px; font-weight: 700; color: var(--text); background: var(--bg-input); padding: 3px 8px; border-radius: 4px; margin-left: 6px; letter-spacing: 0.05em; }
        .traits-display .energy-icon { font-size: 14px; margin-left: 6px; filter: grayscale(100%) brightness(1.2); flex-shrink: 0; }
        .traits-display .trait-rarity { font-size: 7px; color: var(--text-muted); background: var(--bg-card); padding: 2px 5px; border-radius: 3px; flex-shrink: 0; }
        .traits-display .trait-rarity.rare { color: var(--orange); background: rgba(255, 140, 66, 0.15); }

        .collection-link { display: block; text-align: center; padding: 14px 20px; background: var(--bg-input); border-radius: 50px; color: var(--text-dim); text-decoration: none; font-size: 10px; font-weight: 700; letter-spacing: 0.1em; transition: all 0.3s ease; }
        .collection-link:hover { background: var(--bg-card); color: var(--teal); }
        .marketplace-links { display: flex; gap: 6px; flex-wrap: wrap; }
        .marketplace-link { flex: 1; min-width: 70px; padding: 7px 12px; background: var(--bg-input); border-radius: 50px; color: var(--text-dim); text-decoration: none; font-size: 9px; font-weight: 700; letter-spacing: 0.05em; text-transform: uppercase; text-align: center; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .marketplace-link:hover { background: var(--bg-card); color: var(--teal); transform: translateY(-1px); }
        .marketplace-link.opensea:hover { color: #2081E2; }
        .marketplace-link.artblocks:hover { color: var(--teal); }
        .marketplace-link.raster:hover { color: var(--pink); }
        .marketplace-link.offer-btn { background: var(--warm); border: 2px solid var(--warm); color: #000; font-weight: 800; }
        .marketplace-link.offer-btn:hover { background: var(--orange); border-color: var(--orange); color: #000; box-shadow: 0 4px 16px rgba(232, 184, 109, 0.3); }
        .owner-actions { display: flex; gap: 8px; }
        .owner-actions .marketplace-link { flex: 1; }
        .listing-info { margin-top: 10px; padding: 12px 16px; background: var(--bg-card); border-radius: 12px; display: none; }
        .listing-info.visible { display: block; }
        .listing-info .listing-price { font-size: 16px; font-weight: 800; color: var(--teal); }
        .listing-info .listing-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); margin-bottom: 4px; }
        .listing-info .listing-source { font-size: 9px; color: var(--text-dim); margin-top: 4px; }
        .mint-link { background: linear-gradient(90deg, #F4A261, #E07B5A, #C77B8B, #9B6B9E, #E07B5A, #F4A261); background-size: 500% 100%; color: #1a1a2e; margin-bottom: 10px; }
        .mint-link:hover { box-shadow: 0 4px 16px rgba(224, 123, 90, 0.3); color: #1a1a2e; animation: colorShift 8s ease-in-out infinite; }
        @keyframes colorShiftFast { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        /* Mint countdown */
        .mint-countdown { display: flex; align-items: center; justify-content: space-between; padding: 5px 10px; background: var(--bg-input); border-radius: 50px; margin-bottom: 6px; font-size: 7px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; opacity: 0.5; transition: opacity 0.3s ease; }
        .mint-countdown:hover { opacity: 0.8; }
        .countdown-label { color: var(--text-muted); }
        .countdown-timer { color: var(--text-dim); font-variant-numeric: tabular-nums; }
        .mint-countdown.ended { display: none; }

        .supply-tracker { display: block; text-decoration: none; transition: all 0.4s ease; cursor: pointer; position: relative; margin-bottom: 6px; }
        .supply-bar { position: relative; height: 18px; background: var(--bg-input); border-radius: 9px; overflow: hidden; }
        .supply-fill { position: absolute; top: 0; left: 0; height: 100%; background: linear-gradient(90deg, rgba(180, 140, 80, 0.8), rgba(200, 160, 100, 0.8), rgba(180, 140, 80, 0.8)); background-size: 200% 100%; border-radius: 9px; transition: all 0.4s ease; }
        .supply-tracker:hover .supply-fill { background: linear-gradient(90deg, #D4A574, #E8B86D, #D4A574); background-size: 200% 100%; }
        @keyframes supplyShimmer { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
        .supply-label { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; padding: 0 10px; font-size: 7px; font-weight: 800; letter-spacing: 0.08em; color: rgba(163, 123, 55, 0.85); z-index: 2; transition: color 0.3s ease; }
        .supply-tracker:hover .supply-label { color: #000; }
        .supply-tracker .mint-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; opacity: 0; color: #000; font-size: 9px; font-weight: 700; letter-spacing: 0.08em; transition: opacity 0.3s ease; z-index: 3; border-radius: 9px; background: linear-gradient(90deg, var(--orange), var(--yellow), var(--pink), var(--orange)); background-size: 300% 100%; text-shadow: none; }
        .supply-tracker:hover .supply-bar { box-shadow: 0 2px 8px rgba(212, 165, 116, 0.25); }
        .supply-tracker:hover .mint-text { opacity: 1; }
        .supply-tracker.sold-out .supply-fill { background: linear-gradient(90deg, var(--orange), var(--warm)); }
        .supply-tracker.sold-out .supply-label { color: #fff; }

        .collectors-toggle { display: none; }
        .collectors-panel { position: fixed; top: 0; right: 0; width: 420px; height: 100vh; background: var(--bg-panel); padding: 28px 24px; overflow-y: auto; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 550; pointer-events: none; will-change: transform; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; content-visibility: auto; }
        .collectors-panel.open { transform: translateX(0); pointer-events: auto; }
        .collectors-panel.dragging { transition: none; }
        .collectors-panel::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 6px; height: 80px; background: var(--border); border-radius: 0 4px 4px 0; cursor: ew-resize; transition: background 0.2s, width 0.2s, opacity 0.2s; opacity: 0; pointer-events: none; }
        .collectors-panel.open::before { opacity: 1; pointer-events: auto; }
        .collectors-panel.open:hover::before, .collectors-panel.dragging::before { background: var(--teal); width: 8px; }
        .gallery-panel::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 6px; height: 80px; background: var(--border); border-radius: 0 4px 4px 0; cursor: ew-resize; transition: background 0.2s, width 0.2s, opacity 0.2s; opacity: 0; pointer-events: none; }
        .gallery-panel.open::before { opacity: 1; pointer-events: auto; }
        .gallery-panel.open:hover::before, .gallery-panel.dragging::before { background: var(--pink); width: 8px; }
        .collectors-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; margin-top: 40px; }
        .collectors-header h2 { font-size: 14px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.12em; color: #fff; display: flex; align-items: center; gap: 6px; }
        .collectors-header .collapse-arrow { font-size: 12px; letter-spacing: -3px; opacity: 0.35; transition: all 0.2s ease; color: var(--warm); }
        .collectors-header h2:hover .collapse-arrow { opacity: 1; letter-spacing: -1px; }
        .collectors-close { background: var(--bg-input); border: none; color: var(--text-dim); width: 32px; height: 32px; border-radius: 50%; font-size: 16px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .collectors-close:hover { background: var(--bg-card); color: var(--text); }
        .collectors-header-actions { display: flex; gap: 8px; align-items: center; position: relative; z-index: 2; }

        .collectors-stats { text-align: center; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 20px; padding: 12px 18px; background: var(--bg-input); border-radius: 50px; }
        .collectors-stats strong { color: var(--teal); }
        .top-collectors-highlight { display: none; margin-bottom: 16px; padding: 0 2px; }
        .top-collectors-highlight.visible { display: block; }
        .top-collectors-highlight-label { font-size: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-muted); margin-bottom: 10px; opacity: 0.6; }
        .top-collector-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-radius: 10px; margin-bottom: 4px; cursor: pointer; transition: all 0.15s ease; }
        .top-collector-row:nth-child(even) { background: rgba(255,255,255,0.03); }
        .top-collector-row:hover { background: rgba(255,255,255,0.06); }
        .top-collector-rank { font-size: 14px; width: 20px; text-align: center; flex-shrink: 0; }
        .top-collector-info { flex: 1; min-width: 0; }
        .top-collector-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; gap: 6px; }
        .top-collector-status { display: inline-flex; align-items: center; gap: 3px; flex-shrink: 0; position: relative; }
        .top-collector-status-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; opacity: 0.7; transition: opacity 0.2s ease; }
        .top-collector-status-dot.energy-rising { background: #FFB347; }
        .top-collector-status-dot.energy-living { background: #87ceeb; }
        .top-collector-status-dot.energy-fading { background: #DDA0DD; }
        .top-collector-status-dot.energy-resting { background: #B19CD9; }
        .top-collector-status-dot.energy-spectrum { background: linear-gradient(135deg, #FFB347, #77DD77, #AEC6CF, #B19CD9); }
        .top-collector-status-dot.energy-grid { background: var(--warm); }
        .top-collector-status-label { font-size: 7px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; opacity: 0; max-width: 0; overflow: hidden; white-space: nowrap; transition: all 0.25s ease; color: var(--text-muted); }
        .top-collector-row:hover .top-collector-status-label { opacity: 0.7; max-width: 120px; }
        .top-collector-row:hover .top-collector-status-dot { opacity: 1; }
        .top-collector-meta { font-size: 9px; color: var(--text-muted); margin-top: 2px; font-weight: 500; }
        .top-collector-count { font-size: 13px; font-weight: 800; color: var(--teal); flex-shrink: 0; }
        .top-collector-chips { display: flex; gap: 2px; flex-shrink: 0; }
        .top-collector-chip { width: 10px; height: 18px; border-radius: 2px; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1); }
        .collectors-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; }
        .collector-pill { padding: 8px 14px; border-radius: 20px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.03em; cursor: pointer; transition: transform 0.15s ease-out, box-shadow 0.15s ease; position: relative; overflow: hidden; white-space: nowrap; will-change: transform; }
        .collector-pill:hover { transform: scale(1.03); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .collector-pill .pill-count { opacity: 0.7; margin-left: 4px; font-size: 10px; }
        .collector-pill .pill-emoji { display: none; }
        .collector-pill .pill-grid-badge { margin-left: 4px; font-size: 8px; opacity: 0.8; }
        .collector-pill-tooltip { position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%); background: var(--bg-panel); border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; min-width: 140px; opacity: 0; visibility: hidden; transition: all 0.2s ease; z-index: 100; pointer-events: none; box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
        .collector-pill:hover .collector-pill-tooltip { opacity: 1; visibility: visible; }
        .collector-pill-tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); border: 6px solid transparent; border-top-color: var(--border); }
        .collector-pill-tooltip-stat { display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 4px; }
        .collector-pill-tooltip-stat:last-child { margin-bottom: 0; }
        .collector-pill-tooltip-label { color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        .collector-pill-tooltip-value { color: var(--text); font-weight: 600; }
        /* Waterfall pulse animation - only plays once on panel open for performance */
        @keyframes waterfallPulse {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        .collectors-panel.open .collector-pill { animation: waterfallPulse 0.4s ease-out forwards; }
        .collector-pill:nth-child(1) { animation-delay: 0s; }
        .collector-pill:nth-child(2) { animation-delay: 0.03s; }
        .collector-pill:nth-child(3) { animation-delay: 0.06s; }
        .collector-pill:nth-child(4) { animation-delay: 0.09s; }
        .collector-pill:nth-child(5) { animation-delay: 0.12s; }
        .collector-pill:nth-child(6) { animation-delay: 0.15s; }
        .collector-pill:nth-child(7) { animation-delay: 0.18s; }
        .collector-pill:nth-child(8) { animation-delay: 0.21s; }
        .collector-pill:nth-child(9) { animation-delay: 0.24s; }
        .collector-pill:nth-child(10) { animation-delay: 0.27s; }
        .collector-pill:nth-child(n+11) { animation-delay: calc((var(--pill-index, 0) % 10) * 0.03s); }
        /* The Lost Cities - Haunted/Ghostly pill */
        .collector-pill.haunted-pill { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%) !important; color: rgba(200, 200, 220, 0.7) !important; border: 1px solid rgba(100, 100, 150, 0.3); text-shadow: 0 0 8px rgba(150, 150, 200, 0.3); }
        .collector-pill.haunted-pill::before { background: linear-gradient(90deg, transparent, rgba(150, 150, 200, 0.1), transparent); }
        .collector-pill.haunted-pill:hover { box-shadow: 0 4px 20px rgba(100, 100, 180, 0.3), 0 0 30px rgba(100, 100, 150, 0.15); }
        @keyframes hauntedPulse { 0%, 100% { filter: brightness(0.9); opacity: 0.85; } 50% { filter: brightness(1.1); opacity: 1; } }
        .leaderboard-btn { width: auto; padding: 8px 14px; background: linear-gradient(90deg, var(--warm), var(--orange), var(--yellow), var(--warm)); background-size: 400% 100%; border: none; border-radius: 12px; color: #000; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.3s ease; opacity: 0.85; }
        .leaderboard-btn:hover { opacity: 1; }
        .leaderboard-btn:hover { box-shadow: 0 8px 24px rgba(185, 103, 255, 0.25); }
        @keyframes colorShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        .back-btn { background: var(--bg-input); color: var(--text-dim); }
        .back-btn:hover { background: var(--bg-card); color: var(--text); box-shadow: none; }
        .leaderboard-view { display: none; opacity: 0; }
        .leaderboard-view.active { display: block; opacity: 1; animation: fadeInFast 0.15s ease-out; }
        .pills-view { display: block; }
        .pills-view.hidden { display: none; }
        @keyframes fadeInFast { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
        /* Grid badge for leaderboard - shows energy collection as 9:16 cells */
        .leaderboard-grid-wrap { display: inline-flex; gap: 1px; margin-left: 6px; flex-shrink: 0; align-items: center; }
        .leaderboard-grid-col { display: flex; flex-direction: column; gap: 1px; }
        .leaderboard-grid-cell { width: 4px; height: 7px; border-radius: 1px; background: rgba(255,255,255,0.12); }
        .leaderboard-grid-cell.rising { background: #FFB347; }
        .leaderboard-grid-cell.living { background: #77DD77; }
        .leaderboard-grid-cell.fading { background: #AEC6CF; }
        .leaderboard-grid-cell.resting { background: #B19CD9; }
        .leaderboard-grid-wrap.has-complete .leaderboard-grid-cell:not([style*="opacity"]) { filter: brightness(1.15); }
        .leaderboard-grid-multiplier { font-size: 7px; font-weight: 800; color: var(--warm); margin-left: 2px; line-height: 1; }
        /* Achievement badges */
        .achievement-badges { display: inline-flex; gap: 3px; margin-left: 6px; align-items: center; }
        .achievement-badge { font-size: 10px; opacity: 0.7; cursor: default; line-height: 1; }
        .achievement-badge.og { font-size: 7px; font-weight: 600; color: var(--text-muted); opacity: 0.4; letter-spacing: 0.03em; }
        .achievement-badge.grid { display: inline-flex; align-items: center; gap: 1px; }
        .grid-icon-mini { display: inline-grid; grid-template-columns: repeat(2, 3px); grid-template-rows: repeat(2, 5px); gap: 1px; opacity: 0.6; }
        .grid-icon-mini b { display: block; background: currentColor; border-radius: 0.5px; }
        .grid-multiplier { font-size: 7px; opacity: 0.5; font-weight: 600; }
        .achievement-badge.spectrum { filter: saturate(0.7); opacity: 0.65; }
        .achievement-badge.rising-set, .achievement-badge.living-set, .achievement-badge.fading-set { font-size: 10px; opacity: 0.65; }
        .achievement-badge.resting-set { display: inline-flex; align-items: center; gap: 2px; opacity: 0.7; cursor: default; animation: restingSetAppear 0.35s ease-out; }
        .achievement-badge.resting-set:hover { transform: scale(1.35); opacity: 1; }
        .resting-set-grid { display: inline-grid; grid-template-columns: repeat(2, 3px); grid-template-rows: repeat(2, 5px); gap: 1px; }
        .resting-set-grid b { display: block; background: #1a2332; border-radius: 1px; border: 0.5px solid #e8c547; }
        .resting-set-multiplier { font-size: 7px; opacity: 0.6; font-weight: 600; }
        @keyframes restingSetAppear { from { transform: scale(0.6); opacity: 0; } to { transform: scale(1); opacity: 0.7; } }
        /* Leaderboard alternating rows */
        .leaderboard-item:nth-child(odd) { background: rgba(255,255,255,0.02); }
        .leaderboard-item:nth-child(even) { background: transparent; }
        .leaderboard-list { list-style: none; contain: content; }
        .leaderboard-btn.back-btn { margin-bottom: 24px; }
        /* Become a Collector */
        .become-collector-btn { display: block; width: 100%; padding: 12px 16px; margin-bottom: 16px; background: transparent; border: 1px dashed var(--border); color: var(--text-muted); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; border-radius: 12px; cursor: pointer; transition: all 0.2s ease; }
        .become-collector-btn:hover { border-color: var(--warm); color: var(--warm); background: rgba(255,179,71,0.05); }
        .not-collector-link { display: block; width: 100%; padding: 8px 0; margin-bottom: 12px; background: transparent; border: none; color: var(--text-muted); font-size: 10px; font-weight: 500; text-align: center; cursor: pointer; transition: all 0.2s ease; opacity: 0.6; }
        .not-collector-link:hover { opacity: 1; color: var(--warm); }
        .dream-grid-btn { background: none; border: none; cursor: pointer; font-size: 14px; line-height: 1; padding: 4px; opacity: 0.35; transition: all 0.25s ease; filter: grayscale(0.6); }
        .dream-grid-btn:hover { opacity: 0.9; filter: grayscale(0); transform: scale(1.15); }
        .dream-grid-btn[title]::after { content: ''; }
        /* Citizen Guide View - Clean onboarding */
        .collector-guide-view { display: none; }
        .collector-guide-view.active { display: block; }
        .collector-guide-header { display: flex; align-items: center; justify-content: center; margin-bottom: 40px; }
        .collector-guide-steps { display: flex; gap: 12px; align-items: center; }
        .collector-guide-step-num { width: 28px; height: 28px; border-radius: 50%; border: 1px solid var(--border); color: var(--text-dim); font-size: 12px; font-weight: 500; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; cursor: pointer; }
        .collector-guide-step-num.active { border-color: var(--text); color: var(--text); background: rgba(255,255,255,0.05); }
        .collector-guide-step-num.completed { border-color: var(--text-muted); color: var(--text-muted); }
        .collector-guide-step { display: none; animation: fadeSlideIn 0.3s ease; text-align: center; padding: 0 10px; }
        .collector-guide-step.active { display: block; }
        @keyframes fadeSlideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .collector-guide-title { font-size: 18px; font-weight: 500; color: var(--text); margin-bottom: 16px; line-height: 1.4; }
        .collector-guide-desc { font-size: 13px; color: var(--text-dim); line-height: 1.7; margin-bottom: 24px; max-width: 280px; margin-left: auto; margin-right: auto; }
        .collector-guide-highlight { font-size: 12px; color: var(--text-muted); font-style: italic; margin-bottom: 20px; }
        .collector-guide-pill-btn { display: inline-block; padding: 10px 24px; background: var(--warm); border: 1px solid var(--warm); color: #1a1a1a; font-size: 11px; font-weight: 600; letter-spacing: 0.03em; border-radius: 50px; cursor: pointer; transition: all 0.2s ease; text-align: center; text-decoration: none; margin: 4px; position: relative; overflow: visible; }
        .collector-guide-pill-btn:hover { background: var(--yellow); border-color: var(--yellow); }
        .collector-guide-pill-btn.secondary { background: transparent; border: 1px dotted var(--border); color: var(--text-muted); }
        .collector-guide-pill-btn.secondary:hover { border-color: var(--text-muted); border-style: solid; color: var(--text); }
        /* Water droplet split animation */
        .pill-droplet { position: absolute; width: 6px; height: 6px; background: var(--warm); border-radius: 50%; pointer-events: none; opacity: 0.8; }
        .pill-droplet.left { animation: dropletFloatLeft 1.2s ease-out forwards; }
        .pill-droplet.right { animation: dropletFloatRight 1.2s ease-out forwards; }
        @keyframes dropletFloatLeft {
            0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { top: -30px; left: 20%; transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
        }
        @keyframes dropletFloatRight {
            0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { top: -30px; left: 80%; transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
        }
        .collector-guide-nav { display: flex; justify-content: space-between; align-items: center; margin-top: 40px; }
        .collector-guide-arrow { background: transparent; border: none; color: var(--text-dim); font-size: 10px; cursor: pointer; padding: 4px 0; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px; letter-spacing: 0.02em; opacity: 0.5; }
        .collector-guide-arrow:hover { color: var(--text-muted); opacity: 1; }
        .collector-guide-arrow:disabled { opacity: 0.15; cursor: not-allowed; }
        .collector-guide-arrow:disabled:hover { color: var(--text-dim); opacity: 0.15; }
        .collector-guide-arrow .arrow-icon { font-size: 11px; }
        .leaderboard-item { margin-bottom: 12px; display: flex; gap: 10px; align-items: center; contain: layout style; will-change: transform; }
        .leaderboard-name-wrap { flex-shrink: 0; min-width: 140px; display: flex; align-items: center; gap: 4px; }
        .leaderboard-rank { font-size: 9px; font-weight: 600; color: var(--border); width: 18px; opacity: 0; transition: opacity 0.15s ease; flex-shrink: 0; }
        .leaderboard-item:hover .leaderboard-rank { opacity: 1; }
        .leaderboard-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; transition: transform 0.15s ease-out, color 0.15s ease; display: inline-block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; will-change: transform; }
        .leaderboard-item:hover .leaderboard-name { transform: rotate(-1.5deg) translateX(2px); color: var(--yellow) !important; }
        .leaderboard-chips-wrap { flex: 1; display: flex; justify-content: flex-end; overflow: hidden; }
        .leaderboard-chips { display: flex; gap: 2px; border-radius: 4px; overflow: hidden; transition: gap 0.12s ease; }
        .leaderboard-chip { width: 18px; aspect-ratio: 9/16; border-radius: 2px; overflow: hidden; transition: width 0.12s ease, border-radius 0.12s ease; will-change: width; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1); }
        .leaderboard-item:hover .leaderboard-chips { gap: 3px; }
        .leaderboard-item:hover .leaderboard-chip { width: 28px; border-radius: 3px; }
        .leaderboard-count { font-size: 11px; font-weight: 800; color: var(--teal); flex-shrink: 0; min-width: 24px; text-align: right; }

        .loading-bar-container { position: fixed; top: 0; left: 0; right: 0; height: 3px; background: var(--bg-panel); z-index: 1000; opacity: 0; transition: opacity 0.3s; }
        .loading-bar-container.visible { opacity: 1; }
        .loading-bar { height: 100%; background: linear-gradient(90deg, #D4A574, #E8B86D, #D4A574); background-size: 200% 100%; animation: shimmer 1.5s ease-in-out infinite; width: 0%; transition: width 0.3s ease-out; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }

        /* Grid View Panel */
        .grid-toggle { position: fixed; bottom: 24px; left: 324px; z-index: 100; width: auto; padding: 14px 24px; background: transparent; border: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.5); font-size: 11px; border-radius: 20px; transition: all 0.3s ease, opacity 0.3s ease, transform 0.3s ease; }
        .grid-toggle:hover { background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.8); border-color: rgba(255,255,255,0.3); transform: translateY(-2px); }
        body.grid-open .grid-toggle { opacity: 0; pointer-events: none; transform: translateY(20px); }
        .grid-panel { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-deep); z-index: 500; display: none; overflow: hidden; }
        .grid-panel.open { display: flex; flex-direction: column; }
        .grid-header { display: flex; justify-content: center; align-items: center; padding: 20px 28px; background: var(--bg-panel); border-bottom: 1px solid var(--border); flex-shrink: 0; gap: 20px; min-height: 70px; position: relative; }
        .grid-brand { position: absolute; left: 28px; display: flex; flex-direction: row; align-items: baseline; gap: 12px; }
        .grid-brand h1 { font-size: 28px; font-weight: 700; text-transform: none; letter-spacing: 0.02em; color: #fff; margin: 0; font-family: Helvetica, Arial, sans-serif; cursor: pointer; transition: color 0.8s ease, transform 0.8s ease, font-style 0.8s ease, opacity 0.2s ease; line-height: 1; }
        .grid-brand h1:hover { opacity: 0.7; }
        .grid-artist-logos { display: flex; align-items: baseline; gap: 8px; }
        .grid-artist-logo { height: 16px; width: auto; opacity: 0; filter: brightness(0) invert(1); transition: all 0.3s ease; position: relative; top: 1px; }
        .grid-logo-x { opacity: 0; transition: opacity 0.3s ease; }
        /* Show logos on hover over the brand area (desktop only) */
        @media (min-width: 769px) {
            .grid-brand:hover .grid-artist-logo,
            .grid-brand:hover .grid-logo-x { opacity: 0.5; }
            .grid-brand:hover .grid-artist-logo:hover { opacity: 0.9; }
        }
        @media (max-width: 768px) {
            .grid-artist-logo, .grid-logo-x { opacity: 0.5; }
        }
        .grid-artist-logo.diid-logo { height: 20px; top: 1px; }
        .grid-artist-logo:hover { opacity: 0.9; filter: brightness(0) invert(1) drop-shadow(0 0 8px rgba(212, 165, 116, 0.5)); }
        .grid-artist-logo.ef-logo:hover { animation: logoWiggle 0.4s ease-in-out; }
        .grid-logo-x { font-size: 10px; color: var(--text-muted); position: relative; top: -5px; }
        .grid-about-link { display: inline-block; opacity: 0.4; text-decoration: none; transition: all 0.3s ease; margin-left: 8px; }
        .grid-about-link:hover { opacity: 0.8; }
        .grid-about-link img { height: 18px; width: auto; filter: brightness(0) invert(1); transition: all 0.3s ease; }
        .grid-about-link:hover img { filter: brightness(0) invert(1) drop-shadow(0 0 4px rgba(255,255,255,0.3)); }
        .grid-controls { display: flex; gap: 10px; align-items: center; }
        .grid-mode-btn { padding: 14px 24px; background: transparent; border: 1.5px solid rgba(212, 165, 116, 0.35); border-radius: 50px; color: var(--mint); font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.3s ease; outline: none; box-shadow: none; }
        .grid-mode-btn:hover { background: rgba(212, 165, 116, 0.1); border-color: var(--warm); color: var(--warm); }
        .grid-mode-btn:focus-visible { border-color: var(--warm); }
        .grid-mode-btn.active { background: rgba(232, 184, 109, 0.15); border-color: var(--warm); color: var(--warm); }
        .grid-mode-btn .palette-sort-arrow { margin-left: 4px; transition: transform 0.2s ease; display: inline-block; }
        .grid-mode-btn.sort-asc .palette-sort-arrow { transform: rotate(180deg); }
        .grid-mode-btn .mode-gradient-dot { width: 14px; height: 14px; border-radius: 50%; background: conic-gradient(#ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b); display: inline-block; vertical-align: middle; margin-right: 4px; flex-shrink: 0; }
        .grid-mode-btn .mode-az-label { font-weight: 900; letter-spacing: 0.04em; }
        .filter-toggle-bar { display: flex; align-items: center; justify-content: center; padding: 10px 16px; background: var(--bg-panel); border-bottom: 1px solid var(--border); cursor: pointer; position: relative; }
        .filter-toggle-bar span { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        .filter-toggle-bar .arrow { margin-left: 6px; font-size: 8px; transition: transform 0.15s ease; }
        .filter-toggle-bar.open .arrow { transform: rotate(180deg); }
        .grid-filter-bar { display: none; gap: 12px; padding: 16px 28px; background: var(--bg-panel); flex-shrink: 0; align-items: center; flex-wrap: wrap; border-bottom: 1px solid var(--border); position: relative; }
        .grid-filter-bar.open { display: flex; }
        .grid-filter-bar select { padding: 10px 14px; background: var(--bg-input); border: none; color: var(--text); border-radius: 12px; font-size: 11px; font-family: inherit; font-weight: 600; cursor: pointer; min-width: 150px; color-scheme: dark; }
        .grid-filter-bar select:focus { outline: none; box-shadow: 0 0 0 2px rgba(232, 184, 109, 0.3); }
        .grid-filter-bar select option { background: #1e1d28; color: #fff; padding: 10px 14px; }
        .multi-select { position: relative; min-width: 120px; }
        .multi-select-btn { padding: 10px 16px; background: var(--bg-input); border: none; color: var(--text); border-radius: 50px; font-size: 11px; font-family: inherit; font-weight: 600; cursor: pointer; width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
        .multi-select-btn:hover { background: var(--bg-card); }
        .multi-select-btn .arrow { font-size: 8px; opacity: 0.6; }
        .multi-select-btn.has-selection { color: var(--warm); }
        .multi-select-dropdown { position: absolute; top: 100%; left: 0; min-width: 100%; background: var(--bg-card); border-radius: 12px; margin-top: 4px; padding: 8px 0; max-height: 280px; overflow-y: auto; z-index: 1000; display: none; box-shadow: 0 8px 32px rgba(0,0,0,0.4); white-space: nowrap; }
        #paletteMultiSelect .multi-select-dropdown { min-width: 200px; }
        #boundsMultiSelect .multi-select-dropdown { min-width: 180px; }
        .multi-select.open .multi-select-dropdown { display: block; }
        .multi-select-item { display: flex; align-items: center; gap: 10px; padding: 8px 14px; cursor: pointer; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; transition: background 0.2s; }
        .multi-select-item:hover { background: var(--bg-input); }
        .multi-select-item input { appearance: none; -webkit-appearance: none; width: 8px; height: 8px; border-radius: 50%; background: transparent; border: 1.5px solid var(--text-dim); cursor: pointer; flex-shrink: 0; transition: all 0.2s ease; opacity: 0.5; }
        .multi-select-item input:checked { background: var(--text-muted); border-color: var(--text-muted); opacity: 0.7; }
        .multi-select-item.select-all { border-bottom: 1px solid var(--border); margin-bottom: 4px; padding-bottom: 10px; color: var(--text-dim); }
        .multi-select-label { flex: 1; }
        .multi-select-count { font-size: 9px; color: var(--text-muted); font-weight: 500; }
        .multi-select-swatch { display: flex; gap: 2px; padding: 3px; border-radius: 4px; flex-shrink: 0; }
        .multi-select-swatch span { width: 8px; height: 8px; border-radius: 2px; }
        .grid-checkbox { display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: var(--bg-input); border-radius: 50px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text); cursor: pointer; transition: all 0.3s ease; }
        .grid-checkbox:hover { background: var(--bg-card); }
        .grid-checkbox input { appearance: none; -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%; background: transparent; border: 2px solid var(--text-dim); cursor: pointer; transition: all 0.2s ease; }
        .grid-checkbox input:checked { background: var(--teal); border-color: var(--teal); }
        .rarity-filters { display: flex; gap: 6px; align-items: center; }
        .rarity-checkbox { padding: 6px 10px; font-size: 9px; gap: 4px; }
        .rarity-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; }
        .top-10-dot { background: #D4AF37; box-shadow: 0 0 4px #D4AF37; }
        .top-50-dot { background: #C0C0C0; }
        .top-100-dot { background: #CD7F32; }
        /* Color gradient slider for grid view */
        .grid-color-gradient-toggle { padding: 6px; background: none; border: none; border-radius: 50%; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .grid-color-gradient-toggle:hover .color-dot { transform: scale(1.2); box-shadow: 0 0 8px rgba(255,255,255,0.3); }
        .grid-color-gradient-toggle .color-dot { width: 16px; height: 16px; border-radius: 50%; background: conic-gradient(#ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b); flex-shrink: 0; transition: transform 0.2s, box-shadow 0.2s; }
        .grid-color-gradient-toggle.active .color-dot { box-shadow: 0 0 10px rgba(232, 184, 109, 0.5); }
        .grid-color-gradient-bar { position: absolute; left: 0; right: 0; top: 0; bottom: 0; overflow: hidden; z-index: 100; pointer-events: none; opacity: 0; transition: opacity 0.3s ease; display: flex; align-items: stretch; justify-content: center; border-radius: 0; background: transparent; }
        .grid-color-gradient-bar.open { opacity: 1; pointer-events: auto; }
        .grid-color-gradient-inner { padding: 0; width: 100%; display: flex; flex-direction: column; position: relative; }
        .grid-color-gradient-strip { flex: 1; cursor: pointer; position: relative; touch-action: none; border-radius: 0; overflow: hidden; }
        .grid-color-gradient-strip::after { content: ''; position: absolute; inset: 0; box-shadow: inset 0 1px 3px rgba(0,0,0,0.15); pointer-events: none; }
        .grid-color-gradient-marker { position: absolute; width: 18px; height: 18px; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), #888 70%); top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.4); opacity: 1; transition: transform 0.15s ease, box-shadow 0.15s ease; pointer-events: none; cursor: grab; z-index: 3; border: 1.5px solid rgba(255,255,255,0.7); }
        .grid-color-gradient-marker::before { content: ''; position: absolute; left: 50%; top: -200%; width: 1.5px; height: 500%; background: rgba(255,255,255,0.45); transform: translateX(-50%); z-index: -1; pointer-events: none; }
        .grid-color-gradient-strip.active .grid-color-gradient-marker { box-shadow: 0 2px 6px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.9); transform: translate(-50%, -50%) scale(1.1); }
        .grid-color-gradient-meta { position: absolute; top: 0; left: 0; right: 0; display: flex; justify-content: space-between; align-items: center; padding: 4px 12px; z-index: 2; pointer-events: none; }
        .grid-color-gradient-clock { font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace; font-size: 10px; font-weight: 600; letter-spacing: 0.08em; color: rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.25s ease; min-width: 40px; white-space: nowrap; }
        .grid-color-gradient-clock.visible { opacity: 1; }
        .grid-color-gradient-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: rgba(0,0,0,0.45); position: absolute; left: 50%; transform: translateX(-50%); white-space: nowrap; transition: opacity 0.5s ease; }
        .grid-color-gradient-label.hidden { opacity: 0; pointer-events: none; }
        .grid-color-gradient-close { background: none; border: none; color: rgba(0,0,0,0.4); font-size: 14px; cursor: pointer; padding: 0 4px; line-height: 1; opacity: 0.7; transition: opacity 0.2s; pointer-events: auto; }
        .grid-color-gradient-close:hover { opacity: 1; color: rgba(0,0,0,0.7); }
        .grid-color-gradient-hint { font-size: 8px; color: rgba(180, 80, 0, 0.7); opacity: 0; transition: opacity 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600; pointer-events: none; white-space: nowrap; }
        .grid-color-gradient-hint.visible { opacity: 0.8; }
        .gradient-step-toggle { position: absolute; bottom: 4px; right: 6px; z-index: 4; width: 20px; height: 20px; padding: 3px; background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.25); border-radius: 4px; color: rgba(255,255,255,0.7); cursor: pointer; pointer-events: auto; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .gradient-step-toggle:hover { background: rgba(0,0,0,0.4); color: rgba(255,255,255,0.95); border-color: rgba(255,255,255,0.4); }
        .gradient-step-toggle.active { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.45); }
        .gradient-step-toggle svg { width: 100%; height: 100%; }
        @media (max-width: 768px) {
            .grid-color-gradient-inner { padding: 0; }
            .grid-color-gradient-label { display: none; }
            .grid-color-gradient-marker { width: 16px; height: 16px; }
        }
        .grid-filter-spacer { flex: 1; }
        .grid-supply-tracker { width: 120px; height: 28px; position: relative; flex-shrink: 0; cursor: pointer; display: block; text-decoration: none; }
        .grid-supply-bar { position: relative; height: 100%; background: var(--bg-input); border-radius: 14px; overflow: hidden; transition: box-shadow 0.3s ease; }
        .grid-supply-tracker:hover .grid-supply-bar { box-shadow: 0 2px 8px rgba(212, 165, 116, 0.25); }
        .grid-supply-fill { position: absolute; top: 0; left: 0; height: 100%; background: linear-gradient(90deg, rgba(160, 130, 90, 0.5), rgba(180, 150, 100, 0.5), rgba(160, 130, 90, 0.5)); background-size: 200% 100%; border-radius: 14px; transition: all 0.4s ease; }
        .grid-supply-tracker:hover .grid-supply-fill { background: linear-gradient(90deg, #D4A574, #E8B86D, #D4A574); background-size: 200% 100%; }
        .grid-supply-label { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; padding: 0 12px; font-size: 8px; font-weight: 800; letter-spacing: 0.05em; color: rgba(163, 123, 55, 0.85); z-index: 2; transition: color 0.3s ease; }
        .grid-supply-tracker:hover .grid-supply-label { color: #000; }
        .grid-showing-count { font-size: 10px; font-weight: 500; color: var(--text-muted); display: none; letter-spacing: 0.03em; white-space: nowrap; flex-shrink: 0; }
        .grid-showing-count.visible { display: inline; opacity: 0.4; }
        .collector-banner { display: none; flex-direction: row; align-items: center; justify-content: center; gap: 16px; padding: 12px 24px; background: linear-gradient(135deg, #1a1520 0%, #2a2235 50%, #1f1a28 100%); position: relative; z-index: 10; border-bottom: 1px solid rgba(232, 184, 109, 0.15); cursor: pointer; transition: background 0.2s ease; }
        .collector-banner:hover { background: linear-gradient(135deg, #1f1a25 0%, #2f273a 50%, #24202d 100%); }
        .collector-banner.visible { display: flex; }
        .collector-banner-left { display: flex; align-items: baseline; gap: 10px; }
        .collector-banner-label { font-size: 9px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.15em; color: rgba(180, 170, 190, 0.5); }
        .collector-banner-name { font-size: 15px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.12em; color: #e8d4b8; font-family: Helvetica, Arial, sans-serif; cursor: pointer; transition: color 0.2s ease; border-bottom: 1px dashed transparent; padding-bottom: 2px; }
        .collector-banner-name:hover { color: var(--warm); border-bottom-color: rgba(232, 184, 109, 0.4); }
        .collector-banner-right { display: flex; align-items: center; gap: 16px; }
        .collector-banner-phrase { font-size: 11px; font-weight: 400; color: rgba(200, 190, 210, 0.6); font-style: italic; letter-spacing: 0.03em; }
        .collector-banner-wall { background: none; border: 1px solid rgba(232, 184, 109, 0.4); color: rgba(232, 184, 109, 0.8); padding: 6px 14px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; position: relative; z-index: 15; }
        .collector-banner-wall:hover { background: rgba(232, 184, 109, 0.15); border-color: rgba(232, 184, 109, 0.8); color: rgba(232, 184, 109, 1); }
        .collector-banner-count { font-size: 12px; font-weight: 700; color: var(--teal); min-width: 24px; text-align: center; }
        .collector-banner-close { background: rgba(255,255,255,0.08); border: none; color: rgba(200, 190, 210, 0.4); width: 26px; height: 26px; border-radius: 50%; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; position: absolute; right: 16px; top: 50%; transform: translateY(-50%); }
        .collector-banner-close:hover { background: rgba(255,255,255,0.15); color: rgba(200, 190, 210, 0.9); transform: translateY(-50%) scale(1.1); }
        .collector-banner-nav { background: rgba(255,255,255,0.06); border: none; color: rgba(200, 190, 210, 0.5); width: 32px; height: 32px; border-radius: 50%; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; flex-shrink: 0; position: absolute; top: 50%; transform: translateY(-50%); }
        .collector-banner-nav:hover { background: rgba(232, 184, 109, 0.15); color: var(--warm); }
        .collector-banner-prev { left: 16px; }
        .collector-banner-next { right: 56px; }

        /* Wall View Modal */
        .wall-view-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #e8e4e0; z-index: 2000; display: none; flex-direction: column; overflow: hidden; transition: background 0.4s ease; }
        .wall-view-modal.open { display: flex; }
        /* Gray/off-white wall mode (default) */
        .wall-view-modal.wall-gray { background: #e8e4e0; }
        .wall-view-modal.wall-gray .wall-view-content { background: #e8e4e0; }
        .wall-view-modal.wall-gray .wall-view-header { background: rgba(232,228,224,0.95); }
        .wall-view-modal.wall-gray .wall-view-floor { background: linear-gradient(180deg, #ddd8d2 0%, #ccc8c2 100%); }
        .wall-view-modal.wall-gray .wall-view-baseboard { background: #c5c0ba; }
        /* Black wall mode - dark frames and mats */
        .wall-view-modal.wall-black { background: #0f0f0f; }
        .wall-view-modal.wall-black .wall-view-content { background: #0f0f0f; }
        .wall-view-modal.wall-black .wall-view-header { background: rgba(15,15,15,0.95); border-bottom-color: rgba(255,255,255,0.06); }
        .wall-view-modal.wall-black .wall-view-title { color: #555; }
        .wall-view-modal.wall-black .wall-view-title span { color: #aaa; }
        .wall-view-modal.wall-black .wall-view-frame { background: #252525; box-shadow: 0 4px 30px rgba(0,0,0,0.5); }
        .wall-view-modal.wall-black .wall-view-tagline { color: #444; }
        .wall-view-modal.wall-black .wall-view-floor { background: linear-gradient(180deg, #0a0a0a 0%, #050505 100%); }
        .wall-view-modal.wall-black .wall-view-baseboard { background: #0a0a0a; }
        .wall-view-modal.wall-black .wall-view-artwork-label { color: rgba(255,255,255,0.5); }
        .wall-view-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 24px; background: rgba(255,255,255,0.95); border-bottom: 1px solid rgba(0,0,0,0.06); position: absolute; top: 0; left: 0; right: 0; z-index: 10; transition: all 0.5s ease; overflow: visible; }
        .wall-view-modal.dark-mode .wall-view-header { background: rgba(10,10,10,0.95); border-bottom-color: rgba(255,255,255,0.06); }
        .wall-view-header-left { display: flex; align-items: center; gap: 16px; flex-shrink: 0; }
        .wall-view-logo { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 20px; font-weight: 700; letter-spacing: 0.02em; color: #333; }
        .wall-view-modal.dark-mode .wall-view-logo, .wall-view-modal.wall-black .wall-view-logo { color: #fff; }
        .wall-view-collector-name { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: #666; }
        .wall-view-modal.dark-mode .wall-view-collector-name, .wall-view-modal.wall-black .wall-view-collector-name { color: #888; }
        .wall-view-controls { display: flex; align-items: center; gap: 8px; }
        .wall-view-wall-toggle { width: 22px; height: 22px; border-radius: 50%; cursor: pointer; border: 1.5px solid #999; background: linear-gradient(to right, #e8e4e0 50%, #1a1a1a 50%); transition: all 0.2s ease; padding: 0; flex-shrink: 0; }
        .wall-view-wall-toggle:hover { transform: scale(1.15); border-color: #666; }
        .wall-view-modal.wall-black .wall-view-wall-toggle { border-color: #555; }
        .wall-view-mode-toggle { background: none; border: 1px solid #ddd; color: #888; padding: 5px 10px; font-size: 9px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; display: none; }
        .wall-view-modal.wall-black .wall-view-mode-toggle { display: inline-flex; }
        .wall-view-mode-toggle:hover { background: #333; border-color: #333; color: #fff; }
        .wall-view-layout-toggle { background: none; border: 1px solid #ddd; color: #888; padding: 5px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; display: none; }
        .wall-view-modal.show-layout-toggle .wall-view-layout-toggle { display: inline-flex; }
        .wall-view-layout-toggle:hover { background: #333; border-color: #333; color: #fff; }
        .wall-view-layout-toggle.active { background: #333; border-color: #333; color: #fff; }
        .wall-view-modal.wall-black .wall-view-layout-toggle { border-color: #333; color: #666; }
        .wall-view-modal.wall-black .wall-view-layout-toggle:hover, .wall-view-modal.wall-black .wall-view-layout-toggle.active { background: #fff; border-color: #fff; color: #000; }
        .wall-view-hide-empty { background: none; border: 1px solid #ddd; color: #888; padding: 6px 14px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 50px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px; }
        .wall-view-hide-empty .line-icon { font-size: 12px; line-height: 1; }
        .wall-view-hide-empty:hover { background: #333; border-color: #333; color: #fff; }
        .wall-view-hide-empty.active { background: #333; border-color: #333; color: #fff; }
        .wall-view-modal.dark-mode .wall-view-hide-empty, .wall-view-modal.wall-black .wall-view-hide-empty { border-color: #333; color: #666; }
        .wall-view-modal.dark-mode .wall-view-hide-empty:hover, .wall-view-modal.wall-black .wall-view-hide-empty:hover { background: #fff; border-color: #fff; color: #000; }
        .wall-view-modal.dark-mode .wall-view-hide-empty.active, .wall-view-modal.wall-black .wall-view-hide-empty.active { background: #fff; border-color: #fff; color: #000; }
        /* LINE VIEW - horizontal hallway gallery */
        .wall-view-modal.line-view .wall-view-frame.empty-slot { display: none; }
        .wall-view-modal.line-view .try-mode-slot .wall-view-frame.empty-slot { display: block; }
        .wall-view-modal.line-view .wall-view-wall { display: flex !important; flex-wrap: nowrap; gap: 40px; max-width: none; justify-content: flex-start; padding: 40px 120px; }
        .wall-view-modal.line-view .wall-view-artwork { flex: 0 0 auto; width: 140px; }
        .wall-view-modal.line-view .wall-view-room { overflow-x: auto; overflow-y: hidden; display: flex; align-items: center; justify-content: flex-start; }
        .wall-view-modal.line-view .wall-view-wall-wrapper { min-width: max-content; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        @media (max-width: 900px) {
            .wall-view-modal.line-view .wall-view-artwork { width: 120px; }
            .wall-view-modal.line-view .wall-view-wall { gap: 30px; padding: 30px 80px; }
        }
        @media (max-width: 600px) {
            .wall-view-modal.line-view .wall-view-artwork { width: 100px; }
            .wall-view-modal.line-view .wall-view-wall { gap: 24px; padding: 24px 60px; }
        }
        @media (max-width: 768px) {
            .wall-view-header { padding: 8px 12px; gap: 6px; align-items: flex-start; }
            .wall-view-header-left { gap: 8px; padding-top: 4px; }
            .wall-view-logo { font-size: 16px; }
            .wall-view-controls { gap: 5px; flex-wrap: wrap; justify-content: flex-end; }
            .wall-view-back-btn { padding: 5px 10px; font-size: 9px; }
            .wall-view-hide-empty { padding: 5px 10px; font-size: 8px; }
            .wall-view-try-mode { padding: 5px 10px; font-size: 8px; }

            .wall-view-mint-btn { --ch: 18px; padding: 0 4px; min-width: calc(var(--cw) + 8px); }
            .wall-view-close { width: 24px; height: 24px; font-size: 14px; }
        }
        .wall-view-modal.dark-mode .wall-view-mode-toggle { border-color: #333; color: #666; }
        .wall-view-modal.dark-mode .wall-view-mode-toggle:hover { background: #fff; border-color: #fff; color: #000; }
        .wall-view-back-btn { background: rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.15); color: #666; padding: 6px 14px; border-radius: 20px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; }
        .wall-view-back-btn:hover { background: #333; border-color: #333; color: #fff; }
        .wall-view-modal.dark-mode .wall-view-back-btn, .wall-view-modal.wall-black .wall-view-back-btn { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); color: rgba(255,255,255,0.7); }
        .wall-view-modal.dark-mode .wall-view-back-btn:hover, .wall-view-modal.wall-black .wall-view-back-btn:hover { background: #fff; border-color: #fff; color: #000; }
        .wall-view-mint-btn { --ch: 24px; --cw: calc(var(--ch) * 3.985); padding: 0 8px; overflow: visible; flex-shrink: 0; min-width: calc(var(--cw) + 16px); }
        .wall-view-close { background: none; border: 1px solid #ddd; color: #999; width: 28px; height: 28px; border-radius: 50%; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .wall-view-close:hover { background: #333; border-color: #333; color: #fff; }
        .wall-view-modal.dark-mode .wall-view-close { border-color: #333; color: #666; }
        .wall-view-modal.dark-mode .wall-view-close:hover { background: #fff; border-color: #fff; color: #000; }
        .wall-view-content { flex: 1; display: flex; align-items: center; justify-content: center; overflow: auto; background: #ffffff; transition: background 0.5s ease; position: relative; }
        .wall-view-modal.dark-mode .wall-view-content { background: #0a0a0a; }
        .wall-view-lighting { position: absolute; inset: 0; pointer-events: none; opacity: 0; transition: opacity 0.5s ease; }
        .wall-view-modal.lighting-on .wall-view-lighting { opacity: 1; }
        .wall-view-room { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; overflow: auto; cursor: grab; }
        .wall-view-room:active { cursor: grabbing; }
        .wall-view-room.zoomed { overflow: auto; }
        .wall-view-wall-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100%; padding: 100px 60px 60px; transition: transform 0.3s ease; transform-origin: center center; }
        .wall-view-wall { display: grid; gap: 16px; justify-content: center; justify-items: center; align-items: start; width: 100%; max-width: 1800px; margin: 0 auto; grid-template-columns: repeat(auto-fit, minmax(100px, 150px)); position: relative; }
        /* Override columns based on item count for better layouts - consistent 16px gap */
        .wall-view-wall.cols-1 { grid-template-columns: 1fr; max-width: 220px; }
        .wall-view-wall.cols-2 { grid-template-columns: repeat(2, 1fr); max-width: 420px; }
        .wall-view-wall.cols-3 { grid-template-columns: repeat(3, 1fr); max-width: 660px; }
        .wall-view-wall.cols-4 { grid-template-columns: repeat(4, 1fr); max-width: 880px; }
        .wall-view-wall.cols-5 { grid-template-columns: repeat(5, 1fr); max-width: 1100px; }
        .wall-view-wall.cols-6 { grid-template-columns: repeat(6, 1fr); max-width: 1320px; }
        .wall-view-wall.cols-7 { grid-template-columns: repeat(7, 1fr); max-width: 1540px; }
        .wall-view-wall.cols-8 { grid-template-columns: repeat(8, 1fr); max-width: 1760px; }
        .wall-view-wall.cols-9 { grid-template-columns: repeat(9, 1fr); max-width: 1980px; }
        .wall-view-wall.cols-10 { grid-template-columns: repeat(10, 1fr); max-width: 2200px; }
        .wall-view-artwork { display: flex; flex-direction: column; align-items: center; gap: 6px; width: 100%; }
        .wall-view-artwork-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: #666; font-family: 'Nunito', sans-serif; }
        /* Collector info above wall */
        .wall-view-collector-info { text-align: center; margin-bottom: 48px; cursor: pointer; padding: 0 20px; grid-column: 1 / -1; width: 100%; }
        .wall-view-collector-name { font-size: 10px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(200,180,120,0.6); font-family: 'Nunito', sans-serif; transition: color 0.2s ease; max-width: 100%; }
        .wall-view-collector-name:hover { color: #c8b478; }
        .wall-view-modal.wall-black .wall-view-collector-name { color: rgba(200,180,120,0.5); }
        .wall-view-modal.wall-black .wall-view-collector-name:hover { color: #c8b478; }
        /* Zoom controls */
        .wall-view-zoom-controls { position: absolute; bottom: 56px; left: 24px; display: flex; flex-direction: column; gap: 4px; z-index: 20; }
        .wall-view-zoom-btn { width: 32px; height: 32px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: rgba(255,255,255,0.9); color: #666; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .wall-view-zoom-btn:hover { background: #333; color: #fff; border-color: #333; }
        .wall-view-modal.wall-black .wall-view-zoom-btn { background: rgba(30,30,30,0.9); border-color: rgba(255,255,255,0.1); color: #888; }
        .wall-view-modal.wall-black .wall-view-zoom-btn:hover { background: #fff; color: #000; }
        /* Recenter button grid icon */
        .recenter-btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; width: 14px; height: 14px; }
        .recenter-btn-grid span { background: #666; border-radius: 1px; }
        .wall-view-zoom-btn:hover .recenter-btn-grid span { background: #fff; }
        .wall-view-modal.wall-black .recenter-btn-grid span { background: #888; }
        .wall-view-modal.wall-black .wall-view-zoom-btn:hover .recenter-btn-grid span { background: #000; }
        /* Empty slot for aspirational grid - darker background, more visible */
        .wall-view-frame.empty-slot { background: transparent; box-shadow: none; padding: 0; width: 100%; }
        .wall-view-frame.empty-slot .wall-view-empty-frame { width: 100%; background: rgba(255,255,255,0.03); border: 2px dashed rgba(255,255,255,0.15); border-radius: 4px; position: relative; cursor: pointer; transition: all 0.3s ease; aspect-ratio: 9/16; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; box-sizing: border-box; transform: scale(0.95); }
        .wall-view-frame.empty-slot .wall-view-empty-frame:hover { border-color: rgba(255,255,255,0.35); background: rgba(255,255,255,0.06); }
        .wall-view-frame.empty-slot .slot-plus { font-size: 24px; font-weight: 300; color: rgba(255,255,255,0.2); transition: all 0.3s ease; }
        .wall-view-frame.empty-slot .wall-view-empty-frame:hover .slot-plus { color: rgba(255,255,255,0.5); transform: scale(1.1); }
        .wall-view-frame.empty-slot .slot-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.15); transition: color 0.3s ease; }
        .wall-view-frame.empty-slot .wall-view-empty-frame:hover .slot-label { color: rgba(255,255,255,0.4); }
        .wall-view-frame.empty-slot .slot-hide-btn { position: absolute; top: 6px; right: 6px; background: rgba(255,255,255,0.08); border: none; color: rgba(255,255,255,0.25); font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; padding: 4px 8px; border-radius: 10px; cursor: pointer; opacity: 0; transition: all 0.2s ease; }
        .wall-view-frame.empty-slot .wall-view-empty-frame:hover .slot-hide-btn { opacity: 1; }
        .wall-view-frame.empty-slot .slot-hide-btn:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.6); }
        /* Light mode empty frames */
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .wall-view-empty-frame { background: rgba(0,0,0,0.03); border-color: rgba(0,0,0,0.12); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .wall-view-empty-frame:hover { border-color: rgba(0,0,0,0.18); background: rgba(0,0,0,0.02); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .slot-plus { color: rgba(0,0,0,0.08); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .wall-view-empty-frame:hover .slot-plus { color: rgba(0,0,0,0.25); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .slot-hide-btn { background: rgba(0,0,0,0.05); color: rgba(0,0,0,0.3); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .wall-view-frame.empty-slot .slot-hide-btn:hover { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.5); }
        /* Grid/Line toggle button - always visible */
        .wall-view-hide-empty { display: block; }
        /* Empty slot dropdown menu */
        .empty-slot-dropdown { position: fixed; background: #1a1a1a; border: 1px solid rgba(255,255,255,0.15); border-radius: 12px; padding: 8px 0; min-width: 220px; z-index: 2100; box-shadow: 0 8px 32px rgba(0,0,0,0.5); animation: dropdownFadeIn 0.15s ease-out; }
        @keyframes dropdownFadeIn { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
        .empty-slot-dropdown-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; cursor: pointer; transition: background 0.15s ease; }
        .empty-slot-dropdown-item:hover { background: rgba(255,255,255,0.08); }
        .empty-slot-dropdown-item:first-child { border-radius: 8px 8px 0 0; }
        .empty-slot-dropdown-item:last-child { border-radius: 0 0 8px 8px; }
        .empty-slot-dropdown-icon { font-size: 18px; width: 24px; text-align: center; }
        .empty-slot-dropdown-text { flex: 1; }
        .empty-slot-dropdown-title { font-size: 12px; font-weight: 700; color: #fff; text-transform: uppercase; letter-spacing: 0.05em; }
        .empty-slot-dropdown-desc { font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 2px; }
        .empty-slot-dropdown-divider { height: 1px; background: rgba(255,255,255,0.1); margin: 6px 0; }
        /* Grid status nudge - bottom bar message */
        .wall-view-grid-nudge { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(20,20,20,0.95); border-top: 1px solid rgba(255,255,255,0.08); padding: 14px 24px; display: flex; align-items: center; justify-content: center; gap: 16px; z-index: 25; backdrop-filter: blur(12px); opacity: 0; transform: translateY(100%); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; }
        .wall-view-grid-nudge.ready { display: flex; }
        .wall-view-grid-nudge.ready.show { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .wall-view-grid-nudge-text { font-size: 11px; font-weight: 500; color: rgba(255,255,255,0.7); letter-spacing: 0.05em; text-transform: uppercase; }
        .wall-view-grid-nudge-text span { color: #fff; font-weight: 700; }
        .wall-view-grid-nudge-text .grid-count { color: #c9a227; }
        .wall-view-nudge-btn { width: 36px; height: 36px; border-radius: 8px; background: rgba(40,40,45,0.9); border: 1px solid rgba(255,255,255,0.15); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; flex-shrink: 0; }
        .wall-view-nudge-btn:hover { background: rgba(60,60,65,1); border-color: rgba(255,255,255,0.25); transform: scale(1.05); }
        .nudge-btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; width: 16px; height: 16px; }
        .nudge-btn-grid span { background: rgba(255,255,255,0.5); border-radius: 2px; }
        .wall-view-nudge-btn:hover .nudge-btn-grid span { background: rgba(255,255,255,0.8); }
        /* Light mode grid nudge */
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-grid-nudge { background: rgba(250,250,252,0.98); border-top-color: rgba(0,0,0,0.1); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-grid-nudge-text { color: rgba(0,0,0,0.6); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-grid-nudge-text span { color: #000; }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-nudge-btn { background: rgba(0,0,0,0.08); border-color: rgba(0,0,0,0.15); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-nudge-btn:hover { background: rgba(0,0,0,0.12); border-color: rgba(0,0,0,0.25); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .nudge-btn-grid span { background: rgba(0,0,0,0.4); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-nudge-btn:hover .nudge-btn-grid span { background: rgba(0,0,0,0.6); }
        /* Collector suggestion section */
        .wall-view-tips-toggle { position: fixed; bottom: 130px; right: 24px; width: 44px; height: 44px; border-radius: 8px; background: rgba(30,30,35,0.9); border: 1px solid rgba(255,255,255,0.1); cursor: pointer; display: none; align-items: center; justify-content: center; z-index: 23; transition: all 0.2s ease; }
        .wall-view-tips-toggle.has-tips { display: flex; }
        .wall-view-tips-toggle:hover { background: rgba(50,50,55,0.95); border-color: rgba(255,255,255,0.2); transform: scale(1.05); animation: none; }
        /* Light mode tips toggle */
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-tips-toggle { background: rgba(250,250,252,0.95); border-color: rgba(0,0,0,0.15); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-tips-toggle:hover { background: rgba(240,240,245,1); border-color: rgba(0,0,0,0.25); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-tips-toggle .tips-icon { filter: invert(1); }
        .wall-view-tips-toggle .tips-icon { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 10px; line-height: 1; }
        /* Hover tooltip for tips toggle */
        .wall-view-tips-hover { position: fixed; bottom: 130px; right: 76px; background: rgba(20,20,24,0.95); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 8px 12px; font-size: 11px; color: rgba(255,255,255,0.75); z-index: 23; pointer-events: none; opacity: 0; transition: opacity 0.2s ease; max-width: 220px; line-height: 1.4; white-space: normal; backdrop-filter: blur(8px); text-align: right; }
        .wall-view-tips-toggle:hover + .wall-view-tips-hover { opacity: 1; }
        .wall-view-tips-hover:empty { display: none; }
        /* Light mode hover tooltip */
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-tips-hover { background: rgba(250,250,252,0.98); border-color: rgba(0,0,0,0.1); color: rgba(0,0,0,0.65); }
        @keyframes tipsGlow {
            0%, 85% { box-shadow: none; transform: scale(1); }
            90% { box-shadow: 0 0 12px rgba(201, 162, 39, 0.5); transform: scale(1.08); border-color: rgba(201, 162, 39, 0.5); }
            95% { box-shadow: 0 0 8px rgba(201, 162, 39, 0.3); transform: scale(1.04); }
            100% { box-shadow: none; transform: scale(1); }
        }
        .wall-view-suggestion { position: fixed; bottom: 190px; right: 24px; background: rgba(30,30,35,0.95); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 16px 24px; display: none; flex-direction: column; gap: 12px; z-index: 24; backdrop-filter: blur(12px); max-width: 340px; text-align: center; transform: none; left: auto; }
        .wall-view-suggestion.visible { display: flex; }
        .wall-view-suggestion-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.12em; color: rgba(255,255,255,0.5); }
        .wall-view-suggestion-text { font-size: 12px; color: rgba(255,255,255,0.8); line-height: 1.5; }
        .wall-view-suggestion-cities { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 4px; }
        .wall-view-suggestion-city { width: 48px; height: 60px; border-radius: 4px; overflow: hidden; cursor: pointer; transition: all 0.2s ease; border: 2px solid transparent; }
        .wall-view-suggestion-city:hover { transform: scale(1.08); border-color: rgba(255,255,255,0.3); }
        .wall-view-suggestion-city img { width: 100%; height: 100%; object-fit: cover; }
        .wall-view-suggestion-cta { font-size: 10px; color: rgba(255,255,255,0.4); margin-top: 4px; }
        .wall-view-suggestion-cta a { color: rgba(255,255,255,0.6); text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .wall-view-suggestion-cta a:hover { color: #fff; border-color: rgba(255,255,255,0.5); }
        .suggestion-options-dropdown { background: #1a1a1a; border: 1px solid rgba(255,255,255,0.15); border-radius: 12px; padding: 8px 0; min-width: 240px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); animation: dropdownFadeIn 0.15s ease-out; }
        .suggestion-option { display: flex; align-items: center; gap: 12px; padding: 12px 16px; cursor: pointer; transition: background 0.15s ease; }
        .suggestion-option:hover { background: rgba(255,255,255,0.08); }
        .suggestion-option-icon { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.1); border-radius: 6px; font-size: 14px; }
        .suggestion-option-text { flex: 1; }
        .suggestion-option-title { font-size: 12px; font-weight: 600; color: #fff; margin-bottom: 2px; }
        .suggestion-option-desc { font-size: 10px; color: rgba(255,255,255,0.5); }
        .wall-view-suggestion-close { position: absolute; top: 8px; right: 8px; background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer; font-size: 14px; padding: 4px; }
        .wall-view-suggestion-close:hover { color: rgba(255,255,255,0.7); }
        /* Light mode suggestion popup */
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion { background: rgba(250,250,252,0.98); border-color: rgba(0,0,0,0.1); box-shadow: 0 8px 32px rgba(0,0,0,0.15); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-label { color: rgba(0,0,0,0.45); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-text { color: rgba(0,0,0,0.75); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-city { border-color: rgba(0,0,0,0.1); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-city:hover { border-color: rgba(0,0,0,0.3); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-cta { color: rgba(0,0,0,0.4); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-cta a { color: rgba(0,0,0,0.6); border-bottom-color: rgba(0,0,0,0.2); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-cta a:hover { color: #000; border-color: rgba(0,0,0,0.5); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-close { color: rgba(0,0,0,0.3); }
        .wall-view-modal:not(.dark-mode):not(.wall-black) .wall-view-suggestion-close:hover { color: rgba(0,0,0,0.6); }
        /* Grid icon - dynamic rectangles at 9:16 ratio */
        .grid-icon { display: inline-grid; gap: 1px; vertical-align: middle; margin: 0 4px; }
        .grid-icon-rect { background: currentColor; border-radius: 0.5px; aspect-ratio: 9/16; opacity: 0.7; }
        .grid-icon.grid-2x2 { grid-template-columns: repeat(2, 6px); }
        .grid-icon.grid-3x2 { grid-template-columns: repeat(3, 5px); }
        .grid-icon.grid-3x3 { grid-template-columns: repeat(3, 5px); }
        .grid-icon.grid-4x3 { grid-template-columns: repeat(4, 4px); }
        .grid-icon.grid-4x4 { grid-template-columns: repeat(4, 4px); }
        .grid-icon.grid-5x4 { grid-template-columns: repeat(5, 3px); }
        .grid-icon.grid-5x5 { grid-template-columns: repeat(5, 3px); }
        /* Try/Edit mode toggle */
        .wall-view-try-mode { background: none; border: 1px solid rgba(201, 162, 39, 0.4); color: rgba(201, 162, 39, 0.8); padding: 6px 14px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 50px; cursor: pointer; transition: all 0.2s ease; }
        .wall-view-try-mode:hover { background: rgba(201, 162, 39, 0.15); border-color: rgba(201, 162, 39, 0.7); color: #c9a227; }
        .wall-view-try-mode.active { background: rgba(201, 162, 39, 0.25); border-color: #c9a227; color: #c9a227; box-shadow: 0 0 12px rgba(201, 162, 39, 0.3); }
        .wall-view-modal.dark-mode .wall-view-try-mode, .wall-view-modal.wall-black .wall-view-try-mode { border-color: rgba(201, 162, 39, 0.3); color: rgba(201, 162, 39, 0.6); }
        .wall-view-modal.dark-mode .wall-view-try-mode:hover, .wall-view-modal.wall-black .wall-view-try-mode:hover { background: rgba(201, 162, 39, 0.1); border-color: rgba(201, 162, 39, 0.5); color: #c9a227; }
        .wall-view-modal.dark-mode .wall-view-try-mode.active, .wall-view-modal.wall-black .wall-view-try-mode.active { background: rgba(201, 162, 39, 0.2); border-color: #c9a227; color: #c9a227; }
        /* Temporary city indicator - uses dynamic palette color via inline style */
        .wall-view-frame.temp-city { position: relative; cursor: pointer; }
        .wall-view-frame.temp-city .temp-city-badge { position: absolute; top: 6px; right: 6px; background: var(--badge-bg, #c9a227); color: var(--badge-text, #000); font-size: 7px; font-weight: 700; padding: 3px 6px; border-radius: 2px; letter-spacing: 0.05em; z-index: 10; text-transform: uppercase; }
        .wall-view-frame.temp-city .wall-view-frame-mat { opacity: 0.9; }
        /* Temp city action buttons on hover */
        .temp-city-actions { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); display: none; gap: 6px; z-index: 15; }
        .wall-view-frame.temp-city:hover .temp-city-actions { display: flex; }
        .temp-city-action { background: rgba(0,0,0,0.8); border: none; border-radius: 4px; color: #fff; font-size: 8px; font-weight: 600; padding: 5px 8px; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.05em; white-space: nowrap; }
        .temp-city-action:hover { background: #fff; color: #000; }
        .temp-city-action.offer { background: var(--badge-bg, #c9a227); color: var(--badge-text, #000); }
        .temp-city-action.offer:hover { background: #fff; color: #000; }
        /* Remove temp city button */
        .temp-city-remove { position: absolute; top: -8px; right: -8px; width: 20px; height: 20px; background: var(--badge-bg, #c9a227); border: none; border-radius: 50%; color: var(--badge-text, #000); font-size: 12px; font-weight: 700; cursor: pointer; display: none; align-items: center; justify-content: center; z-index: 15; transition: all 0.2s ease; }
        .wall-view-frame.temp-city:hover .temp-city-remove { display: flex; }
        .temp-city-remove:hover { background: #fff; transform: scale(1.1); }
        /* Inline try-another + button on last placed try city */
        .try-add-more { position: absolute; bottom: -6px; right: -6px; width: 18px; height: 18px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 50%; color: rgba(255,255,255,0.3); font-size: 14px; font-weight: 300; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 16; transition: all 0.2s ease; line-height: 1; }
        .try-add-more:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.8); border-color: rgba(255,255,255,0.35); transform: scale(1.15); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .try-add-more { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.12); color: rgba(0,0,0,0.25); }
        .wall-view-modal:not(.wall-black):not(.dark-mode) .try-add-more:hover { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.6); border-color: rgba(0,0,0,0.25); }
        /* Try city picker modal */
        .try-city-picker { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 3000; backdrop-filter: blur(8px); }
        .try-city-picker-content { background: #1a1a1a; border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 24px; width: 380px; max-width: 90vw; }
        .try-city-picker-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .try-city-picker-title { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: #fff; }
        .try-city-picker-close { background: none; border: none; color: #666; font-size: 24px; cursor: pointer; padding: 0; line-height: 1; transition: color 0.2s; }
        .try-city-picker-close:hover { color: #fff; }
        .try-city-picker-input-row { display: flex; gap: 8px; margin-bottom: 16px; }
        .try-city-picker-input { flex: 1; background: #0a0a0a; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 12px 16px; color: #fff; font-size: 14px; font-family: inherit; }
        .try-city-picker-input:focus { outline: none; border-color: #c9a227; }
        .try-city-picker-input::placeholder { color: #555; }
        .try-city-picker-add { background: #c9a227; border: none; border-radius: 8px; padding: 12px 20px; color: #000; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s; }
        .try-city-picker-add:hover { background: #fff; }
        .try-city-picker-preview { min-height: 120px; display: flex; align-items: center; justify-content: center; margin-bottom: 16px; }
        .try-city-picker-preview img { max-height: 150px; border-radius: 4px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .try-city-picker-suggestions { border-top: 1px solid rgba(255,255,255,0.08); padding-top: 16px; }
        .try-city-picker-quick { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .try-city-picker-thumb { cursor: pointer; transition: all 0.2s; border-radius: 3px; overflow: hidden; position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .try-city-picker-thumb:hover { transform: scale(1.08); box-shadow: 0 4px 16px rgba(0,0,0,0.4); }
        .try-city-picker-thumb img { width: 56px; height: 100px; object-fit: cover; display: block; }
        .try-city-picker-energy-filters { display: flex; gap: 6px; margin-bottom: 16px; flex-wrap: wrap; justify-content: center; }
        .try-city-picker-energy-btn { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 6px 12px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: rgba(255,255,255,0.5); cursor: pointer; transition: all 0.2s; }
        .try-city-picker-energy-btn:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.8); }
        .try-city-picker-energy-btn.active { background: rgba(201, 162, 39, 0.2); border-color: rgba(201, 162, 39, 0.5); color: #c9a227; }
        .try-city-picker-energy-btn.recommended { position: relative; }
        .try-city-picker-energy-btn.recommended::after { content: 'ðŸ™ï¸'; position: absolute; top: -6px; right: -6px; font-size: 10px; }
        .try-city-picker-section-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.3); margin-bottom: 10px; text-align: center; }
        .try-city-picker-tabs { display: flex; gap: 4px; margin-bottom: 16px; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 12px; }
        .try-city-picker-tab { flex: 1; background: none; border: none; padding: 8px 4px; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: rgba(255,255,255,0.4); cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent; margin-bottom: -13px; }
        .try-city-picker-tab:hover { color: rgba(255,255,255,0.7); }
        .try-city-picker-tab.active { color: #c9a227; border-bottom-color: #c9a227; }
        .try-city-picker-tab-content { display: none; min-height: 120px; }
        .try-city-picker-tab-content.active { display: block; }
        .try-city-picker-smart-row { margin-bottom: 16px; }
        .try-city-picker-smart-label { font-size: 9px; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .try-city-picker-smart-label .label-icon { color: #c9a227; }
        .try-city-picker-smart-cities { display: flex; gap: 6px; flex-wrap: wrap; }
        .wall-view-frame { width: 100%; background: #e8e4dc; padding: 3px; box-shadow: 0 4px 20px rgba(0,0,0,0.1), 0 8px 40px rgba(0,0,0,0.06); position: relative; cursor: pointer; transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease; box-sizing: border-box; }
        .wall-view-frame:hover { transform: scale(1.02); box-shadow: 0 8px 30px rgba(0,0,0,0.15), 0 12px 50px rgba(0,0,0,0.1); z-index: 5; }
        .wall-view-modal.dark-mode .wall-view-frame { background: #1a1a1a; box-shadow: 0 4px 30px rgba(0,0,0,0.4), 0 8px 50px rgba(0,0,0,0.3); }
        .wall-view-frame-mat { background: #ffffff; padding: 8px; position: relative; }
        .wall-view-frame-inner { background: #fff; padding: 0; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.03); }
        .wall-view-modal.dark-mode .wall-view-frame-mat { background: #111; }
        .wall-view-modal.dark-mode .wall-view-frame-inner { background: #0a0a0a; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03); }
        .wall-view-modal.wall-black .wall-view-frame-mat { background: #1a1a1a; }
        .wall-view-modal.wall-black .wall-view-frame-inner { background: #121212; box-shadow: none; }
        .wall-view-frame img { display: block; width: 100%; height: auto; aspect-ratio: 9/16; object-fit: contain; transition: all 0.3s ease; }
        /* Drag-to-swap states */
        .wall-view-artwork.dragging { opacity: 0.4; transform: scale(0.95); transition: opacity 0.2s ease, transform 0.2s ease; }
        .wall-view-artwork.dragging .wall-view-frame { box-shadow: none; }
        .wall-view-artwork.drag-over .wall-view-frame { box-shadow: 0 0 0 2px rgba(201, 162, 39, 0.8), 0 0 20px rgba(201, 162, 39, 0.3); transform: scale(1.04); }
        .wall-view-modal.wall-black .wall-view-artwork.drag-over .wall-view-frame { box-shadow: 0 0 0 2px rgba(201, 162, 39, 0.8), 0 0 24px rgba(201, 162, 39, 0.4); }
        .wall-view-artwork.swap-flash { animation: swapFlash 0.35s ease-out; }
        @keyframes swapFlash { 0% { transform: scale(0.92); opacity: 0.6; } 50% { transform: scale(1.03); } 100% { transform: scale(1); opacity: 1; } }
        /* Responsive wall - consistent 16px gap, adjust frame size for viewport */
        @media (max-width: 1400px) {
            .wall-view-wall { grid-template-columns: repeat(auto-fit, minmax(100px, 160px)); }
        }
        @media (max-width: 1100px) {
            .wall-view-wall { grid-template-columns: repeat(auto-fit, minmax(90px, 140px)); }
            .wall-view-frame { padding: 3px; }
            .wall-view-frame-mat { padding: 5px; }
        }
        @media (max-width: 900px) {
            .wall-view-wall { grid-template-columns: repeat(auto-fit, minmax(80px, 120px)); }
            .wall-view-frame { padding: 2px; }
            .wall-view-frame-mat { padding: 4px; }
            .wall-view-wall-wrapper { padding: 80px 40px 60px; }
        }
        @media (max-width: 700px) {
            .wall-view-wall { gap: 12px; grid-template-columns: repeat(auto-fit, minmax(60px, 90px)); }
            .wall-view-frame { padding: 2px; }
            .wall-view-frame-mat { padding: 3px; }
            .wall-view-wall-wrapper { padding: 70px 20px 50px; }
        }
        .wall-view-placard { text-align: center; }
        .wall-view-placard-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: #333; margin-bottom: 3px; transition: color 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-placard-title { color: #ccc; }
        .wall-view-placard-collector { font-size: 9px; font-weight: 400; color: #888; letter-spacing: 0.05em; transition: color 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-placard-collector { color: #555; }
        .wall-view-placard-date { font-size: 8px; font-weight: 400; font-style: italic; color: #aaa; margin-top: 2px; transition: color 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-placard-date { color: #444; }
        .wall-view-floor { height: 50px; background: linear-gradient(180deg, #f0eeea 0%, #e8e4de 50%, #ddd8d0 100%); box-shadow: inset 0 2px 10px rgba(0,0,0,0.04); flex-shrink: 0; transition: background 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-floor { background: linear-gradient(180deg, #0f0f0f 0%, #080808 50%, #050505 100%); }
        .wall-view-baseboard { height: 6px; background: linear-gradient(180deg, #f5f3f0 0%, #eae6e0 100%); box-shadow: 0 -1px 0 rgba(0,0,0,0.03); flex-shrink: 0; transition: background 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-baseboard { background: linear-gradient(180deg, #151515 0%, #0a0a0a 100%); }
        .wall-view-nav { position: absolute; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: #888; width: 40px; height: 40px; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; z-index: 20; }
        .wall-view-nav:hover { color: #ccc; }
        .wall-view-modal.dark-mode .wall-view-nav { color: #666; }
        .wall-view-modal.dark-mode .wall-view-nav:hover { color: #aaa; }
        .wall-view-nav.prev { left: 20px; }
        .wall-view-nav.next { right: 20px; }
        .wall-view-print-btn { position: absolute; bottom: 80px; right: 24px; background: rgba(0,0,0,0.7); border: none; color: #fff; padding: 8px 14px; font-size: 9px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; z-index: 20; opacity: 0.6; }
        .wall-view-print-btn:hover { opacity: 1; background: #000; }
        /* Print Inquiry Modal */
        .print-inquiry-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 3000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(8px); }
        .print-inquiry-modal.open { display: flex; }
        .print-inquiry-content { background: #1a1a1a; border-radius: 16px; padding: 24px; max-width: 380px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5); position: relative; }
        .print-inquiry-close { position: absolute; top: 16px; right: 16px; background: none; border: none; color: #666; font-size: 24px; cursor: pointer; line-height: 1; padding: 4px; z-index: 2; }
        .print-inquiry-close:hover { color: #fff; }
        .print-inquiry-title { font-size: 15px; font-weight: 700; color: #fff; margin-bottom: 14px; text-transform: uppercase; letter-spacing: 0.05em; }
        /* Frame preview in print form */
        .print-inquiry-frame-preview { display: flex; flex-direction: column; align-items: center; margin-bottom: 16px; padding: 20px 16px 12px; background: #f5f3f0; border-radius: 10px; position: relative; }
        .print-inquiry-frame-preview::before { content: ''; position: absolute; inset: 0; border-radius: 10px; background: radial-gradient(ellipse 80% 60% at 30% 30%, rgba(255,255,255,0.5) 0%, transparent 50%); pointer-events: none; }
        .print-inquiry-mini-frame { background: #c4a47a; padding: 3px; box-shadow: 4px 6px 16px rgba(0,0,0,0.15), 2px 3px 6px rgba(0,0,0,0.1); position: relative; z-index: 1; }
        .print-inquiry-mini-inner { background: #ffffff; padding: 5px; box-shadow: inset 0 0 1px rgba(0,0,0,0.08); }
        .print-inquiry-mini-inner img { display: block; width: 100%; height: auto; max-height: 180px; object-fit: contain; box-shadow: 0 1px 2px rgba(0,0,0,0.08); border: none; box-sizing: border-box; }
        .print-inquiry-frame-label { font-size: 10px; font-weight: 600; color: #888; letter-spacing: 0.1em; margin-top: 10px; position: relative; z-index: 1; }
        .print-inquiry-frame-colors { display: flex; gap: 8px; margin-top: 8px; position: relative; z-index: 1; }
        .print-inquiry-frame-color { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.15); }
        .print-inquiry-frame-color:hover { transform: scale(1.15); }
        .print-inquiry-frame-color.active { border-color: var(--warm); box-shadow: 0 0 0 2px rgba(201, 162, 39, 0.3); }
        .print-inquiry-frame-color[data-color="light-wood"] { background: #c4a47a; }
        .print-inquiry-frame-color[data-color="white"] { background: #f5f3f0; border: 2px solid #ddd; }
        .print-inquiry-frame-color.active[data-color="white"] { border-color: var(--warm); }
        .print-inquiry-frame-color[data-color="black"] { background: #1a1a1a; }
        .print-inquiry-frame-color[data-color="dark-wood"] { background: #5a3d2b; }
        /* Frame color variants in print form */
        .print-inquiry-mini-frame.frame-white { background: #faf9f7; }
        .print-inquiry-mini-frame.frame-white .print-inquiry-mini-inner { background: #ffffff; }
        .print-inquiry-mini-frame.frame-black { background: #1a1a1a; }
        .print-inquiry-mini-frame.frame-black .print-inquiry-mini-inner { background: #f5f3f0; }
        .print-inquiry-mini-frame.frame-dark-wood { background: #5a3d2b; }
        .print-inquiry-mini-frame.frame-dark-wood .print-inquiry-mini-inner { background: #faf9f7; }
        /* Frameless preview (poster/mini print, unframed) */
        .print-inquiry-mini-frame.frameless { background: transparent; padding: 0; box-shadow: none; }
        .print-inquiry-mini-frame.frameless .print-inquiry-mini-inner { background: transparent; padding: 0; box-shadow: none; }
        .print-inquiry-mini-frame.frameless .print-inquiry-mini-inner img { box-shadow: 4px 6px 16px rgba(0,0,0,0.15), 2px 3px 6px rgba(0,0,0,0.1); }
        .print-inquiry-frame-preview.dark-wall .print-inquiry-mini-frame.frameless .print-inquiry-mini-inner img { box-shadow: 4px 6px 16px rgba(0,0,0,0.4), 2px 3px 6px rgba(0,0,0,0.3); }
        /* Dark wall for frame preview */
        .print-inquiry-frame-preview.dark-wall { background: #0a0a0a; }
        .print-inquiry-frame-preview.dark-wall::before { background: radial-gradient(ellipse 80% 60% at 30% 30%, rgba(255,255,255,0.03) 0%, transparent 50%); }
        .print-inquiry-frame-preview.dark-wall .print-inquiry-frame-label { color: #555; }
        .print-inquiry-frame-preview.dark-wall .print-inquiry-mini-frame { box-shadow: 4px 6px 16px rgba(0,0,0,0.4), 2px 3px 6px rgba(0,0,0,0.3); }
        .print-inquiry-wall-toggle { position: absolute; top: 8px; left: 8px; width: 28px; height: 28px; border: none; background: rgba(0,0,0,0.06); color: #999; font-size: 12px; cursor: pointer; border-radius: 50%; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; z-index: 2; }
        .print-inquiry-wall-toggle:hover { background: rgba(0,0,0,0.12); color: #666; }
        .print-inquiry-frame-preview.dark-wall .print-inquiry-wall-toggle { background: rgba(255,255,255,0.08); color: #666; }
        .print-inquiry-frame-preview.dark-wall .print-inquiry-wall-toggle:hover { background: rgba(255,255,255,0.15); color: #999; }
        /* Multi-city strip in preview */
        .print-inquiry-city-strip { display: flex; gap: 4px; margin-top: 8px; position: relative; z-index: 1; }
        .print-inquiry-city-strip-thumb { width: 28px; height: 28px; border-radius: 4px; overflow: hidden; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; opacity: 0.5; transition: all 0.2s ease; }
        .print-inquiry-city-strip-thumb.active { opacity: 1; border-color: var(--warm); }
        .print-inquiry-city-strip-thumb img { width: 100%; height: 100%; object-fit: cover; }
        .print-inquiry-city-strip-more { width: 28px; height: 28px; border-radius: 4px; background: rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center; font-size: 8px; color: #666; font-weight: 600; }
        /* Simplified form fields */
        .print-inquiry-field { margin-bottom: 12px; }
        .print-inquiry-field label { display: block; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: #888; margin-bottom: 5px; }
        .print-inquiry-field input, .print-inquiry-field textarea, .print-inquiry-field select { width: 100%; padding: 10px 12px; background: #2a2a2a; border: 1px solid #333; border-radius: 8px; color: #fff; font-size: 12px; font-family: inherit; }
        .print-inquiry-field input:focus, .print-inquiry-field textarea:focus, .print-inquiry-field select:focus { outline: none; border-color: #c9a227; }
        .print-inquiry-field textarea { resize: vertical; min-height: 60px; }
        .print-inquiry-field select { cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%23888'%3E%3Cpath d='M1 3l4 4 4-4'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 14px center; }
        .print-inquiry-sizes { display: flex; gap: 6px; margin-bottom: 6px; }
        .print-inquiry-size-option { flex: 1; background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 8px 4px; cursor: pointer; transition: all 0.2s ease; text-align: center; }
        .print-inquiry-size-option:hover { border-color: #555; }
        .print-inquiry-size-option.active { border-color: #c9a227; background: rgba(201, 162, 39, 0.1); }
        .print-inquiry-size-option .size-dims { font-size: 12px; font-weight: 700; color: #fff; margin-bottom: 1px; }
        .print-inquiry-size-option .size-cm { font-size: 8px; color: #666; margin-bottom: 3px; }
        .print-inquiry-size-option .size-price { font-size: 11px; font-weight: 700; color: #888; margin-bottom: 0; }
        .print-inquiry-size-option.active .size-price { color: #c9a227; }
        .print-inquiry-size-option .size-price-converted { font-size: 8px; color: #666; margin-bottom: 2px; min-height: 0; }
        .print-inquiry-size-option .size-price-converted:empty { display: none; }
        .print-inquiry-size-option.active .size-price-converted { color: #a88620; }
        .print-inquiry-size-option .size-label { font-size: 7px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.03em; color: #666; }
        .print-inquiry-size-option.active .size-label { color: #a88620; }
        .print-inquiry-size-option { position: relative; }
        .print-inquiry-size-option .size-signature { position: absolute; top: 4px; right: 4px; width: 22px; height: auto; opacity: 0.18; pointer-events: none; }
        .print-inquiry-size-option.active .size-signature { opacity: 0.35; }
        .print-inquiry-shipping-note { font-size: 8px; color: #555; margin-top: 8px; text-align: center; }
        /* Collapsible details section */
        .print-inquiry-details-toggle { display: flex; align-items: center; gap: 6px; background: none; border: none; color: #555; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; padding: 8px 0; margin-top: 4px; transition: color 0.2s; }
        .print-inquiry-details-toggle:hover { color: #888; }
        .print-inquiry-details-toggle .toggle-arrow { font-size: 8px; transition: transform 0.2s; }
        .print-inquiry-details-toggle.open .toggle-arrow { transform: rotate(90deg); }
        .print-inquiry-details-extra { display: none; }
        .print-inquiry-details-extra.open { display: block; }
        .print-inquiry-type-note { font-size: 9px; color: #555; line-height: 1.5; margin-bottom: 12px; }
        .print-inquiry-type-note a { color: var(--warm); text-decoration: none; }
        .print-inquiry-type-note a:hover { text-decoration: underline; }
        .print-inquiry-actions { display: flex; gap: 10px; margin-top: 18px; }
        .print-inquiry-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; }
        .print-inquiry-btn.primary { background: #c9a227; color: #000; }
        .print-inquiry-btn.primary:hover { background: #ddb840; }
        .print-inquiry-btn.secondary { background: #333; color: #888; }
        .print-inquiry-btn.secondary:hover { background: #444; color: #fff; }
        .print-inquiry-success { text-align: center; padding: 20px 0; }
        .print-inquiry-success-icon { font-size: 48px; margin-bottom: 16px; }
        .print-inquiry-success-text { font-size: 14px; color: #fff; margin-bottom: 8px; }
        .print-inquiry-success-sub { font-size: 11px; color: #888; }
        .print-inquiry-shop-link { display: block; margin-top: 20px; text-align: center; font-size: 10px; color: #666; text-decoration: none; transition: color 0.2s; }
        .print-inquiry-shop-link:hover { color: #c9a227; }
        /* Print inquiry dark mode (inherits from wall view or frame mockup) */
        .print-inquiry-modal.dark { background: rgba(0,0,0,0.95); }
        .print-inquiry-modal.dark .print-inquiry-content { background: #0f0f0f; }
        .print-inquiry-modal.dark .print-inquiry-frame-preview { background: #0a0a0a; }
        .print-inquiry-modal.dark .print-inquiry-frame-preview::before { background: radial-gradient(ellipse 80% 60% at 30% 30%, rgba(255,255,255,0.03) 0%, transparent 50%); }
        .print-inquiry-modal.dark .print-inquiry-frame-label { color: #555; }
        .print-inquiry-modal.dark .print-inquiry-mini-frame { box-shadow: 4px 6px 16px rgba(0,0,0,0.4), 2px 3px 6px rgba(0,0,0,0.3); }
        .print-inquiry-modal.dark .print-inquiry-wall-toggle { background: rgba(255,255,255,0.08); color: #666; }
        .print-inquiry-modal.dark .print-inquiry-field input,
        .print-inquiry-modal.dark .print-inquiry-field textarea,
        .print-inquiry-modal.dark .print-inquiry-field select { background: #1a1a1a; border-color: #222; }
        .print-inquiry-modal.dark .print-inquiry-size-option { background: #1a1a1a; border-color: #222; }
        .print-inquiry-modal.dark .print-inquiry-size-option:hover { border-color: #444; }
        .print-inquiry-modal.dark .print-inquiry-btn.secondary { background: #1a1a1a; }
        .print-inquiry-modal.dark .print-inquiry-details-toggle { color: #444; }
        .print-inquiry-modal.dark .print-inquiry-details-toggle:hover { color: #666; }

        /* Energy Quadrant Trigger Button */
        .energy-quadrant-btn { position: relative; width: 34px; height: 34px; border: none; background: rgba(255,255,255,0.06); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); opacity: 0.8; font-size: 15px; line-height: 1; filter: saturate(0.6); border: 1px solid rgba(255,255,255,0.08); }
        .energy-quadrant-btn:hover { opacity: 1; filter: saturate(1); transform: scale(1.15); border-color: transparent; background: linear-gradient(135deg, rgba(255,179,71,0.25), rgba(135,206,235,0.25), rgba(221,160,221,0.25), rgba(232,184,109,0.3)); box-shadow: 0 0 16px rgba(232,184,109,0.25), 0 0 32px rgba(135,206,235,0.12); }
        .energy-quadrant-btn:active { transform: scale(0.95); }
        .energy-quadrant-btn.launching { animation: eqBtnLaunch 0.7s cubic-bezier(0.22, 1, 0.36, 1) forwards; pointer-events: none; }
        @keyframes eqBtnShimmer {
            0% { background-position: 200% center; }
            100% { background-position: -200% center; }
        }
        @keyframes eqBtnLaunch {
            0% { transform: scale(1); opacity: 1; filter: saturate(1); background: linear-gradient(135deg, rgba(255,179,71,0.3), rgba(135,206,235,0.3), rgba(221,160,221,0.3), rgba(232,184,109,0.4)); box-shadow: 0 0 20px rgba(232,184,109,0.3); border-color: transparent; }
            20% { transform: scale(1.3); opacity: 1; background: linear-gradient(135deg, #ffb347, #87ceeb, #dda0dd, #E8B86D); box-shadow: 0 0 30px rgba(232,184,109,0.5), 0 0 60px rgba(135,206,235,0.3); border-color: transparent; }
            40% { transform: scale(1.2) translateX(-20px); opacity: 1; }
            70% { transform: scale(2.5) translateX(-120px); opacity: 0.6; filter: saturate(1.5) brightness(1.3); box-shadow: 0 0 50px rgba(232,184,109,0.6), 0 0 100px rgba(135,206,235,0.3); }
            100% { transform: scale(4) translateX(-200px); opacity: 0; filter: saturate(2) brightness(1.5); }
        }
        /* Energy Quadrant Modal */
        .energy-quadrant-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(8, 8, 12, 0.88); z-index: 2500; display: none; align-items: center; justify-content: center; backdrop-filter: blur(12px); padding: 40px; cursor: pointer; }
        .energy-quadrant-modal.open { display: flex; }
        .energy-quadrant-container { background: #111114; border-radius: 20px; width: 100%; max-width: 900px; max-height: calc(100vh - 80px); padding: 28px; cursor: default; position: relative; box-shadow: 0 30px 80px rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.06); overflow: hidden; display: flex; flex-direction: column; }
        .energy-quadrant-header { text-align: center; margin-bottom: 20px; flex-shrink: 0; position: relative; }
        .eq-close-btn { position: absolute; top: -6px; right: -6px; width: 30px; height: 30px; border-radius: 50%; background: none; border: 1px solid rgba(255,255,255,0.15); color: #666; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .eq-close-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); color: #fff; }
        .energy-quadrant-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.12em; color: #666; }
        .energy-quadrant-subtitle { display: block; font-size: 9px; color: #444; margin-top: 4px; letter-spacing: 0.05em; }
        .energy-quadrant-grid { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 2px; flex: 1; min-height: 0; border-radius: 12px; overflow: hidden; }
        .energy-quadrant { padding: 20px; position: relative; overflow-y: auto; display: flex; flex-direction: column; }
        .eq-rising { background: rgba(255, 179, 71, 0.06); }
        .eq-living { background: rgba(135, 206, 235, 0.06); }
        .eq-fading { background: rgba(221, 160, 221, 0.06); }
        .eq-resting { background: rgba(74, 85, 104, 0.08); }
        .eq-label { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 12px; display: flex; align-items: center; gap: 5px; }
        .eq-label-icon { font-size: 12px; }
        .eq-total { font-size: 8px; font-weight: 500; opacity: 0.5; margin-left: auto; letter-spacing: 0; text-transform: none; }
        .eq-rising .eq-label { color: #ffb347; }
        .eq-living .eq-label { color: #87ceeb; }
        .eq-fading .eq-label { color: #dda0dd; }
        .eq-resting .eq-label { color: #6b7280; }
        .energy-quadrant:hover .eq-label { filter: brightness(1.4); }
        .energy-quadrant:hover .eq-chip { filter: brightness(1.05); }
        .energy-quadrant:hover .eq-chip:hover { filter: brightness(1.15); }
        .eq-rising { border-left: 2px solid rgba(255, 179, 71, 0.35); border-top: 2px solid rgba(255, 179, 71, 0.35); }
        .eq-living { border-right: 2px solid rgba(135, 206, 235, 0.35); border-top: 2px solid rgba(135, 206, 235, 0.35); }
        .eq-fading { border-left: 2px solid rgba(221, 160, 221, 0.35); border-bottom: 2px solid rgba(221, 160, 221, 0.35); }
        .eq-resting { border-right: 2px solid rgba(74, 85, 104, 0.45); border-bottom: 2px solid rgba(74, 85, 104, 0.45); }
        .eq-collectors { display: flex; flex-wrap: wrap; gap: 6px; align-content: flex-start; }
        .eq-chip { padding: 5px 12px; border-radius: 20px; font-size: 9px; font-weight: 600; cursor: pointer; transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1); white-space: nowrap; line-height: 1.2; display: inline-flex; align-items: center; gap: 5px; position: relative; }
        .eq-chip .eq-chip-name { font-weight: 700; }
        .eq-chip .eq-chip-count { font-size: 8px; opacity: 0.7; font-weight: 500; }
        .eq-chip:hover { transform: scale(1.12) translateY(-2px); z-index: 10; }
        .eq-chip:hover .eq-chip-count { opacity: 1; }
        .eq-chip.eq-chip-lg { font-size: 10px; padding: 6px 14px; font-weight: 700; }
        .eq-chip.eq-chip-lg .eq-chip-count { font-size: 9px; }
        .eq-nudge { text-align: center; margin-bottom: 16px; flex-shrink: 0; display: none; }
        .eq-nudge.visible { display: block; }
        .eq-nudge-showcase { display: flex; flex-direction: column; gap: 10px; }
        .eq-nudge-set-row { display: flex; align-items: center; gap: 8px; padding: 7px 14px; border-radius: 14px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.05); cursor: pointer; transition: all 0.2s ease; }
        .eq-nudge-set-row:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.1); }
        .eq-nudge-set-icon { font-size: 13px; flex-shrink: 0; }
        .eq-nudge-set-label { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: #666; flex-shrink: 0; min-width: 50px; }
        .eq-nudge-set-names { display: flex; flex-wrap: wrap; gap: 4px; flex: 1; }
        .eq-nudge-set-name { font-size: 9px; font-weight: 600; color: #bbb; padding: 2px 8px; border-radius: 10px; background: rgba(255,255,255,0.04); letter-spacing: 0.02em; transition: all 0.2s ease; cursor: pointer; }
        .eq-nudge-set-name:hover { color: #fff; background: rgba(255,255,255,0.1); }
        .eq-nudge-set-count { font-size: 8px; color: #444; flex-shrink: 0; margin-left: auto; }
        .eq-nudge-set-row.rising .eq-nudge-set-label { color: #ffb347; }
        .eq-nudge-set-row.living .eq-nudge-set-label { color: #87ceeb; }
        .eq-nudge-set-row.fading .eq-nudge-set-label { color: #dda0dd; }
        .eq-nudge-set-row.resting .eq-nudge-set-label { color: #6b7280; }
        .eq-nudge-set-row.energy-full .eq-nudge-set-label { color: #E8B86D; }
        .eq-nudge-set-row.rising .eq-nudge-set-name { color: #ffb347; }
        .eq-nudge-set-row.living .eq-nudge-set-name { color: #87ceeb; }
        .eq-nudge-set-row.fading .eq-nudge-set-name { color: #dda0dd; }
        .eq-nudge-set-row.resting .eq-nudge-set-name { color: #8b95a5; }
        .eq-nudge-set-row.energy-full .eq-nudge-set-name { color: #E8B86D; }
        .eq-nudge-almost-row { margin-top: 4px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.03); display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; align-items: center; }
        .eq-nudge-almost-tag { font-size: 8px; text-transform: uppercase; letter-spacing: 0.08em; color: #333; width: 100%; text-align: center; margin-bottom: 2px; }
        .eq-nudge-almost-name { font-size: 8px; color: #444; padding: 2px 7px; border-radius: 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.04); cursor: pointer; transition: all 0.2s ease; }
        .eq-nudge-almost-name:hover { color: #888; background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.1); }
        .eq-nudge-almost-miss { font-style: italic; color: #333; }
        @media (max-width: 768px) {
            .energy-quadrant-modal { padding: 20px; }
            .energy-quadrant-container { padding: 20px; border-radius: 14px; }
            .energy-quadrant-grid { gap: 1px; }
            .energy-quadrant { padding: 14px; }
            .eq-chip { font-size: 8px; padding: 3px 8px; }
        }
        @media (max-width: 480px) {
            .energy-quadrant-modal { padding: 12px; }
            .energy-quadrant-container { padding: 14px; }
            .energy-quadrant { padding: 10px; }
        }
        /* Perfect Sets View */
        .perfect-sets-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.98); z-index: 2600; display: none; align-items: flex-start; justify-content: center; overflow-y: auto; padding: 40px 20px 80px; cursor: pointer; opacity: 0; transition: opacity 0.2s ease; }
        .perfect-sets-modal.open { display: flex; opacity: 1; }
        .perfect-sets-content { max-width: 1000px; width: 100%; cursor: default; }
        .perfect-sets-header { text-align: center; margin-bottom: 32px; position: relative; padding-top: 20px; }
        .perfect-sets-title { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.14em; color: #888; }
        .perfect-sets-subtitle { display: block; font-size: 10px; color: #444; margin-top: 6px; letter-spacing: 0.04em; }
        .perfect-sets-close { position: absolute; top: 16px; right: 0; width: 32px; height: 32px; border-radius: 50%; background: none; border: 1px solid rgba(255,255,255,0.12); color: #666; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .perfect-sets-close:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); color: #fff; }
        .perfect-sets-section { margin-bottom: 40px; }
        .perfect-sets-section-header { display: flex; align-items: center; gap: 8px; margin-bottom: 18px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.06); }
        .perfect-sets-section-icon { font-size: 16px; }
        .perfect-sets-section-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; }
        .perfect-sets-section-count { font-size: 9px; color: #555; margin-left: auto; letter-spacing: 0.04em; }
        .ps-section-rising .perfect-sets-section-name { color: #ffb347; }
        .ps-section-living .perfect-sets-section-name { color: #87ceeb; }
        .ps-section-fading .perfect-sets-section-name { color: #dda0dd; }
        .ps-section-resting .perfect-sets-section-name { color: #6b7280; }
        .ps-section-rising .perfect-sets-section-header { border-bottom-color: rgba(255, 179, 71, 0.15); }
        .ps-section-living .perfect-sets-section-header { border-bottom-color: rgba(135, 206, 235, 0.15); }
        .ps-section-fading .perfect-sets-section-header { border-bottom-color: rgba(221, 160, 221, 0.15); }
        .ps-section-resting .perfect-sets-section-header { border-bottom-color: rgba(74, 85, 104, 0.2); }
        .perfect-sets-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; }
        .perfect-set-card { background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 16px; transition: all 0.25s ease; }
        .perfect-set-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.1); transform: translateY(-2px); box-shadow: 0 8px 30px rgba(0,0,0,0.3); }
        .perfect-set-card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .perfect-set-collector { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: #ccc; cursor: pointer; transition: color 0.2s ease; }
        .perfect-set-collector:hover { color: #fff; }
        .perfect-set-count { font-size: 8px; color: #555; letter-spacing: 0.04em; }
        .perfect-set-quad { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 10px; border-radius: 8px; overflow: hidden; }
        .perfect-set-cell { position: relative; aspect-ratio: 1; overflow: hidden; background: rgba(255,255,255,0.02); }
        .perfect-set-cell img { width: 100%; height: 100%; object-fit: cover; display: block; transition: transform 0.3s ease; }
        .perfect-set-cell:hover img { transform: scale(1.08); }
        .perfect-set-cell-id { position: absolute; bottom: 2px; right: 4px; font-size: 8px; font-weight: 600; color: rgba(255,255,255,0.7); text-shadow: 0 1px 3px rgba(0,0,0,0.8); pointer-events: none; }
        .perfect-set-empty { text-align: center; padding: 30px 20px; color: #333; font-size: 10px; letter-spacing: 0.04em; }
        @media (max-width: 768px) {
            .perfect-sets-modal { padding: 20px 12px 60px; }
            .perfect-sets-grid { grid-template-columns: repeat(auto-fill, minmax(170px, 1fr)); gap: 14px; }
            .perfect-set-card { padding: 12px; }
        }
        @media (max-width: 480px) {
            .perfect-sets-grid { grid-template-columns: 1fr 1fr; gap: 10px; }
            .perfect-set-card { padding: 10px; border-radius: 10px; }
        }
        /* Haunted wall view effect for The Lost Cities */
        .wall-view-haunted-effect { position: absolute; inset: 0; pointer-events: none; opacity: 0; transition: opacity 2s ease; z-index: 15; }
        .wall-view-modal.wall-black.haunted-active .wall-view-haunted-effect { opacity: 1; }
        .haunted-ghost { position: absolute; font-size: 40px; opacity: 0; filter: blur(1px); }
        .haunted-ghost:nth-child(1) { top: 20%; left: 10%; animation-delay: 0s; }
        .haunted-ghost:nth-child(2) { top: 60%; right: 15%; animation-delay: 2s; }
        .haunted-ghost:nth-child(3) { top: 40%; left: 50%; animation-delay: 4s; }
        @keyframes ghostFloat { 0%, 100% { opacity: 0; transform: translateY(0) scale(1); } 20% { opacity: 0.15; } 50% { opacity: 0.25; transform: translateY(-20px) scale(1.1); } 80% { opacity: 0.1; } }
        .haunted-mist { position: absolute; bottom: 0; left: 0; right: 0; height: 150px; background: linear-gradient(to top, rgba(100, 100, 150, 0.08), transparent); }
        @keyframes mistPulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        .wall-view-tagline { position: absolute; bottom: 70px; left: 0; right: 0; text-align: center; font-size: 11px; font-style: italic; color: #999; letter-spacing: 0.02em; padding: 0 40px; transition: color 0.5s ease; }
        .wall-view-modal.dark-mode .wall-view-tagline { color: #555; }

        /* Single Piece Framed Overlay */

        /* Collector Feature - Subtle Dark Style */
        .collector-feature { display: none; position: relative; margin: -16px -16px 16px -16px; border-radius: 0 0 16px 16px; overflow: hidden; background: transparent; }
        .collector-feature.visible { display: block; }
        /* Collapsed state - just the label */
        .feature-collapsed-label { display: flex; align-items: center; gap: 8px; padding: 12px 16px; cursor: pointer; }
        .feature-label-icon { color: #c9a227; font-size: 10px; text-shadow: 0 0 8px rgba(201, 162, 39, 0.6); transition: color 0.2s ease; }
        .feature-collapsed-label .feature-label-text { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.5); transition: all 0.2s ease; }
        @media (min-width: 769px) {
            .feature-collapsed-label:hover .feature-label-text { color: var(--yellow); }
            .feature-collapsed-label:hover .feature-label-icon { color: var(--yellow); }
        }
        .feature-expand-arrow { font-size: 8px; color: rgba(255,255,255,0.3); margin-left: auto; transition: transform 0.2s ease; }
        .collector-feature:not(.collapsed) .feature-expand-arrow { transform: rotate(180deg); }
        .collector-feature.collapsed .feature-expanded-content { display: none; }
        .feature-expanded-content { padding: 0 16px 20px; background: rgba(10,10,10,0.5); border-radius: 0 0 12px 12px; }
        .feature-palette-blend { position: absolute; inset: 0; opacity: 0.15; filter: blur(40px); pointer-events: none; }
        .feature-content { position: relative; z-index: 1; }
        /* Collector name - prominent, all caps */
        .feature-collector { font-size: 14px; font-weight: 700; color: #fff; margin-bottom: 14px; letter-spacing: 0.08em; text-transform: uppercase; }
        .feature-collector-label { font-size: 8px; font-weight: 500; color: rgba(255,255,255,0.35); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 4px; }
        /* Horizontal crop of cities */
        .feature-cities { display: flex; gap: 8px; overflow: hidden; transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1); }
        .feature-city-wrapper { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .feature-city { width: 100%; height: auto; aspect-ratio: 9/16; border-radius: 6px; overflow: hidden; position: relative; }
        .feature-city img { width: 100%; height: 100%; object-fit: cover; object-position: center center; }
        .feature-city-number { position: absolute; bottom: 4px; left: 4px; font-size: 8px; font-weight: 700; color: rgba(255,255,255,0.8); background: rgba(0,0,0,0.5); padding: 2px 5px; border-radius: 3px; letter-spacing: 0.05em; opacity: 1; }
        /* Palette info - below each city */
        .feature-city-palette { display: flex; align-items: center; gap: 4px; }
        .feature-palette-name { font-size: 8px; font-weight: 600; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 0.06em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px; }
        .feature-palette-swatches { display: flex; gap: 2px; }
        .feature-swatch { width: 8px; height: 8px; border-radius: 2px; }
        /* Legacy palette row - hidden */
        .feature-palettes { display: none; }

        /* Thank You Builders Section */
        .patrons-section { margin: 8px 0 12px; border-radius: 12px; overflow: hidden; background: linear-gradient(135deg, rgba(255, 215, 0, 0.04) 0%, rgba(255, 180, 50, 0.02) 100%); border: 1px solid rgba(255, 215, 0, 0.08); }
        .patrons-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px; cursor: pointer; transition: background 0.2s ease; }
        .patrons-header:hover { background: rgba(255, 215, 0, 0.05); }
        .patrons-icon { font-size: 12px; opacity: 0.7; }
        .patrons-title { font-size: 10px; font-weight: 500; color: rgba(255, 255, 255, 0.5); letter-spacing: 0.03em; }
        .patrons-arrow { font-size: 8px; color: rgba(255, 255, 255, 0.3); margin-left: auto; transition: transform 0.25s ease; }
        .patrons-section.expanded .patrons-arrow { transform: rotate(180deg); }
        .patrons-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease; }
        .patrons-section.expanded .patrons-content { max-height: 200px; }
        .patrons-message { padding: 12px 16px 14px; font-size: 12px; line-height: 1.7; color: rgba(255, 255, 255, 0.6); }

        /* Founding Patron Pill Style - Cities texture pattern with solid, dashed, dotted lines */
        .collector-pill.founding-patron, .leaderboard-item.founding-patron .leaderboard-name {
            position: relative;
            overflow: hidden;
        }
        .collector-pill.founding-patron::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            pointer-events: none;
            opacity: 0.5;
            background-image: var(--pill-texture);
            background-size: 65px 65px;
        }
        .leaderboard-item.founding-patron {
            background: transparent;
        }
        .leaderboard-item.founding-patron .leaderboard-name::after {
            display: none;
        }

        .grid-content { flex: 1; overflow-y: auto; padding: 20px; -webkit-overflow-scrolling: touch; }
        .grid-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
        .grid-item { aspect-ratio: 9/16; background: var(--bg-card); border-radius: 12px; overflow: hidden; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; position: relative; contain: layout style paint; content-visibility: auto; contain-intrinsic-size: 0 200px; touch-action: manipulation; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; }
        .grid-item:hover { transform: scale(1.03); box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); z-index: 10; }
        .grid-item.selected { outline: 3px solid var(--teal); }
        .grid-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; image-rendering: auto; }
        .grid-item img[src*="width=20"] { image-rendering: pixelated; }
        .grid-item-label { position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(10, 9, 16, 0.9)); font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text); text-align: center; pointer-events: none; transition: opacity 0.2s ease; }
        .grid-panel.hide-numbers .grid-item-label { opacity: 0; }
        /* Desktop: hearts hidden until hover */
        .grid-item-fav { position: absolute; top: 4px; right: 4px; width: 22px; height: 22px; border: none; background: rgba(10, 9, 16, 0.5); color: rgba(255,255,255,0.45); font-size: 10px; cursor: pointer; border-radius: 50%; opacity: 0; transition: all 0.2s ease; z-index: 2; display: flex; align-items: center; justify-content: center; }
        .grid-item:hover .grid-item-fav { opacity: 1; }
        .grid-item-fav:hover { background: rgba(255,255,255,0.85); color: #333; transform: scale(1.1); }
        .grid-item-fav.favorited { opacity: 1; color: var(--spot-text, #000); background: var(--spot-color, var(--yellow)); box-shadow: 0 1px 6px color-mix(in srgb, var(--spot-color, var(--yellow)) 30%, transparent); }
        .grid-item-fav.favorited:hover { background: rgba(255,255,255,0.85); color: #333; }
        /* On favorites page, hide hearts until hover (they're all favorited anyway) */
        .favorites-grid .grid-item-fav { opacity: 0; }
        .favorites-grid .grid-item:hover .grid-item-fav { opacity: 1; }
        /* Mobile: hearts hidden by default, only show favorited */
        @media (pointer: coarse) {
            .grid-item-fav { opacity: 0; width: 26px; height: 26px; font-size: 11px; background: rgba(10, 9, 16, 0.5); color: rgba(255,255,255,0.4); pointer-events: none; }
            .grid-item-fav.favorited { opacity: 1; pointer-events: auto; }
        }
        .grid-item-rank { position: absolute; top: 6px; left: 6px; background: var(--spot-color, var(--yellow)); color: var(--spot-text, #000); font-size: 8px; font-weight: 700; padding: 3px 6px; border-radius: 4px; z-index: 2; letter-spacing: 0.03em; border: none; pointer-events: none; box-shadow: 0 2px 12px color-mix(in srgb, var(--spot-color, var(--yellow)) 50%, transparent); }
        .grid-item-tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg-card); border-radius: 10px; padding: 10px 12px; font-size: 9px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s, transform 0.2s; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.4); margin-bottom: 8px; }
        .grid-item:hover .grid-item-tooltip { opacity: 1; transform: translateX(-50%) translateY(-4px); }
        .grid-item-tooltip-row { display: flex; justify-content: space-between; gap: 16px; margin-bottom: 4px; }
        .grid-item-tooltip-row:last-child { margin-bottom: 0; }
        .grid-item-tooltip-label { color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        .grid-item-tooltip-value { color: var(--text); font-weight: 700; text-transform: uppercase; }
        .grid-item-tooltip-pct { color: var(--text-muted); margin-left: 6px; }
        .grid-item-tooltip-pct.rare { color: var(--orange); }
        .grid-group { margin-bottom: 24px; }
        .grid-group-header { display: flex; align-items: center; gap: 12px; padding: 12px 20px; background: var(--bg-panel); border-radius: 50px; margin-bottom: 12px; cursor: pointer; transition: background 0.3s ease; will-change: background; }
        .grid-group-header:hover { background: var(--bg-card); }
        .grid-group-fav { width: 24px; height: 24px; border: none; background: transparent; color: var(--spot-color, var(--text-muted)); font-size: 16px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; flex-shrink: 0; display: flex; align-items: center; justify-content: center; opacity: 0.4; }
        .grid-group-fav:hover { background: rgba(255,255,255,0.1); color: var(--spot-color, var(--pink)); opacity: 1; }
        .grid-group-fav.favorited { color: var(--spot-color, var(--pink)); opacity: 1; }
        .grid-group-shuffle { width: 24px; height: 24px; border: none; background: transparent; color: var(--text-muted); font-size: 12px; cursor: pointer; border-radius: 50%; transition: all 0.3s ease; flex-shrink: 0; display: flex; align-items: center; justify-content: center; position: relative; overflow: visible; }
        .grid-group-shuffle:hover { background: var(--bg-input); color: var(--teal); }
        .grid-group-inspect { border: none; background: transparent; font-size: 14px; cursor: pointer; padding: 4px 6px; border-radius: 10px; transition: opacity 0.25s ease, background 0.2s ease, filter 0.25s ease; opacity: 0; margin-left: 4px; filter: grayscale(1); }
        .grid-group-header:hover .grid-group-inspect { opacity: 0.5; }
        .grid-group-inspect:hover { opacity: 1 !important; background: var(--bg-input); filter: grayscale(0); }
        @media (max-width: 768px) { .grid-group-inspect { display: none; } }
        @media (pointer: coarse) { .grid-group-inspect { display: none; } }
        .grid-group-color { width: 24px; height: 24px; border-radius: 6px; flex-shrink: 0; opacity: 0.7; transition: opacity 0.25s ease; }
        .grid-group-header:hover .grid-group-color { opacity: 1; }
        .grid-group-swatches { display: flex; gap: 0; height: 24px; border-radius: 4px; overflow: hidden; transition: gap 0.25s ease; will-change: gap; }
        .grid-group-swatches span { width: 3px; height: 24px; border-radius: 0; transition: width 0.25s ease, border-radius 0.25s ease; will-change: width; }
        .grid-group-header:hover .grid-group-swatches { gap: 3px; }
        .grid-group-header:hover .grid-group-swatches span { width: 14px; border-radius: 3px; }
        .grid-group-name { flex: 1; font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text); cursor: pointer; user-select: none; }
        .collector-group .collector-name:hover { color: var(--yellow); }
        .collector-group-wall-btn { background: none; border: 1px solid rgba(232, 184, 109, 0.3); color: rgba(232, 184, 109, 0.6); padding: 4px 12px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 16px; cursor: pointer; transition: all 0.2s ease; opacity: 0; margin-left: auto; }
        .grid-group-header:hover .collector-group-wall-btn { opacity: 1; }
        .collector-group-wall-btn:hover { background: rgba(232, 184, 109, 0.15); border-color: rgba(232, 184, 109, 0.6); color: rgba(232, 184, 109, 1); }
        .collector-rank { font-size: 10px; font-weight: 700; color: var(--text-muted); padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 10px; }
        .collector-rank.rank-1 { background: linear-gradient(135deg, #c9a227, #ffe135); color: #000; }
        .collector-rank.rank-2 { background: linear-gradient(135deg, #8a8a8a, #c0c0c0); color: #000; }
        .collector-rank.rank-3 { background: linear-gradient(135deg, #8b5a2b, #cd7f32); color: #fff; }
        .grid-group-blurb { display: none; font-size: 11px; color: var(--text-dim); font-weight: 400; text-transform: none; letter-spacing: 0.02em; padding: 12px 16px; margin: -8px 0 8px 0; font-style: italic; border-left: 2px solid var(--warm); margin-left: 52px; }
        .grid-group-blurb.visible { display: block; }
        .grid-group-collectors { display: flex; gap: 6px; align-items: center; flex-shrink: 1; overflow: hidden; opacity: 0; transition: opacity 0.25s ease; pointer-events: none; margin-left: auto; }
        .grid-group-count { font-size: 11px; font-weight: 700; color: var(--teal); flex-shrink: 0; margin-left: 8px; }
        .grid-group-header:hover .grid-group-collectors { opacity: 1; pointer-events: auto; }
        .grid-group-collector { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); cursor: pointer; transition: all 0.2s ease; white-space: nowrap; opacity: 0.6; }
        .grid-group-collector:hover { color: var(--yellow); opacity: 1; text-shadow: 0 0 8px rgba(255, 225, 53, 0.4); }
        .grid-group-collectors-more { font-size: 7px; color: var(--text-muted); opacity: 0.5; white-space: nowrap; }
        .grid-group-toggle { color: var(--text-muted); font-size: 14px; transition: transform 0.2s; }
        .grid-group.collapsed .grid-group-toggle { transform: rotate(-90deg); }
        .grid-group.collapsed .grid-group-items { display: none !important; }
        .grid-group-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }
        .grid-pagination { display: flex; justify-content: center; align-items: center; gap: 12px; padding: 20px; flex-shrink: 0; background: var(--bg-panel); border-top: 1px solid var(--border); }
        .grid-pagination button { padding: 12px 20px; background: var(--bg-input); border: none; border-radius: 50px; color: var(--text-dim); font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.3s ease; }
        .grid-pagination button:hover:not(:disabled) { background: var(--bg-card); color: var(--teal); }
        .grid-pagination button:disabled { opacity: 0.4; cursor: not-allowed; }
        .grid-pagination .page-info { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        @media (max-width: 768px) {
            .grid-header { padding: 14px 16px; flex-direction: column; gap: 10px; min-height: auto; align-items: stretch; }
            .grid-clock { top: 4px; left: 8px; font-size: 8px; }
            .grid-brand { position: static; flex-wrap: nowrap; justify-content: flex-start; gap: 8px; align-items: baseline; }
            .grid-brand h1 { font-size: 18px; }
            .grid-controls { order: 2; justify-content: flex-start; }
            .grid-about-link { margin-left: 4px; margin-right: 40px; }
            .grid-about-link img { height: 14px; }
            .grid-artist-logos { gap: 4px; display: flex; }
            .grid-artist-logo { height: 11px; top: 0; }
            .grid-artist-logo.diid-logo { height: 14px; }
            .grid-logo-x { font-size: 7px; top: -1px; }
            .filter-toggle-bar { padding: 8px 12px; }
            .filter-toggle-bar span { font-size: 9px; }
            .grid-filter-bar.open { padding: 10px 12px; }
            .grid-filter-bar select { min-width: 100px; font-size: 10px; padding: 8px 10px; }
            .grid-checkbox { padding: 6px 10px; font-size: 9px; }
            .grid-content { padding: 8px; }
            .grid-items, .grid-group-items { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
            /* Grid size overrides for mobile */
            .grid-items.grid-2-col, .grid-group-items.grid-2-col { grid-template-columns: repeat(2, 1fr) !important; gap: 10px !important; }
            .grid-items.grid-3-col, .grid-group-items.grid-3-col { grid-template-columns: repeat(3, 1fr) !important; gap: 8px !important; }
            .grid-items.grid-4-col, .grid-group-items.grid-4-col { grid-template-columns: repeat(3, 1fr) !important; gap: 6px !important; }
            .grid-items.grid-6-col, .grid-group-items.grid-6-col { grid-template-columns: repeat(4, 1fr) !important; gap: 4px !important; }
            .grid-items.grid-8-col, .grid-group-items.grid-8-col { grid-template-columns: repeat(4, 1fr) !important; gap: 3px !important; }
            .grid-items.grid-11-col, .grid-group-items.grid-11-col { grid-template-columns: repeat(4, 1fr) !important; gap: 3px !important; }
            .grid-items.grid-12-col, .grid-group-items.grid-12-col { grid-template-columns: repeat(4, 1fr) !important; gap: 3px !important; }
            .grid-items.grid-auto, .grid-group-items.grid-auto { grid-template-columns: repeat(4, 1fr) !important; gap: 3px !important; }
            .grid-item { border-radius: 6px; }
            .grid-controls { flex-wrap: nowrap; gap: 4px; justify-content: center; width: 100%; overflow-x: visible; overflow: visible; }
            .grid-mode-btn { padding: 0 10px; font-size: 8px; font-weight: 700; letter-spacing: 0.05em; border-width: 1.5px; height: 34px; min-height: 34px; white-space: nowrap; flex-shrink: 0; border-radius: 50px; display: flex; align-items: center; justify-content: center; width: auto; }
            .grid-mode-btn::after { content: none; }
            .grid-mode-btn[data-emoji="ðŸŽ¨"] { font-size: 0; width: 34px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="ðŸŽ¨"]::after { content: "ðŸŽ¨"; font-size: 15px; line-height: 1; }
            .grid-mode-btn[data-emoji="gradient"] { font-size: 0; width: 34px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="gradient"] .mode-gradient-dot { display: none; }
            .grid-mode-btn[data-emoji="gradient"]::after { content: ""; display: block; width: 16px; height: 16px; border-radius: 50%; background: conic-gradient(#ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b); }
            .grid-mode-btn[data-emoji="ðŸ‘¥"] { font-size: 0; width: 34px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="ðŸ‘¥"]::after { content: "ðŸ‘¥"; font-size: 14px; line-height: 1; }
            .grid-mode-btn[data-emoji="az"] { width: auto; padding: 0 10px; }
            .grid-mode-btn[data-emoji="az"] .mode-az-label { font-size: 11px; }
            .grid-mode-btn .palette-sort-arrow { display: none; }
            .gallery-room-toggle, .grid-size-toggle { width: 44px; height: 44px; font-size: 12px; flex-shrink: 0; }
            /* Palette headers on mobile */
            .grid-group-header { padding: 10px 12px; gap: 6px; flex-wrap: nowrap; }
            .grid-group-name { font-size: 10px; letter-spacing: 0.05em; flex: 1 1 auto; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .grid-group-count { font-size: 9px; padding: 2px 6px; flex-shrink: 0; }
            .grid-group-fav, .grid-group-shuffle { width: 32px; height: 32px; font-size: 14px; flex-shrink: 0; }
            .grid-group-toggle { font-size: 12px; flex-shrink: 0; }
            .grid-group-color { width: 22px; height: 22px; flex-shrink: 0; }
            .grid-group-swatches { display: none; }
            .grid-group-collectors { display: none; }
            .grid-filter-spacer, .grid-supply-tracker, .grid-showing-count { display: none; }
            .grid-stats-bar { padding: 6px 12px; font-size: 8px; gap: 10px; flex-wrap: wrap; justify-content: center; }
            /* Move filter bar to bottom on mobile */
            .grid-panel.open { display: flex; flex-direction: column; }
            .filter-toggle-bar { order: 10; position: fixed; bottom: 0; left: 0; right: 0; margin: 0; border-radius: 0; z-index: 160; background: var(--bg-panel); border-top: 1px solid var(--border); padding: 14px 16px; }
            .grid-filter-bar { order: 11; position: fixed; bottom: 50px; left: 0; right: 0; z-index: 159; border-radius: 0; overflow-y: auto; max-height: 50vh; }
            .grid-filter-bar:has(.multi-select.open) { overflow: visible; }
            .grid-filter-bar.open { display: flex; padding: 16px; }
            .multi-select-dropdown { top: auto; bottom: 100%; margin-top: 0; margin-bottom: 4px; }
            .grid-color-gradient-bar { top: auto; height: 44px; }
            .grid-content { order: 5; padding-bottom: 90px; }
            /* Collector banner: center name above artworks on mobile */
            .collector-banner { flex-direction: column; gap: 6px; padding: 10px 48px; align-items: center; text-align: center; }
            .collector-banner-left { flex-direction: column; align-items: center; gap: 4px; }
            .collector-banner-name { font-size: 13px; letter-spacing: 0.1em; }
            .collector-banner-right { gap: 10px; }
            .collector-banner-phrase { display: none; }
            .collector-banner-nav { width: 28px; height: 28px; font-size: 16px; }
            .collector-banner-prev { left: 10px; }
            .collector-banner-next { right: 40px; }
            .collector-banner-close { right: 10px; }
        }

        /* Compact nav buttons when space is tight */
        @media (max-width: 900px) {
            .grid-controls { gap: 6px; }
            .grid-mode-btn { font-size: 0; width: 36px; height: 36px; padding: 0; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
            .grid-mode-btn::after { content: none; }
            .grid-mode-btn[data-emoji="ðŸŒ"] { font-size: 0; }
            .grid-mode-btn[data-emoji="ðŸŒ"]::after { content: "ðŸŒ"; font-size: 16px; line-height: 1; }
            .grid-mode-btn[data-emoji="â¤ï¸"] { font-size: 0; }
            .grid-mode-btn[data-emoji="â¤ï¸"]::after { content: "â¤ï¸"; font-size: 16px; line-height: 1; }
            .grid-mode-btn[data-emoji="ðŸŽ¨"]::after { content: "ðŸŽ¨"; font-size: 16px; line-height: 1; }
            .grid-mode-btn[data-emoji="gradient"] .mode-gradient-dot { display: none; }
            .grid-mode-btn[data-emoji="gradient"]::after { content: ""; display: block; width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b); }
            .grid-mode-btn[data-emoji="âœï¸"]::after { content: "âœï¸"; font-size: 16px; line-height: 1; }
            .grid-mode-btn[data-emoji="ðŸ‘¥"]::after { content: "ðŸ‘¥"; font-size: 16px; line-height: 1; }
            .grid-mode-btn[data-emoji="az"] { width: auto; padding: 0 10px; font-size: 10px; }
            .grid-mode-btn[data-emoji="az"] .mode-az-label { font-size: 11px; }
            .grid-mode-btn .palette-sort-arrow { display: none; }
        }

        /* Hide progress bar and spacers early so grid filters stay on one line */
        @media (max-width: 1400px) {
            .grid-supply-tracker, .grid-filter-spacer, .grid-showing-count { display: none !important; }
        }

        /* Tighten grid filters at medium widths to prevent wrapping */
        @media (max-width: 1100px) {
            .grid-filter-bar { gap: 8px; padding: 12px 16px; }
            .multi-select { min-width: 90px; }
            .multi-select-btn { padding: 8px 12px; font-size: 10px; }
        }

        /* Condensed sidebar for narrow windows */
        @media (max-width: 1200px) {
            .supply-tracker { display: none; }
            /* Start collapsed but allow toggle to work */
            .filters-section.collapsed .filters-content, .metadata-section.collapsed .metadata-content { display: none; }
            .filters-section.collapsed .toggle-icon, .metadata-section.collapsed .toggle-icon { transform: rotate(-90deg); }
            .filter-grid { gap: 6px; }
            .filter-grid .control-group label { font-size: 8px; }
            .filter-grid select { font-size: 10px; padding: 8px 12px; }
            .filters-toggle, .metadata-toggle { padding: 8px 14px; }
            .filters-toggle span, .metadata-toggle span { font-size: 8px; }
            .section-label { font-size: 8px; margin: 10px 0 6px; }
            hr { margin: 8px 0; }
        }

        /* Show smaller logos when window is narrow */
        @media (max-width: 1200px) {
            .grid-artist-logos { gap: 4px; }
            .grid-artist-logo { height: 12px; }
            .grid-artist-logo.diid-logo { height: 15px; }
            .grid-logo-x { font-size: 7px; }
            /* Show fewer collectors on medium screens */
            .grid-group-collector:nth-child(n+4) { display: none; }
            .grid-group-collectors-more { display: inline; }
        }
        @media (max-width: 900px) {
            /* Show even fewer collectors on smaller screens */
            .grid-group-collector:nth-child(n+3) { display: none; }
        }

        .mobile-menu-toggle { display: none; position: fixed; top: 16px; left: 16px; z-index: 200; width: 40px; height: 40px; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 50%; cursor: pointer; flex-direction: column; align-items: center; justify-content: center; gap: 5px; box-shadow: 0 2px 12px rgba(0,0,0,0.3); }
        .mobile-menu-toggle span { display: block; width: 20px; height: 2px; background: var(--text-dim); border-radius: 1px; transition: all 0.3s; }
        .mobile-menu-toggle.active span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
        .mobile-menu-toggle.active span:nth-child(2) { opacity: 0; }
        .mobile-menu-toggle.active span:nth-child(3) { transform: rotate(-45deg) translate(5px, -5px); }
        .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.8); z-index: 9; opacity: 0; transition: opacity 0.3s; }
        .sidebar-overlay.visible { opacity: 1; }

        /* Legacy mobile (Layout A) - now handled by Layout C below */
        @media (max-width: 768px) {
            .collectors-toggle { display: none; }
        }
        @media (pointer: coarse) {
            .btn { min-height: 48px; }
            .token-nav button { min-width: 48px; min-height: 48px; }
            .gallery-item .item-actions { opacity: 1; background: rgba(10, 9, 16, 0.7); }
            /* Larger touch targets for mobile */
            .heart-btn { width: 48px; height: 48px; font-size: 22px; }
            .icon-btn { width: 44px; height: 44px; font-size: 18px; }
            .grid-item-fav { width: 26px; height: 26px; font-size: 11px; }
            .grid-group-fav, .grid-group-shuffle { width: 32px; height: 32px; font-size: 14px; }
        }

        /* Mobile bottom controls bar - REMOVED */
        .mobile-bottom-bar { display: none !important; }
        @media (max-width: 768px) {
            /* Main content spacing without bottom bar */
            .main-content { padding-bottom: 16px !important; padding-top: 50px !important; }
            .grid-toggle { display: none; }
            /* Grid panel needs bottom padding for filter bar */
            .grid-panel { padding-bottom: 70px; }
            .grid-content { padding-bottom: 100px; }
        }

        /* Pull to refresh indicator */
        .pull-refresh-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: var(--bg-panel);
            border-radius: 0 0 20px 20px;
            color: var(--text-dim);
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
        }
        .pull-refresh-indicator.visible { display: block; }
        .pull-refresh-indicator.pulling { color: var(--teal); }
        .pull-refresh-indicator.refreshing { color: var(--warm); }
        .pull-refresh-indicator .refresh-icon { display: inline-block; margin-right: 6px; transition: transform 0.3s ease; }
        .pull-refresh-indicator.refreshing .refresh-icon { animation: spin 0.6s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* Double-tap heart animation */
        .double-tap-heart {
            position: fixed;
            pointer-events: none;
            font-size: 80px;
            z-index: 1000;
            opacity: 0;
            transform: scale(0);
            transition: none;
            color: #FF6B8A;
            text-shadow: 0 0 30px rgba(255, 107, 138, 0.8), 0 0 60px rgba(255, 107, 138, 0.4);
        }
        .double-tap-heart.show {
            animation: doubleTapHeart 0.8s ease-out forwards;
        }
        @keyframes doubleTapHeart {
            0% { opacity: 0; transform: scale(0) rotate(-15deg); }
            15% { opacity: 1; transform: scale(1.3) rotate(5deg); }
            30% { transform: scale(0.9) rotate(-3deg); }
            45% { transform: scale(1.1) rotate(2deg); }
            60% { transform: scale(1) rotate(0deg); }
            100% { opacity: 0; transform: scale(1.2) rotate(0deg); }
        }

        /* Landscape mode on mobile - condense vertical space */
        @media (max-height: 500px) and (orientation: landscape) {
            .grid-header { padding: 8px 16px; gap: 6px; min-height: auto; }
            .grid-brand h1 { font-size: 16px; }
            .grid-artist-logo { height: 10px; }
            .grid-artist-logo.diid-logo { height: 12px; }
            .grid-controls { gap: 4px; }
            .grid-mode-btn { padding: 0 8px; font-size: 7px; font-weight: 700; letter-spacing: 0.05em; height: 32px; min-height: 32px; border-radius: 50px; display: flex; align-items: center; justify-content: center; width: auto; }
            .grid-mode-btn::after { content: none; }
            .grid-mode-btn[data-emoji="ðŸŽ¨"] { font-size: 0; width: 32px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="ðŸŽ¨"]::after { content: "ðŸŽ¨"; font-size: 14px; line-height: 1; }
            .grid-mode-btn[data-emoji="gradient"] { font-size: 0; width: 32px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="gradient"] .mode-gradient-dot { display: none; }
            .grid-mode-btn[data-emoji="gradient"]::after { content: ""; display: block; width: 14px; height: 14px; border-radius: 50%; background: conic-gradient(#ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b); }
            .grid-mode-btn[data-emoji="ðŸ‘¥"] { font-size: 0; width: 32px; padding: 0; border-radius: 50%; }
            .grid-mode-btn[data-emoji="ðŸ‘¥"]::after { content: "ðŸ‘¥"; font-size: 13px; line-height: 1; }
            .grid-mode-btn[data-emoji="az"] { width: auto; padding: 0 8px; }
            .grid-mode-btn[data-emoji="az"] .mode-az-label { font-size: 10px; }
            .grid-mode-btn .palette-sort-arrow { display: none; }
            .gallery-room-toggle, .grid-size-toggle { width: 32px; height: 32px; font-size: 12px; }
            .filter-toggle-bar { padding: 8px 12px; }
            .grid-filter-bar.open { padding: 8px 12px; }
            .grid-group-header { padding: 6px 10px; }
            .grid-group-name { font-size: 9px; }
            .grid-group-fav, .grid-group-shuffle, .grid-group-color { width: 20px; height: 20px; font-size: 10px; }
            .grid-content { padding: 6px; }
            .grid-items, .grid-group-items { gap: 4px !important; }
            .main-content { padding-top: 50px !important; padding-bottom: 16px !important; }
            .top-nav-fixed { top: 8px; right: 8px; gap: 4px; }
            .view-toggle-btn { width: 28px; height: 28px; min-width: 28px; }
            .mint-toggle { --ch: 14px; --cw: calc(var(--ch) * 3.985); padding: 1px; }
            .preview-image { max-height: calc(100vh - 140px); }
            .pull-refresh-indicator { padding: 8px 16px; font-size: 9px; }
        }

        /* Extra condensed for very short landscape screens */
        @media (max-height: 400px) and (orientation: landscape) {
            .grid-header { padding: 6px 12px; flex-direction: row; align-items: center; }
            .grid-brand { gap: 6px; }
            .grid-brand h1 { font-size: 14px; }
            .grid-artist-logos { display: none; }
            .grid-controls { width: auto; }
            .grid-mode-btn { padding: 5px 10px; font-size: 7px; }
            .filter-toggle-bar { padding: 6px 10px; position: static; }
            .grid-filter-bar { position: relative; max-height: none; }
            .main-content { padding-top: 40px !important; padding-bottom: 16px !important; }
            .preview-image { max-height: calc(100vh - 130px); }
        }

        /* Smooth orientation change transitions */
        body.orientation-changing * {
            transition: all 0.2s ease !important;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* Whimsical animations */
        /* Token ID slot machine bounce */
        @keyframes slotBounce { 0% { transform: translateY(-4px); opacity: 0; } 50% { transform: translateY(1px); } 100% { transform: translateY(0); opacity: 1; } }
        .token-input-wrapper input.digit-change { animation: slotBounce 0.15s ease-out; }

        /* Similar outputs breathing */
        .similar-output { }
        .similar-output:nth-child(2) { animation-delay: 0.5s; }
        .similar-output:nth-child(3) { animation-delay: 1s; }
        .similar-output:nth-child(4) { animation-delay: 1.5s; }
        @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.015); } }

        /* Owner name typewriter */
        .owner-display a { display: inline-block; }
        .owner-display.typing a span { opacity: 0; animation: typeIn 0.03s ease forwards; }
        @keyframes typeIn { to { opacity: 1; } }

        /* Filter glow when active */
        .filter-grid select.has-value { box-shadow: 0 0 0 1px var(--teal), 0 0 8px rgba(0, 229, 204, 0.2); }
        @keyframes filterPulse { 0% { box-shadow: 0 0 0 1px var(--teal), 0 0 8px rgba(0, 229, 204, 0.2); } 50% { box-shadow: 0 0 0 1px var(--teal), 0 0 12px rgba(0, 229, 204, 0.4); } 100% { box-shadow: 0 0 0 1px var(--teal), 0 0 8px rgba(0, 229, 204, 0.2); } }
        .filter-grid select.just-selected { animation: filterPulse 0.4s ease-out; }

        /* Navigation bounce at limits */
        @keyframes bounceBack { 0% { transform: translateX(0); } 30% { transform: translateX(-3px); } 60% { transform: translateX(1px); } 100% { transform: translateX(0); } }
        @keyframes bounceForward { 0% { transform: translateX(0); } 30% { transform: translateX(3px); } 60% { transform: translateX(-1px); } 100% { transform: translateX(0); } }
        .token-nav button.at-limit-prev { animation: bounceBack 0.3s ease-out; }
        .token-nav button.at-limit-next { animation: bounceForward 0.3s ease-out; }

        /* Preview image settle */
        @keyframes imageSettle { 0% { transform: scale(1.008); opacity: 0.8; } 100% { transform: scale(1); opacity: 1; } }
        .preview-image.just-loaded { animation: imageSettle 0.25s ease-out; }

        /* Favorite heart burst */
        @keyframes heartBurst { 0% { transform: scale(1); } 20% { transform: scale(1.3); } 100% { transform: scale(1); } }
        .heart-btn.burst { animation: heartBurst 0.35s ease-out; }
        .heart-btn { position: relative; overflow: visible; }
        .heart-droplet { position: absolute; width: 6px; height: 6px; background: var(--pink); border-radius: 50%; pointer-events: none; opacity: 0.9; }
        .heart-droplet:nth-child(1) { animation: heartDroplet1 0.9s ease-out forwards; }
        .heart-droplet:nth-child(2) { animation: heartDroplet2 0.9s ease-out forwards; }
        .heart-droplet:nth-child(3) { animation: heartDroplet3 1s ease-out forwards; }
        .heart-droplet:nth-child(4) { animation: heartDroplet4 1s ease-out forwards; }
        @keyframes heartDroplet1 { 0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); opacity: 0.9; } 100% { top: -20px; left: 0%; transform: translate(-50%, -50%) scale(0.2); opacity: 0; } }
        @keyframes heartDroplet2 { 0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); opacity: 0.9; } 100% { top: -25px; left: 100%; transform: translate(-50%, -50%) scale(0.2); opacity: 0; } }
        @keyframes heartDroplet3 { 0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8); opacity: 0.8; } 100% { top: -15px; left: 30%; transform: translate(-50%, -50%) scale(0.1); opacity: 0; } }
        @keyframes heartDroplet4 { 0% { top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8); opacity: 0.8; } 100% { top: -18px; left: 70%; transform: translate(-50%, -50%) scale(0.1); opacity: 0; } }

        /* Random button scatter droplets */
        .btn-shuffle { position: relative; overflow: visible; }
        .shuffle-droplet { position: absolute; width: 5px; height: 5px; background: var(--yellow); border-radius: 50%; pointer-events: none; top: 50%; left: 50%; }
        .shuffle-droplet:nth-child(1) { animation: shuffleScatter1 0.7s ease-out forwards; }
        .shuffle-droplet:nth-child(2) { animation: shuffleScatter2 0.7s ease-out forwards; }
        .shuffle-droplet:nth-child(3) { animation: shuffleScatter3 0.8s ease-out forwards; }
        .shuffle-droplet:nth-child(4) { animation: shuffleScatter4 0.8s ease-out forwards; }
        .shuffle-droplet:nth-child(5) { animation: shuffleScatter5 0.75s ease-out forwards; }
        .shuffle-droplet:nth-child(6) { animation: shuffleScatter6 0.75s ease-out forwards; }
        @keyframes shuffleScatter1 { 0% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; } 100% { transform: translate(-40px, -25px) scale(0.2); opacity: 0; } }
        @keyframes shuffleScatter2 { 0% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; } 100% { transform: translate(40px, -20px) scale(0.2); opacity: 0; } }
        @keyframes shuffleScatter3 { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.8; } 100% { transform: translate(-30px, 20px) scale(0.1); opacity: 0; } }
        @keyframes shuffleScatter4 { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.8; } 100% { transform: translate(35px, 15px) scale(0.1); opacity: 0; } }
        @keyframes shuffleScatter5 { 0% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.7; } 100% { transform: translate(-15px, -30px) scale(0.1); opacity: 0; } }
        @keyframes shuffleScatter6 { 0% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.7; } 100% { transform: translate(20px, -28px) scale(0.1); opacity: 0; } }

        /* Side navigation arrows */
        .side-nav-arrow { position: fixed; top: 50%; transform: translateY(-50%); width: 40px; height: 80px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; z-index: 50; color: var(--text-muted); font-size: 20px; }
        .side-nav-arrow:hover { opacity: 0.8 !important; color: var(--text); }
        .side-nav-arrow.left { left: 310px; }
        .side-nav-arrow.right { right: 10px; }
        .main-content:hover ~ .side-nav-arrow, .side-nav-arrow:hover { opacity: 0.3; }
        @media (max-width: 768px) { .side-nav-arrow { display: none; } }

        /* Welcome/loading screen */
        .welcome-screen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-deep); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s ease, visibility 0.8s ease; will-change: opacity; }
        .welcome-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        .welcome-content { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .welcome-greeting { position: absolute; top: 18%; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4em; color: var(--text-muted); opacity: 0.25; cursor: default; transition: opacity 0.3s ease; }
        .welcome-greeting:hover { opacity: 0.5; }
        .welcome-greeting .phrase { display: none; }
        .welcome-greeting:hover .default { display: none; }
        .welcome-greeting:hover .phrase { display: inline; }
        .welcome-animation-container { position: relative; width: 190px; height: 190px; }
        .welcome-blob, .welcome-city { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); height: 154px; width: auto; transition: opacity 1s ease; }
        .welcome-city { height: 190px; opacity: 0; }
        .welcome-screen.show-city .welcome-blob { opacity: 0; }
        .welcome-screen.show-city .welcome-city { opacity: 1; }
        .welcome-progress-container { width: 118px; height: 2px; background: rgba(255,255,255,0.08); border-radius: 1px; overflow: visible; margin-top: 56px; opacity: 0.5; }
        .welcome-progress-bar { height: 100%; width: 0%; background: rgba(255,255,255,0.4); border-radius: 1px; transition: width 0.3s ease-out; transform-origin: left center; }
        @keyframes wiggle {
            0% { transform: translateY(0); }
            12.5% { transform: translateY(-1px); }
            25% { transform: translateY(0); }
            37.5% { transform: translateY(1px); }
            50% { transform: translateY(0); }
            62.5% { transform: translateY(-1px); }
            75% { transform: translateY(0); }
            87.5% { transform: translateY(1px); }
        }
        .welcome-text { font-size: 12px; font-weight: 700; letter-spacing: 0.1em; color: var(--text-muted); opacity: 0.3; margin-top: 47px; }
        .welcome-logos { display: flex; align-items: center; gap: 7px; opacity: 0; animation: welcomeLogosFadeIn 1.5s ease-out forwards; animation-delay: 0.5s; }
        .welcome-logos.welcome-logos-bottom { position: absolute; bottom: 18%; }
        .welcome-logos .artist-logo { height: 14px; opacity: 0.4; cursor: default; }
        .welcome-logos .artist-logo.diid-logo { height: 18px; position: relative; top: 1px; }
        .welcome-logos .logo-x { font-size: 8px; color: var(--text-muted); font-weight: 300; opacity: 0.3; }
        @keyframes welcomeLogosFadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Extra grid sizes */
        .grid-items.grid-11-col, .grid-group-items.grid-11-col { grid-template-columns: repeat(11, 1fr); gap: 3px; }
        .grid-items.grid-12-col, .grid-group-items.grid-12-col { grid-template-columns: repeat(12, 1fr); gap: 2px; }
        .grid-items.grid-1-col, .grid-group-items.grid-1-col { grid-template-columns: 1fr; gap: 20px; max-width: 500px; margin: 0 auto; }
        .grid-1-col .grid-item { aspect-ratio: 9/16; border-radius: 12px; }

        /* Comparison Mode */
        .comparison-mode { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 2500; display: none; flex-direction: column; }
        .comparison-mode.open { display: flex; }
        .comparison-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; border-bottom: 1px solid var(--border); background: var(--bg-panel); }
        .comparison-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        .comparison-actions { display: flex; gap: 8px; align-items: center; }
        .comparison-add-btn { padding: 8px 16px; background: var(--bg-input); border: 1px dashed var(--border); border-radius: 20px; color: var(--text-muted); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; }
        .comparison-add-btn:hover { border-color: var(--warm); color: var(--warm); background: rgba(232, 184, 109, 0.1); }
        .comparison-share-btn { padding: 8px 16px; background: transparent; border: 1px solid var(--border); border-radius: 20px; color: var(--text-muted); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; }
        .comparison-share-btn:hover { border-color: var(--text); color: var(--text); }
        .comparison-close { width: 32px; height: 32px; background: none; border: 1px solid var(--border); border-radius: 50%; color: var(--text-muted); font-size: 16px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .comparison-close:hover { background: var(--text); color: var(--bg-deep); }
        .comparison-content { flex: 1; display: flex; align-items: stretch; overflow: hidden; background: #000; }
        .comparison-item { flex: 1; display: flex; flex-direction: column; border-right: 1px solid rgba(255,255,255,0.1); position: relative; cursor: pointer; transition: flex 0.3s ease; }
        .comparison-item:last-child { border-right: none; }
        .comparison-item.expanded { flex: 2.5; }
        .comparison-item:not(.expanded) { flex: 1; }
        .comparison-item-image { flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; min-height: 0; background: #0a0a0c; }
        .comparison-item-image img { max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 4px; transition: transform 0.3s ease; }
        .comparison-item.expanded .comparison-item-image img { transform: scale(1.02); }
        .comparison-item-info { padding: 12px 16px; background: var(--bg-panel); border-top: 1px solid var(--border); }
        .comparison-item-id { font-size: 12px; font-weight: 700; color: var(--text); margin-bottom: 6px; }
        .comparison-item-traits { display: flex; flex-direction: column; gap: 3px; }
        .comparison-trait { display: flex; justify-content: space-between; font-size: 8px; }
        .comparison-trait-name { color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        .comparison-trait-value { color: var(--text); font-weight: 600; }
        .comparison-trait-value.highlight { color: var(--warm); }
        .comparison-item-remove { position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; background: rgba(0,0,0,0.7); border: none; border-radius: 50%; color: #888; font-size: 14px; cursor: pointer; opacity: 0; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; z-index: 5; }
        .comparison-item:hover .comparison-item-remove { opacity: 1; }
        .comparison-item-remove:hover { background: #fff; color: #000; }
        .comparison-empty { flex: 1; display: flex; align-items: center; justify-content: center; border: 2px dashed rgba(255,255,255,0.15); margin: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; background: rgba(255,255,255,0.02); }
        .comparison-empty:hover { border-color: var(--warm); background: rgba(232, 184, 109, 0.05); }
        .comparison-empty-text { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        /* Comparison mode selection in grid */
        .grid-item.compare-selected { outline: 3px solid var(--warm); outline-offset: 2px; }
        .grid-item .compare-check { position: absolute; top: 6px; left: 6px; width: 20px; height: 20px; background: var(--warm); border-radius: 50%; color: #000; font-size: 12px; font-weight: 700; display: none; align-items: center; justify-content: center; z-index: 3; pointer-events: none; }
        .grid-item.compare-selected .compare-check { display: flex; }

        /* Immersive Gallery Room - simplified, just art */
        .gallery-room { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #08070d; z-index: 10000; display: none; overflow: hidden; }
        .gallery-room.open { display: block; animation: galleryFadeIn 0.5s ease-out; }
        @keyframes galleryFadeIn { from { opacity: 0; } to { opacity: 1; } }
        .gallery-room-ambient { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 50% 120%, rgba(212, 165, 116, 0.05) 0%, transparent 60%); pointer-events: none; }
        .gallery-room-wall { position: absolute; top: 0; left: 0; height: 100%; display: flex; align-items: center; gap: 60px; padding: 0 100px; will-change: transform; transform: translateZ(0); backface-visibility: hidden; }
        .gallery-room-frame { flex-shrink: 0; background: linear-gradient(145deg, #1a1a2e, #12121f); padding: 12px; border-radius: 4px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); transition: transform 0.3s ease; position: relative; cursor: pointer; transform: translateZ(0); }
        .gallery-room-frame img { height: 60vh; width: auto; display: block; border-radius: 2px; }
        @media (max-width: 768px) {
            .gallery-room-wall { gap: 30px; padding: 0 40px; }
            .gallery-room-frame { padding: 8px; }
            .gallery-room-frame img { height: 50vh; }
            .gallery-room-frame:hover { transform: none; }
            .gallery-room-frame:hover img { transform: none; }
        }
        .gallery-room-frame:hover { transform: scale(1.02); }
        .gallery-room-frame:hover img { transform: scale(1.08); }
        .gallery-room-frame-label { display: none; }
        .gallery-room-counter { position: fixed; top: 68px; left: 30px; font-size: 10px; font-weight: 600; color: rgba(255,255,255,0.2); text-transform: uppercase; letter-spacing: 0.15em; opacity: 0; transition: opacity 0.3s ease; }
        .gallery-room:hover .gallery-room-counter { opacity: 1; }
        .gallery-room-close { position: fixed; top: 30px; right: 30px; width: 44px; height: 44px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 50%; color: rgba(255,255,255,0.4); font-size: 20px; cursor: pointer; opacity: 0; transition: all 0.3s ease; z-index: 10001; }
        .gallery-room:hover .gallery-room-close { opacity: 1; cursor: pointer; }
        .gallery-room-close:hover { background: rgba(255,255,255,0.1); color: #fff; }
        /* Standardized back button for full-screen overlay views */
        .view-back-btn { position: absolute; top: 24px; left: 24px; z-index: 10001; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); color: rgba(255,255,255,0.6); padding: 6px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; }
        .view-back-btn:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.95); }
        .frame-mockup .view-back-btn { top: 78px; }
        .frame-mockup:not(.dark-mode) .view-back-btn { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.12); color: rgba(0,0,0,0.5); }
        .frame-mockup:not(.dark-mode) .view-back-btn:hover { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.8); }
        .gallery-room .gallery-room-top-left { position: fixed; top: 24px; left: 30px; z-index: 10001; display: flex; flex-direction: column; align-items: flex-start; gap: 8px; opacity: 0; transition: opacity 0.3s ease; }
        .gallery-room:hover .gallery-room-top-left { opacity: 1; }
        .gallery-room-title { font-size: 28px; font-weight: 700; color: rgba(255,255,255,0.7); font-family: Helvetica, Arial, sans-serif; line-height: 1; }
        .gallery-room .view-back-btn { position: static; opacity: 1; }
        .gallery-room-about { position: fixed; top: 30px; right: 80px; z-index: 10001; opacity: 0; transition: all 0.3s ease; }
        .gallery-room:hover .gallery-room-about { opacity: 0.4; }
        .gallery-room-about:hover { opacity: 0.8 !important; }
        .gallery-room-about img { height: 20px; width: auto; filter: brightness(0) invert(1); transition: all 0.3s ease; }
        .gallery-room-about:hover img { filter: brightness(0) invert(1) drop-shadow(0 0 4px rgba(255,255,255,0.3)); }
        .gallery-room-info { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.2); font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.2em; opacity: 0; transition: opacity 0.3s ease; }
        .gallery-room:hover .gallery-room-info { opacity: 1; }
        .gallery-room-controls { display: none; }
        /* More controls menu */
        .more-controls-wrapper { position: relative; }
        .more-controls-toggle { width: 32px; height: 32px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 50%; color: var(--text-muted); font-size: 18px; font-weight: 300; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .more-controls-toggle:hover { background: var(--bg-card); color: var(--text); border-color: var(--text-muted); }
        .more-controls-toggle.open { transform: rotate(45deg); background: var(--warm); color: #000; border-color: var(--warm); }
        .more-controls-menu { position: absolute; top: calc(100% + 8px); right: 0; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; padding: 8px; display: none; flex-direction: column; gap: 4px; min-width: 140px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index: 1000; }
        .more-controls-menu.open { display: flex; }
        .more-controls-menu button { width: 100%; padding: 10px 14px; background: transparent; border: none; border-radius: 8px; color: var(--text-muted); font-size: 11px; font-weight: 600; text-align: left; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 8px; }
        .more-controls-menu button:hover { background: var(--bg-input); color: var(--text); }
        .gallery-room-toggle, .compare-mode-toggle, .heatmap-toggle, .grid-originals-btn { font-size: 12px; }
        .heatmap-toggle.active { color: var(--warm); }
        /* Leave Your Mark */
        .playground-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #0a0910; z-index: 2000; display: none; flex-direction: column; }
        .playground-overlay.open { display: flex; }
        .playground-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; background: var(--bg-panel); border-bottom: 1px solid var(--border); flex-shrink: 0; flex-wrap: wrap; gap: 12px; }
        .playground-header-left { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .playground-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        .playground-palette-name { font-size: 10px; font-weight: 600; color: var(--text); padding: 4px 10px; background: var(--bg-input); border-radius: 12px; cursor: pointer; transition: all 0.2s ease; border: 1px solid var(--border); }
        .playground-palette-name:hover { border-color: var(--text-muted); }
        .playground-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .playground-btn { padding: 8px 14px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 20px; color: var(--text-muted); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s ease; }
        .playground-btn:hover { border-color: var(--text-muted); color: var(--text); }
        .playground-btn.active { background: var(--warm); border-color: var(--warm); color: #000; }
        .playground-close { width: 32px; height: 32px; background: none; border: 1px solid var(--border); border-radius: 50%; color: var(--text-muted); font-size: 16px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .playground-close:hover { background: var(--text); color: var(--bg-deep); }
        .playground-canvas-wrap { flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; overflow: hidden; }
        .playground-canvas { cursor: crosshair; max-width: 100%; max-height: 100%; }
        .playground-toolbar { display: flex; justify-content: center; gap: 12px; padding: 16px; background: var(--bg-panel); border-top: 1px solid var(--border); flex-shrink: 0; flex-wrap: wrap; align-items: center; }
        .playground-tool { width: 40px; height: 40px; background: var(--bg-input); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .playground-tool:hover { border-color: var(--text-muted); }
        .playground-tool.active { border-color: var(--warm); background: rgba(232, 184, 109, 0.15); }
        .playground-tool svg { width: 20px; height: 20px; stroke: var(--text-muted); fill: none; stroke-width: 2; stroke-linecap: round; }
        .playground-tool.active svg { stroke: var(--warm); }
        .playground-size { display: flex; gap: 6px; align-items: center; margin-left: 16px; padding-left: 16px; border-left: 1px solid var(--border); }
        .playground-size-btn { width: 28px; height: 28px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .playground-size-btn:hover { border-color: var(--text-muted); }
        .playground-size-btn.active { border-color: var(--warm); background: rgba(232, 184, 109, 0.15); }
        .playground-size-dot { border-radius: 50%; background: var(--text-muted); }
        .playground-size-btn.active .playground-size-dot { background: var(--warm); }
        /* Color picker (palette colors) */
        .playground-colors { display: flex; gap: 6px; align-items: center; margin-left: 16px; padding-left: 16px; border-left: 1px solid var(--border); }
        .playground-color-btn { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
        .playground-color-btn:hover { transform: scale(1.1); }
        .playground-color-btn.active { border-color: #fff; box-shadow: 0 0 0 2px var(--warm), 0 2px 8px rgba(0,0,0,0.4); }
        .playground-color-label { font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-right: 4px; }
        /* Multi-color toggle */
        .playground-multicolor { margin-left: 8px; }
        .playground-multicolor-btn { display: flex; align-items: center; gap: 4px; padding: 6px 10px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 9px; font-weight: 600; color: var(--text-muted); transition: all 0.2s ease; }
        .playground-multicolor-btn:hover { border-color: var(--text-muted); color: var(--text); }
        .playground-multicolor-btn.active { border-color: var(--warm); background: rgba(232, 184, 109, 0.15); color: var(--warm); }
        .multicolor-icon { font-size: 12px; }
        .multicolor-label { text-transform: uppercase; letter-spacing: 0.05em; }
        /* Aspect ratio picker */
        .playground-ratio { display: flex; gap: 6px; align-items: center; margin-left: 16px; padding-left: 16px; border-left: 1px solid var(--border); }
        .playground-ratio-btn { padding: 6px 10px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 9px; font-weight: 600; color: var(--text-muted); transition: all 0.2s ease; }
        .playground-ratio-btn:hover { border-color: var(--text-muted); color: var(--text); }
        .playground-ratio-btn.active { border-color: var(--warm); background: rgba(232, 184, 109, 0.15); color: var(--warm); }
        /* Download dropdown */
        .playground-download-wrap { position: relative; }
        .playground-download-menu { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); background: var(--bg-panel); border: 1px solid var(--border); border-radius: 8px; padding: 8px 0; margin-top: 8px; min-width: 160px; display: none; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .playground-download-menu.open { display: block; }
        .playground-download-option { padding: 8px 16px; font-size: 10px; color: var(--text-muted); cursor: pointer; transition: all 0.15s ease; }
        .playground-download-option:hover { background: var(--bg-input); color: var(--text); }
        /* Sidebar Footer - Clean icon row */
        .sidebar-footer { position: fixed; bottom: 0; left: 0; width: 300px; padding: 10px 20px 14px; background: linear-gradient(to top, var(--bg-panel) 80%, transparent); z-index: 150; box-sizing: border-box; pointer-events: auto; }
        @media (max-width: 768px) { .sidebar-footer { display: none; } .sidebar.open .sidebar-footer { display: block; } }
        .sidebar-footer-row { display: flex; justify-content: center; gap: 8px; }
        .sidebar-footer-btn { width: 32px; height: 32px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 50%; color: var(--text-muted); font-size: 13px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; position: relative; }
        .sidebar-footer-btn:hover { background: var(--bg-card); color: var(--text); border-color: var(--text-muted); }
        .footer-icon { font-size: 14px; }
        /* Transform (i) button to X when about modal is open */
        body.about-open #aboutTrigger { opacity: 0.9; }
        .fav-badge { position: absolute; top: -4px; right: -4px; background: var(--warm); color: #000; font-size: 8px; font-weight: 700; padding: 2px 5px; border-radius: 8px; min-width: 14px; text-align: center; }
        .fav-badge:empty, .fav-badge[data-count="0"] { display: none; }

        /* Collection Planner Modal */
        .collection-planner-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 9, 16, 0.9); z-index: 2500; display: none; align-items: center; justify-content: center; }
        .collection-planner-modal.open { display: flex; }
        .collection-planner-content { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 16px; padding: 24px; max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .collection-planner-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .collection-planner-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        .collection-planner-close { width: 28px; height: 28px; background: none; border: 1px solid var(--border); border-radius: 50%; color: var(--text-muted); font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .collection-planner-close:hover { background: var(--text); color: var(--bg-deep); }
        .collection-set { margin-bottom: 16px; padding: 12px; background: var(--bg-input); border-radius: 10px; }
        .collection-set:last-of-type { margin-bottom: 0; }
        .collection-set-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .collection-set-name { font-size: 11px; font-weight: 700; color: var(--text); }
        .collection-set-status { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; padding: 4px 10px; border-radius: 12px; }
        .collection-set-status.complete { background: rgba(46, 204, 113, 0.2); color: #2ecc71; }
        .collection-set-status.partial { background: rgba(241, 196, 15, 0.2); color: #f1c40f; }
        .collection-set-status.empty { background: rgba(149, 165, 166, 0.2); color: #95a5a6; }
        .collection-set-desc { font-size: 10px; color: var(--text-muted); margin-bottom: 10px; }
        .collection-set-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
        .collection-set-slot { aspect-ratio: 9/16; border-radius: 6px; background: var(--bg-deep); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-muted); overflow: hidden; }
        .collection-set-slot.filled { cursor: pointer; }
        .collection-set-slot.filled img { width: 100%; height: 100%; object-fit: cover; }
        .collection-set-slot.empty { border: 1px dashed var(--border); }
        .collection-promo { margin-top: 16px; padding: 12px; background: linear-gradient(135deg, rgba(232, 184, 109, 0.15) 0%, rgba(241, 196, 15, 0.1) 100%); border: 1px solid rgba(232, 184, 109, 0.3); border-radius: 10px; }
        .collection-promo-text { font-size: 10px; font-weight: 600; color: var(--warm); text-align: center; line-height: 1.4; }
        .collection-promo-link { display: block; margin-top: 10px; text-align: center; }
        .collection-promo-link a { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--warm); text-decoration: none; transition: opacity 0.2s ease; }
        .collection-promo-link a:hover { opacity: 0.7; }
        /* Keyboard hint overlay */
        .keyboard-hint-overlay { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(20, 19, 28, 0.9); border: 1px solid var(--border); border-radius: 8px; padding: 8px 16px; font-size: 11px; color: var(--text-muted); z-index: 500; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
        .keyboard-hint-overlay.visible { opacity: 1; }
        .keyboard-hint-overlay kbd { background: var(--bg-input); padding: 2px 6px; border-radius: 4px; font-family: inherit; font-weight: 700; color: var(--text); margin-left: 6px; }

        /* Drift Mode - Meditative Screensaver Gallery */
        .drift-mode { position: fixed; inset: 0; z-index: 10000; overflow: hidden; cursor: none; opacity: 0; visibility: hidden; transition: opacity 0.8s ease, visibility 0.8s ease; }
        .drift-mode.active { opacity: 1; visibility: visible; }
        .drift-mode.light { background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 50%, #f0f0f0 100%); }
        .drift-mode.dark { background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 50%, #151515 100%); }
        .drift-track { display: flex; gap: 60px; position: absolute; top: 50%; transform: translateY(-50%); padding: 0 100px; will-change: transform; }
        .drift-item { flex-shrink: 0; transition: transform 0.4s ease; cursor: pointer; }
        .drift-item:hover { transform: scale(1.08); }
        .drift-frame { background: #fff; padding: 12px 12px 40px 12px; box-shadow: 0 8px 40px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1); }
        .drift-mode.dark .drift-frame { background: #1a1a1a; box-shadow: 0 8px 40px rgba(0,0,0,0.4), 0 0 1px rgba(255,255,255,0.1); }
        .drift-frame img { display: block; width: 280px; height: auto; aspect-ratio: 1; object-fit: cover; }
        .drift-label { font-size: 9px; font-weight: 500; letter-spacing: 0.1em; text-transform: uppercase; color: #999; margin-top: 12px; text-align: center; font-family: Helvetica, Arial, sans-serif; }
        .drift-mode.dark .drift-label { color: #555; }
        .drift-close { position: fixed; top: 30px; right: 30px; background: none; border: none; color: #666; font-size: 24px; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; z-index: 10001; padding: 10px; }
        .drift-mode:hover .drift-close { opacity: 0.5; cursor: pointer; }
        .drift-close:hover { opacity: 1 !important; }
        .drift-mode.light .drift-close { color: #333; }
        .drift-toggle { position: fixed; bottom: 30px; right: 30px; background: none; border: none; color: #666; font-size: 10px; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; z-index: 10001; padding: 10px; text-transform: uppercase; letter-spacing: 0.1em; }
        .drift-mode:hover .drift-toggle { opacity: 0.5; }
        .drift-toggle:hover { opacity: 1 !important; }
        .drift-hint { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #444; opacity: 0; transition: opacity 0.3s ease; z-index: 10001; letter-spacing: 0.05em; pointer-events: none; }
        .drift-mode:hover .drift-hint { opacity: 0.4; }
        .drift-mode.light .drift-hint { color: #999; }

        /* ===== Mobile Redesign: Art-first with bottom toolbar + action sheet ===== */

        /* Mobile bottom bar - hidden on desktop */
        .mobile-bottom-bar { display: none; }
        .mobile-sheet-overlay { display: none; }
        .mobile-sheet { display: none; }

        @media (max-width: 768px) {
            body { overflow: hidden !important; }
            /* Sidebar hidden on mobile */
            .mobile-menu-toggle { display: none !important; }
            .sidebar-overlay { display: none !important; }
            .sidebar { display: none !important; }
            .sidebar-footer { display: none !important; }

            /* Art fills the screen above the bottom bar with generous negative space */
            .main-content {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 52px !important;
                width: 100% !important;
                padding: 20px 24px !important;
                display: flex !important;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                pointer-events: auto;
                box-sizing: border-box;
            }

            .frame-container {
                width: auto !important;
                max-width: 85% !important;
                flex: 0 1 auto !important;
                min-height: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 12px;
            }

            .preview-image {
                max-height: calc(100vh - 180px) !important;
                max-width: 100% !important;
                width: auto;
                height: auto;
                object-fit: contain;
                border-radius: 8px;
            }

            /* Hide bottom info - token shown in bottom bar */
            .bottom-info { display: none !important; }

            /* Hide side nav arrows - use bottom bar instead */
            .side-nav-arrow { display: none !important; }

            /* Hide grid toggle - it's in the sheet */
            .grid-toggle { display: none !important; }

            /* Hide efdot fixed shop icon */
            .efdot-shop-fixed { display: none !important; }

            /* Top nav: keep collect button, shrink */
            .top-nav-fixed { top: 8px; right: 8px; gap: 4px; }
            .view-toggle-btn { width: 28px; height: 28px; min-width: 28px; }
            .mint-toggle { --ch: 16px; --cw: calc(var(--ch) * 3.985); padding: 2px; }

            /* Collectors/Gallery panels still slide from right, full width */
            .gallery-panel, .collectors-panel { width: 100%; max-width: 100vw; right: 0; left: 0; transform: translateX(100%); padding: 20px 16px; box-sizing: border-box; }
            .gallery-panel.open, .collectors-panel.open { transform: translateX(0); }
            .collectors-panel::before { display: none; }
            body.collectors-open .top-nav-fixed { display: none; }

            .status-message { bottom: 64px; }
            .keyboard-hints { display: none; }

            /* ===== Mobile Bottom Bar ===== */
            .mobile-bottom-bar {
                display: flex !important;
                position: fixed;
                bottom: 0; left: 0; right: 0;
                height: 52px;
                background: var(--bg-panel);
                border-top: 1px solid var(--border);
                z-index: 500;
                align-items: center;
                justify-content: space-between;
                padding: 0 12px;
                -webkit-tap-highlight-color: transparent;
            }
            .mob-nav-group {
                display: flex;
                align-items: center;
                gap: 2px;
            }
            .mob-btn {
                background: none;
                border: none;
                color: var(--text-dim);
                font-size: 18px;
                width: 42px;
                height: 42px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                border-radius: 50%;
                transition: all 0.15s ease;
                -webkit-tap-highlight-color: transparent;
            }
            .mob-btn:active { background: var(--bg-input); color: var(--text); transform: scale(0.92); }
            .mob-token {
                font-size: 13px;
                font-weight: 700;
                color: var(--warm);
                letter-spacing: 0.04em;
                min-width: 48px;
                text-align: center;
                cursor: pointer;
            }
            .mob-actions {
                display: flex;
                align-items: center;
                gap: 0;
            }
            .mob-fav { font-size: 20px; }
            .mob-fav.active { color: #ff6b6b; }
            .mob-more-btn {
                font-size: 22px;
                font-weight: 700;
                color: var(--text-muted);
            }

            /* ===== Mobile Action Sheet ===== */
            .mobile-sheet-overlay {
                display: block;
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.6);
                z-index: 600;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.25s ease;
            }
            .mobile-sheet-overlay.open { opacity: 1; pointer-events: auto; }

            .mobile-sheet {
                display: block;
                position: fixed;
                bottom: 0; left: 0; right: 0;
                background: var(--bg-panel);
                border-radius: 16px 16px 0 0;
                z-index: 650;
                transform: translateY(100%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                padding: 8px 16px 24px;
                max-height: 70vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            .mobile-sheet.open { transform: translateY(0); }

            .mobile-sheet-handle {
                width: 36px;
                height: 4px;
                background: var(--border);
                border-radius: 2px;
                margin: 4px auto 16px;
            }

            .mobile-sheet-section { margin-bottom: 16px; }
            .mobile-sheet-section-label {
                font-size: 8px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 0.12em;
                color: var(--text-muted);
                margin-bottom: 8px;
                padding-left: 4px;
            }
            .mobile-sheet-row {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }
            .mob-menu-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: 12px 4px;
                background: var(--bg-input);
                border: 1px solid var(--border);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.15s ease;
                -webkit-tap-highlight-color: transparent;
            }
            .mob-menu-btn:active { background: var(--bg-card); transform: scale(0.95); border-color: var(--warm); }
            .mob-menu-icon { font-size: 18px; color: var(--text); }
            .mob-menu-label { font-size: 9px; font-weight: 600; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.04em; }

            .mobile-sheet-owner {
                font-size: 10px;
                color: var(--text-muted);
                text-align: center;
                padding: 8px 0;
                border-top: 1px solid var(--border);
                margin-top: 8px;
            }
            .mobile-sheet-owner:empty { display: none; }

            .mobile-sheet-footer {
                text-align: center;
                padding: 12px 0 4px;
                font-size: 9px;
                color: var(--text-muted);
                opacity: 0.4;
            }
            .mobile-sheet-footer a { color: var(--text-muted); text-decoration: none; }
            .mobile-sheet-footer span { margin: 0 4px; }
        }

        @media (max-width: 480px) {
            .preview-image { max-height: calc(100vh - 160px) !important; }
            .frame-container { max-width: 82% !important; }
            .mob-menu-btn { padding: 10px 2px; }
            .mob-menu-icon { font-size: 16px; }
        }

        /* Second mobile bottom bar (art view nav) - yellow/black theme */
        @media (max-width: 768px) {
            .mobile-bottom-bar#mobileBottomBar2 {
                display: flex !important;
                padding: 0 20px;
                height: 56px;
                background: #111;
                border-top: 1px solid rgba(201, 162, 39, 0.2);
                justify-content: space-between;
                align-items: center;
            }
            .mobile-bottom-bar#mobileBottomBar2 button {
                background: none;
                border: none;
                color: #c9a227;
                font-size: 20px;
                width: 48px;
                height: 48px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                border-radius: 50%;
                transition: all 0.15s ease;
                -webkit-tap-highlight-color: transparent;
            }
            .mobile-bottom-bar#mobileBottomBar2 button:active {
                background: rgba(201, 162, 39, 0.15);
                transform: scale(0.92);
            }
            .mobile-bottom-bar#mobileBottomBar2 .mobile-heart-btn {
                font-size: 24px;
                color: #c9a227;
                opacity: 0.45;
                transition: opacity 0.2s ease, color 0.2s ease;
            }
            .mobile-bottom-bar#mobileBottomBar2 .mobile-heart-btn.favorited {
                color: #ff6b6b;
                opacity: 1;
            }
        }

        /* Print form responsive */
        @media (max-width: 900px) {
            .print-inquiry-content { max-width: 360px; }
            .print-inquiry-mini-inner img { max-height: 160px; }
        }
        @media (max-width: 768px) {
            .print-inquiry-modal { align-items: stretch; justify-content: stretch; }
            .print-inquiry-content {
                border-radius: 0;
                max-width: 100%;
                width: 100%;
                max-height: 100%;
                height: 100%;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 20px 16px;
            }
            .print-inquiry-frame-preview { padding: 16px 12px 10px; margin-bottom: 12px; }
            .print-inquiry-mini-inner img { max-height: 140px; }
            .print-inquiry-sizes { gap: 4px; }
            .print-inquiry-size-option { padding: 6px 2px; }
            .print-inquiry-size-option .size-dims { font-size: 11px; }
            .print-inquiry-size-option .size-price { font-size: 10px; }
        }
        @media (max-width: 380px) {
            .print-inquiry-mini-inner img { max-height: 120px; }
            .print-inquiry-frame-color { width: 18px; height: 18px; }
        }

    </style>
</head>
<body class="grid-open">
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <div class="welcome-animation-container">
                <img src="loading-goo.gif" alt="Loading" class="welcome-city">
            </div>
            <div class="welcome-text">Cities</div>
            <div class="welcome-progress-container">
                <div class="welcome-progress-bar" id="welcomeProgressBar"></div>
            </div>
        </div>
        <div class="welcome-logos welcome-logos-bottom">
            <img src="ef-logo.png" alt="Efdot" class="artist-logo ef-logo">
            <span class="logo-x">Ã—</span>
            <img src="diid-logo.png" alt="Diid" class="artist-logo diid-logo">
        </div>
    </div>

    <div class="loading-bar-container" id="loadingBarContainer">
        <div class="loading-bar" id="loadingBar"></div>
    </div>

    <button class="mobile-menu-toggle" id="mobileMenuToggle">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <div class="bg-bubbles">
        <div class="bubble bubble-1"></div>
        <div class="bubble bubble-2"></div>
        <div class="bubble bubble-3"></div>
    </div>

    <div class="app-wrapper">
    <div class="sidebar" id="sidebar">
        <h1 id="sidebarTitle">Cities</h1>
        <div class="artist-logos">
            <a href="https://www.efdotstudio.com" target="_blank" title="Efdot Studio"><img src="ef-logo.png" alt="Efdot" class="artist-logo ef-logo"></a>
            <span class="logo-x">Ã—</span>
            <a href="https://diid.art" target="_blank" title="Diid"><img src="diid-logo.png" alt="Diid" class="artist-logo diid-logo"></a>
            <a href="#" class="sidebar-about-link" id="aboutTrigger" title="About" onclick="window.toggleAboutModal ? window.toggleAboutModal() : (window.openAboutModal && window.openAboutModal()); return false;"><img src="info-icon.png" alt="About"></a>
        </div>

        <div class="control-group">
            <div class="token-nav">
                <button id="prevToken" aria-label="Previous city">&larr;</button>
                <div class="token-input-wrapper">
                    <span class="token-hash">#</span>
                    <input type="number" id="tokenId" value="0" min="0" max="317" placeholder="0-317" aria-label="City token number (0-317)">
                </div>
                <button id="nextToken" aria-label="Next city">&rarr;</button>
            </div>
            <button class="back-to-previous" id="backToPrevious" style="display: none;" title="Back to previous city">â†© Back</button>
        </div>
        <div class="owner-display" id="ownerDisplay"></div>
        <div class="listing-info" id="listingInfo"></div>
        <div class="owner-actions" id="ownerActions" style="margin-top: 4px; margin-bottom: 6px;">
            <a href="#" target="_blank" class="marketplace-link offer-btn" id="makeOfferBtn">MAKE OFFER</a>
        </div>

        <!-- Neighbors - Same Palette Cities -->
        <div class="same-palette-section collapsed" id="samePaletteSection" style="display: none;">
            <div class="same-palette-label" id="samePaletteLabel">
                <span class="expand-icon">â–¶</span>
                <span>Neighbors</span>
            </div>
            <div class="same-palette-grid" id="samePaletteGrid"></div>
            <div class="same-palette-owners" id="samePaletteOwners" style="display: none;"></div>
        </div>

        <!-- Pairs Well With - complementary palettes (collapsed by default) -->
        <div class="pairs-well-section collapsed" id="pairsWellSection" style="display: none;">
            <div class="pairs-well-label" id="pairsWellLabel">
                <span class="expand-icon">â–¶</span>
                <span>Pairs well with</span>
            </div>
            <div class="pairs-well-grid" id="pairsWellGrid"></div>
        </div>

        <button class="sidebar-inspect-btn" id="inspectPalette">INSPECT PALETTE</button>

        <div class="metadata-section collapsed" id="metadataSection">
            <div class="metadata-toggle" id="metadataToggle">
                <span>METADATA</span>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="metadata-content">
                <div id="traitsDisplay" class="traits-display">LOADING...</div>
            </div>
        </div>

        <div class="filters-section collapsed" id="filtersSection">
            <div class="filters-toggle" id="filtersToggle">
                <span>FILTERS</span>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="filters-content">
                <div class="filter-grid">
                    <div class="control-group">
                        <label>TIME</label>
                        <select id="filterTime"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>ENERGY</label>
                        <select id="filterEnergy"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>PALETTE</label>
                        <select id="filterPalette"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>BOUNDS</label>
                        <select id="filterBounds"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>TRAFFIC</label>
                        <select id="filterTraffic"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>ZOOM</label>
                        <select id="filterZoom"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>LINE</label>
                        <select id="filterLine"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>RENDER</label>
                        <select id="filterRender"><option value="">ANY</option></select>
                    </div>
                    <div class="control-group">
                        <label>WATER</label>
                        <select id="filterWater"><option value="">ANY</option></select>
                    </div>
                </div>
                <div class="set-filter-row">
                    <button id="setFilterBtn" class="set-filter-btn">SET FILTER</button>
                </div>
                <div class="time-color-picker" id="timeColorPicker">
                    <label class="time-color-label">COLOR AS TIME</label>
                    <div class="time-color-gradient" id="timeColorGradient">
                        <div class="time-color-marker" id="timeColorMarker"></div>
                    </div>
                    <div class="time-color-labels">
                        <span>Night</span>
                        <span>Dawn</span>
                        <span>Morning</span>
                        <span>Daylight</span>
                        <span>Afternoon</span>
                        <span>Dusk</span>
                        <span>Evening</span>
                    </div>
                </div>
                <div class="filter-clear-link">
                    <span id="clearFilters">Clear filters</span>
                </div>
            </div>
        </div>
        <div class="match-count" id="matchCount">LOADING...</div>

        <hr>
        <div class="action-bar">
            <button class="btn btn-fullscreen action-bar-main" id="fullscreenBtn" aria-label="Enter fullscreen mode">FULLSCREEN</button>
            <button class="btn btn-shuffle" id="exploreRandom" aria-label="Random city">âŸ³ RANDOM</button>
            <button class="icon-btn heart-btn" id="saveFavorite" title="Save to Favorites" aria-label="Save to favorites"><span class="heart-red" aria-hidden="true">â¤ï¸</span><span class="heart-blue" aria-hidden="true">ðŸ’™</span></button>
        </div>

        <div class="icon-buttons-row">
            <button class="icon-btn" id="copyLink" title="Copy Link" aria-label="Copy link to clipboard">ðŸ”—</button>
            <a href="#" id="iconOpenSea" target="_blank" class="icon-btn opensea-icon" title="View on OpenSea">â›µ</a>
            <button class="icon-btn" id="frameViewBtn" title="View framed mockup" aria-label="View framed on wall">â–£</button>
            <button class="icon-btn" id="downloadPng" title="Download for Stories (1080x1920)" aria-label="Download JPG for Instagram/X Stories">â†“</button>
            <button class="icon-btn" id="sidebarOrderPrint" title="Order a print" aria-label="Order a print"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9V2h12v7"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg></button>
        </div>
        <div class="saved-note" id="savedNote">Saved to your favorites<span class="saved-dots"></span></div>

        <div class="mint-countdown" id="mintCountdown">
            <span class="countdown-label">CLOSES</span>
            <span class="countdown-timer" id="countdownTimer"></span>
        </div>

        <a href="https://www.artblocks.io/collection/0x7c78f67700e700b4005c8a3d920a1a99e6004800-0" target="_blank" class="supply-tracker" id="supplyTracker" onclick="return confirm('You are about to leave Cities Explorer and visit Art Blocks. Continue?');">
            <div class="supply-bar">
                <div class="supply-fill" id="supplyFill" style="width: 0%;"></div>
                <div class="supply-label"><span id="mintedCount"></span>&nbsp;COLLECTED</div>
            </div>
            <span class="mint-text">VIEW ON ARTBLOCKS</span>
        </a>

        <!-- Sidebar Footer - Clean layout -->
        <div class="sidebar-footer">
            <div class="sidebar-footer-row">
                <button class="sidebar-footer-btn" id="sidebarCollectorsBtn" title="Collectors">
                    <span class="footer-icon">ðŸ‘¥</span>
                </button>
                <button class="sidebar-footer-btn" id="sidebarOriginalsBtn" title="Origins Timeline">
                    <span class="footer-icon">â—«</span>
                </button>
                <button class="sidebar-footer-btn" id="toggleGallery" title="Favorites">
                    <span class="footer-icon">â™¡</span>
                    <span class="fav-badge" id="favCount">0</span>
                </button>
            </div>
        </div>
        <script>
        // Define openAboutModal early so onclick handlers work
        window.openAboutModal = window.openAboutModal || function() {
            var modal = document.getElementById('aboutModal');
            if (modal) modal.classList.add('open');
        };
        </script>

        <!-- Keyboard Hints (hidden by default) -->
        <div class="keyboard-hints" id="keyboardHints" style="display: none;">
            <div class="hint-row"><span>SAVE</span><kbd>S</kbd></div>
            <div class="hint-row"><span>DOWNLOAD</span><kbd>D</kbd></div>
            <div class="hint-row"><span>TWEET</span><kbd>T</kbd></div>
            <div class="hint-row"><span>NAV</span><kbd>â† â†’</kbd></div>
            <div class="hint-row"><span>RANDOM</span><kbd>F</kbd></div>
            <div class="hint-row"><span>FULLSCREEN</span><kbd>SPACE</kbd></div>
            <div class="hint-row"><span>COPY LINK</span><kbd>L</kbd></div>
        </div>

    </div>

    <!-- Collection Planner Modal -->
    <div class="collection-planner-modal" id="collectionPlannerModal">
        <div class="collection-planner-content">
            <div class="collection-planner-header">
                <div class="collection-planner-title">Sets You Can Collect</div>
                <button class="collection-planner-close" id="collectionPlannerClose">Ã—</button>
            </div>
            <div class="collection-set" id="gridSet">
                <div class="collection-set-header">
                    <span class="collection-set-name">âŠž Grid Set</span>
                    <span class="collection-set-status empty" id="gridSetStatus">0/4</span>
                </div>
                <div class="collection-set-desc">One city from each grid type</div>
                <div class="collection-set-grid" id="gridSetSlots"></div>
            </div>
            <div class="collection-set" id="energySet">
                <div class="collection-set-header">
                    <span class="collection-set-name">âš¡ Energy Set</span>
                    <span class="collection-set-status empty" id="energySetStatus">0/4</span>
                </div>
                <div class="collection-set-desc">One city from each time of day</div>
                <div class="collection-set-grid" id="energySetSlots"></div>
            </div>
            <div class="collection-promo" id="collectionPromo">
                <div class="collection-promo-text">Complete your Energy Set to unlock a free Efdot artwork!</div>
                <div class="collection-promo-link">
                    <a href="https://www.artblocks.io/collection/0x7c78f67700e700b4005c8a3d920a1a99e6004800-0" target="_blank">COLLECT MORE â†’</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Bottom Bar -->
    <div class="mobile-bottom-bar" id="mobileBottomBar">
        <div class="mob-nav-group">
            <button class="mob-btn" id="mobPrev" aria-label="Previous">â€¹</button>
            <div class="mob-token" id="mobToken">#0</div>
            <button class="mob-btn" id="mobNext" aria-label="Next">â€º</button>
        </div>
        <div class="mob-actions">
            <button class="mob-btn" id="mobRandom" title="Random">âŸ³</button>
            <button class="mob-btn mob-fav" id="mobFav" title="Favorite">â™¡</button>
            <button class="mob-btn mob-more-btn" id="mobMore" title="More">â‹®</button>
        </div>
    </div>

    <!-- Mobile Action Sheet -->
    <div class="mobile-sheet-overlay" id="mobileSheetOverlay"></div>
    <div class="mobile-sheet" id="mobileSheet">
        <div class="mobile-sheet-handle"></div>
        <div class="mobile-sheet-section">
            <div class="mobile-sheet-section-label">Tools</div>
            <div class="mobile-sheet-row">
                <button class="mob-menu-btn" id="mobFullscreen"><span class="mob-menu-icon">â›¶</span><span class="mob-menu-label">Fullscreen</span></button>
                <button class="mob-menu-btn" id="mobFrame"><span class="mob-menu-icon">â–£</span><span class="mob-menu-label">Frame</span></button>
                <button class="mob-menu-btn" id="mobDownload"><span class="mob-menu-icon">â†“</span><span class="mob-menu-label">Download</span></button>
                <button class="mob-menu-btn" id="mobPrint"><span class="mob-menu-icon">âŠ¡</span><span class="mob-menu-label">Print</span></button>
            </div>
        </div>
        <div class="mobile-sheet-section">
            <div class="mobile-sheet-section-label">Explore</div>
            <div class="mobile-sheet-row">
                <button class="mob-menu-btn" id="mobGrid"><span class="mob-menu-icon">âŠž</span><span class="mob-menu-label">Grid</span></button>
                <button class="mob-menu-btn" id="mobFilters"><span class="mob-menu-icon">âš™</span><span class="mob-menu-label">Filters</span></button>
                <button class="mob-menu-btn" id="mobPalette"><span class="mob-menu-icon">â—</span><span class="mob-menu-label">Palette</span></button>
                <button class="mob-menu-btn" id="mobCopyLink"><span class="mob-menu-icon">ðŸ”—</span><span class="mob-menu-label">Link</span></button>
            </div>
        </div>
        <div class="mobile-sheet-section">
            <div class="mobile-sheet-section-label">Community</div>
            <div class="mobile-sheet-row">
                <button class="mob-menu-btn" id="mobCollectors"><span class="mob-menu-icon">ðŸ‘¥</span><span class="mob-menu-label">Collectors</span></button>
                <button class="mob-menu-btn" id="mobFavorites"><span class="mob-menu-icon">â™¡</span><span class="mob-menu-label">Favorites</span></button>
                <button class="mob-menu-btn" id="mobOpenSea"><span class="mob-menu-icon">â›µ</span><span class="mob-menu-label">OpenSea</span></button>
                <button class="mob-menu-btn" id="mobAbout"><span class="mob-menu-icon">â“˜</span><span class="mob-menu-label">About</span></button>
            </div>
        </div>
        <div class="mobile-sheet-owner" id="mobOwnerDisplay"></div>
        <div class="mobile-sheet-footer">
            <a href="https://www.efdotstudio.com" target="_blank">efdot</a> <span>Ã—</span> <a href="https://diid.art" target="_blank">diid</a>
        </div>
    </div>

    <div class="side-nav-arrow left" id="sideNavPrev">â€¹</div>
    <div class="side-nav-arrow right" id="sideNavNext">â€º</div>

    <div class="main-content">
        <div class="frame-container" id="frameContainer">
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div class="loading-text">Cities</div>
            </div>
            <img id="preview-image" class="preview-image" alt="Cities Preview">
            <div class="click-to-view" id="clickToView">VIEW ON OPENSEA</div>
            <button class="explore-fullscreen-btn" id="exploreFullscreenBtn" title="Enter Fullscreen" aria-label="Enter fullscreen mode">â›¶</button>
        </div>
        <div class="fullscreen-exit-hint" id="fullscreenExitHint">TAP TO EXIT</div>
        <div class="bottom-info">
            <div class="info-display">
                <div class="token-line">CITIES #<span class="token-id" id="displayToken">0</span></div>
            </div>
            <div class="similar-outputs" id="similarOutputs">
                <div class="similar-outputs-grid" id="similarOutputsGrid"></div>
            </div>
        </div>
    </div>

    <div class="top-nav-fixed">
        <div class="collect-btn-wrapper">
            <button class="mint-toggle" id="mintToggle" onclick="toggleCollectPopover(this)"><span class="collect-seg cs-1"></span><span class="collect-seg cs-2"></span><span class="collect-seg cs-3"></span><span class="collect-seg cs-4"></span><span class="collect-seg cs-5"></span></button>
            <div class="collect-popover" id="collectPopoverNav">
                <a href="https://www.artblocks.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Get with ETH <span>Art Blocks</span></a>
                <a href="https://shop.efdotstudio.com/collections/cities-collection/products/cities-1-1-500" target="_blank" class="collect-popover-option">Buy with Card <span>Efdot Shop</span></a>
                <a href="https://opensea.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Browse Marketplace <span>OpenSea</span></a>
            </div>
        </div>
        <button class="view-toggle-btn" id="viewToggleBtn" title="Toggle Grid/Single View" aria-label="Toggle between grid and single view" aria-expanded="false">
            <img src="glyph-blob-static.png" alt="" class="glyph-img glyph-static glyph-blob">
            <img src="glyph-blob.gif" alt="" class="glyph-img glyph-animated glyph-blob">
            <img src="glyph-textile-static.png" alt="" class="glyph-img glyph-static glyph-textile">
            <img src="glyph-textile.gif" alt="" class="glyph-img glyph-animated glyph-textile">
        </button>
    </div>

    <div class="gallery-panel" id="galleryPanel" role="dialog" aria-label="Favorites panel" aria-hidden="true">
        <div class="gallery-header">
            <h2 class="gallery-title-close" id="galleryTitleClose">FAVORITES <span class="gallery-close-arrow">â€º</span></h2>
            <button class="gallery-close" id="closeGallery">&times;</button>
        </div>
        <div class="fav-palettes-section" id="favPalettesSection">
            <div class="fav-palettes-header" id="favPalettesToggle">FAVORITE PALETTES <span class="collapse-arrow">â–¼</span></div>
            <div class="fav-palettes-grid" id="favPalettesGrid">
                <div class="fav-palette-item" data-palette="Beach Day">
                    <div class="fav-palette-swatch" style="background: #f1e9d2;"></div>
                    <div class="fav-palette-name">Beach Day</div>
                    <button class="fav-palette-remove">Ã—</button>
                </div>
            </div>
        </div>
        <div class="gallery-grid" id="galleryGrid">
            <div class="empty-gallery">Nothing here yet. Go explore.</div>
        </div>
    </div>

    <button class="btn btn-secondary collectors-toggle" id="toggleCollectors">COLLECTORS</button>

    <div class="collectors-panel" id="collectorsPanel" role="dialog" aria-label="Collectors panel" aria-hidden="true">
        <div class="collectors-header">
            <h2 id="collectorsTitle" style="cursor: pointer;"><span class="collectors-title-text">COLLECTORS</span> <span class="collapse-arrow">â€ºâ€ºâ€º</span></h2>
            <div class="collectors-header-actions">
                <button class="dream-grid-btn" id="dreamGridBtn" title="Dream Collection" aria-label="Build a dream collection">&#x1F4AD;</button>
                <button class="energy-quadrant-btn" id="energyQuadrantBtn" title="Energy Collector Map" aria-label="Open energy collector map">âš¡</button>
                <button class="leaderboard-btn" id="showLeaderboard">LEADERBOARD</button>
                <button class="collectors-close" id="closeCollectors">&times;</button>
            </div>
        </div>
        <button class="not-collector-link" id="notCollectorTop">Not a collector yet? âœ¦</button>
        <div class="pills-view" id="pillsView">
            <!-- Daily Collector Feature - collapsed by default -->
            <div class="collector-feature collapsed" id="collectorFeature">
                <div class="feature-collapsed-label" id="featureCollapsedLabel"
                    onclick="event.stopPropagation(); var el = document.getElementById('collectorFeature'); el.classList.toggle('collapsed'); var txt = document.getElementById('featureLabelText'); if(txt) txt.textContent = el.classList.contains('collapsed') ? 'Cities OTD' : 'Cities of the Day';"
                    onmouseenter="if(window.innerWidth > 768) { var txt = document.getElementById('featureLabelText'); if(txt && document.getElementById('collectorFeature').classList.contains('collapsed')) txt.textContent = 'Cities of the Day'; }"
                    onmouseleave="if(window.innerWidth > 768) { var txt = document.getElementById('featureLabelText'); if(txt && document.getElementById('collectorFeature').classList.contains('collapsed')) txt.textContent = 'Cities OTD'; }">
                    <span class="feature-label-icon">âœ¦</span>
                    <span class="feature-label-text" id="featureLabelText">Cities OTD</span>
                    <span class="feature-expand-arrow">â–¼</span>
                </div>
                <div class="feature-expanded-content">
                    <div class="feature-palette-blend" id="featurePaletteBlend"></div>
                    <div class="feature-content">
                        <div class="feature-collector-label">Collected by</div>
                        <div class="feature-collector" id="featureCollector"></div>
                        <div class="feature-cities" id="featureCities"></div>
                        <div class="feature-palettes" id="featurePalettes"></div>
                    </div>
                </div>
            </div>
            <div class="collectors-stats"><span id="collectorCountStats">164</span> collectors Â· <span id="citiesCountStats">321</span> cities</div>
            <div class="top-collectors-highlight" id="topCollectorsHighlight"></div>
            <div class="collectors-pills" id="collectorsPills"></div>
            <button class="become-collector-btn" id="becomeCollectorBtn">âœ¦ Join the Movement</button>
        </div>
        <!-- Citizen Guide View - Step-by-step onboarding -->
        <div class="collector-guide-view" id="collectorGuideView">
            <button class="leaderboard-btn back-btn" id="backFromGuide">â† BACK</button>

            <div class="collector-guide-header">
                <div class="collector-guide-steps">
                    <div class="collector-guide-step-num active" data-step="1">1</div>
                    <div class="collector-guide-step-num" data-step="2">2</div>
                    <div class="collector-guide-step-num" data-step="3">3</div>
                </div>
            </div>

            <!-- Step 1: What is digital art ownership? -->
            <div class="collector-guide-step active" data-step="1">
                <div class="collector-guide-title">Digital ownership 101</div>
                <div class="collector-guide-desc">
                    Each City is a unique piece of digital art, one of only 500 ever&nbsp;made. When you collect one, it's truly yours. No&nbsp;middlemen, no&nbsp;expiration. Think of it like owning an original painting, but digital and&nbsp;one&#8209;of&#8209;a&#8209;kind.
                </div>
                <div class="collector-guide-highlight">500 unique Cities. Each one exists only&nbsp;once. Yours to keep&nbsp;forever.</div>
            </div>

            <!-- Step 2: How to collect -->
            <div class="collector-guide-step" data-step="2">
                <div class="collector-guide-title">How to collect</div>
                <div class="collector-guide-desc">
                    You can get one directly with ETH on Art&nbsp;Blocks, or buy with a credit card through the Efdot Studio&nbsp;Shop. No crypto wallet&nbsp;needed. Already&#8209;collected Cities can be found on&nbsp;OpenSea.
                </div>
                <div class="collector-guide-highlight">Every 4&nbsp;Cities you own is a&nbsp;set. Each set earns one airdrop of future&nbsp;drops. One City of each energy&nbsp;type&mdash;Rising, Living, Fading, Resting&mdash;is a complete energy&nbsp;set.</div>
                <button class="collector-guide-pill-btn secondary" id="guideExploreGrid">
                    Explore the grid
                </button>
                <button class="collector-guide-pill-btn secondary" id="guideDreamGrid">
                    &#x1F4AD; Build a dream collection
                </button>
            </div>

            <!-- Step 3: Digital + Physical -->
            <div class="collector-guide-step" data-step="3">
                <div class="collector-guide-title">Digital + Physical</div>
                <div class="collector-guide-desc">Cities aren't just for&nbsp;screens. Owners can order hand&#8209;signed prints, and high&#8209;quality posters are available to anyone through the Efdot Studio&nbsp;Shop. Collect the art you love, then put it on your&nbsp;wall.</div>
                <a href="https://www.artblocks.io/marketplace/collections/cities-by-efdot-x-diid" target="_blank" class="collector-guide-pill-btn">
                    Get on Art Blocks
                </a>
                <a href="https://shop.efdotstudio.com/collections/cities-collection" target="_blank" class="collector-guide-pill-btn secondary">
                    Browse Prints
                </a>
                <a href="https://opensea.io/collection/cities-by-efdot-x-diid" target="_blank" class="collector-guide-pill-btn secondary">
                    Browse on OpenSea
                </a>
            </div>

            <div class="collector-guide-nav">
                <button class="collector-guide-arrow prev" id="guidePrevBtn" disabled>
                    <span class="arrow-icon">â†</span> back
                </button>
                <button class="collector-guide-arrow next" id="guideNextBtn">
                    next <span class="arrow-icon">â†’</span>
                </button>
            </div>
        </div>
        <div class="leaderboard-view" id="leaderboardView">
            <button class="leaderboard-btn back-btn" id="backToPills">â† BACK TO ALL COLLECTORS</button>
            <ul class="leaderboard-list" id="leaderboardList"></ul>
        </div>
    </div>

    <button class="btn btn-secondary grid-toggle" id="toggleGrid" aria-label="Open grid view of all cities">GRID VIEW</button>

    <!-- Mobile elements - must be before script -->
    <div class="mobile-bottom-bar" id="mobileBottomBar2">
        <button id="mobileMenuBtn" title="Menu">â˜°</button>
        <button id="mobilePrevBtn" title="Previous">â—€</button>
        <button id="mobileHeartBtn" class="mobile-heart-btn" title="Favorite">â™¥</button>
        <button id="mobileNextBtn" title="Next">â–¶</button>
        <button id="mobileGridBtn" title="Grid View">âŠž</button>
    </div>
    <div class="pull-refresh-indicator" id="pullRefreshIndicator">
        <span class="refresh-icon">â†»</span>
        <span class="refresh-text">Pull to shuffle</span>
    </div>
    <div class="double-tap-heart" id="doubleTapHeart">â™¥</div>

    <div class="grid-panel open hide-numbers" id="gridPanel" role="dialog" aria-label="Cities grid view" aria-hidden="true">
        <div class="grid-header">
            <div class="grid-brand">
                <h1 id="gridTitle">Cities</h1>
                <div class="grid-artist-logos">
                    <a href="https://www.efdotstudio.com" target="_blank" title="Efdot Studio"><img src="ef-logo.png" alt="Efdot" class="grid-artist-logo ef-logo"></a>
                    <span class="grid-logo-x">Ã—</span>
                    <a href="https://diid.art" target="_blank" title="Diid"><img src="diid-logo.png" alt="Diid" class="grid-artist-logo diid-logo"></a>
                </div>
                <a href="#" class="grid-about-link" id="gridAboutTrigger" title="About" onclick="if(window.openAboutModal) window.openAboutModal(); return false;"><img src="info-icon.png" alt="About"></a>
            </div>
            <div class="grid-controls">
                <button class="grid-size-toggle" id="gridSizeToggle" title="Change grid size">
                    <span class="size-icon" id="sizeIcon"></span>
                </button>
                <button class="grid-mode-btn" data-mode="grid" data-emoji="ðŸŒ" id="gridAllFavBtn" title="All Cities">ALL</button>
                <button class="grid-mode-btn active" data-mode="palette" data-emoji="ðŸŽ¨" id="paletteColorToggle" title="Sort by Palette">BY PALETTE <span class="palette-sort-arrow">â†“</span></button>
                <button class="grid-mode-btn origins-btn" data-mode="origins" data-emoji="âœï¸" id="gridOriginsBtn" title="Origins">ORIGINS</button>
                <button class="grid-mode-btn collectors-btn" data-emoji="ðŸ‘¥" id="gridCollectorsBtn" title="Collectors">COLLECTORS</button>
            </div>
        </div>
        <div class="filter-toggle-bar" id="filterToggleBar"><div class="grid-clock" id="gridClock"></div><span>FILTERS</span><span class="arrow">â–¼</span></div>
        <div class="grid-filter-bar" id="gridFilterBar">
            <div class="multi-select" id="paletteMultiSelect">
                <button class="multi-select-btn" type="button">PALETTE <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <div class="multi-select" id="timeMultiSelect">
                <button class="multi-select-btn" type="button">TIME <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <div class="multi-select" id="energyMultiSelect">
                <button class="multi-select-btn" type="button">ENERGY <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <div class="multi-select" id="zoomMultiSelect">
                <button class="multi-select-btn" type="button">ZOOM <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <div class="multi-select" id="boundsMultiSelect">
                <button class="multi-select-btn" type="button">BOUNDS <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <div class="multi-select" id="trafficMultiSelect">
                <button class="multi-select-btn" type="button">TRAFFIC <span class="arrow">â–¼</span></button>
                <div class="multi-select-dropdown"></div>
            </div>
            <label class="grid-checkbox"><input type="checkbox" id="gridWaterFilter"> WATER</label>
            <button class="grid-sort-toggle sort-desc" id="gridSortToggle" title="Sort order">NEW <span class="sort-arrow">â†‘</span></button>
            <button class="grid-numbers-toggle" id="gridNumbersToggle" title="Toggle output numbers">#</button>
            <button class="grid-color-gradient-toggle" id="gridColorGradientToggle" title="Filter by color"><span class="color-dot"></span></button>
            <div class="grid-color-gradient-bar" id="gridColorGradientBar">
                <div class="grid-color-gradient-inner">
                    <div class="grid-color-gradient-meta">
                        <span class="grid-color-gradient-clock" id="gridColorGradientClock"></span>
                        <span class="grid-color-gradient-label">SLIDE TO FILTER BY COLOR</span>
                        <span class="grid-color-gradient-hint" id="gridColorGradientHint">Few results â€” try clearing other filters</span>
                        <button class="grid-color-gradient-close" id="gridColorGradientClose" title="Close color filter">&times;</button>
                    </div>
                    <div class="grid-color-gradient-strip" id="gridColorGradientStrip">
                        <div class="grid-color-gradient-marker" id="gridColorGradientMarker"></div>
                        <button class="gradient-step-toggle" id="gradientStepToggle" title="Toggle smooth / stepped"><svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2 14 h3.5 v-4 h3.5 v-4 h3.5 v-4"/></svg></button>
                    </div>
                </div>
            </div>
            <div class="grid-filter-spacer"></div>
            <span class="grid-showing-count" id="gridShowingCount">318 showing</span>
            <a href="https://www.artblocks.io/collection/0x7c78f67700e700b4005c8a3d920a1a99e6004800-0" target="_blank" class="grid-supply-tracker" id="gridSupplyTracker" onclick="return confirm('You are about to leave Cities Explorer and visit Art Blocks. Continue?');">
                <div class="grid-supply-bar">
                    <div class="grid-supply-fill" id="gridSupplyFill" style="width: 0%;"></div>
                    <div class="grid-supply-label"><span id="gridMintedCount"></span>&nbsp;COLLECTED</div>
                </div>
            </a>
        </div>
        <div class="collector-banner" id="collectorBanner">
            <button class="collector-banner-nav collector-banner-prev" id="collectorBannerPrev" onclick="event.stopPropagation(); navigateToPrevCollector();" title="Previous collector (â†)">â€¹</button>
            <div class="collector-banner-left">
                <span class="collector-banner-label">COLLECTION OF</span>
                <span class="collector-banner-name" id="collectorBannerName" title="Click to view wall"></span>
            </div>
            <div class="collector-banner-right">
                <span class="collector-banner-phrase" id="collectorBannerPhrase"></span>
                <button class="collector-banner-wall" id="collectorWallView">WALL</button>
                <span class="collector-banner-count" id="collectorBannerCount"></span>
            </div>
            <button class="collector-banner-nav collector-banner-next" id="collectorBannerNext" onclick="event.stopPropagation(); navigateToNextCollector();" title="Next collector (â†’)">â€º</button>
            <button class="collector-banner-close" id="collectorBannerClose">&times;</button>
        </div>
        <div class="grid-content" id="gridContent"></div>
        <div class="grid-pagination" id="gridPagination">
            <button id="gridPrevPage">â† PREV</button>
            <span class="page-info" id="gridPageInfo">PAGE 1 OF 1</span>
            <button id="gridNextPage">NEXT â†’</button>
        </div>
    </div>

    <div class="status-message" id="statusMessage"></div>

    <!-- Wall View Modal -->
    <div class="wall-view-modal" id="wallViewModal">
        <div class="wall-view-header">
            <div class="wall-view-header-left">
                <button class="wall-view-back-btn" id="wallViewBackBtn">â† BACK</button>
                <span class="wall-view-logo">Cities</span>
            </div>
            <div class="wall-view-controls">
                <button class="wall-view-wall-toggle" id="wallViewWallToggle" title="Toggle wall color" aria-label="Toggle light/dark wall"></button>
                <button class="wall-view-layout-toggle" id="wallViewLayoutToggle" title="Toggle wide/tall layout">âŠž</button>
                <button class="wall-view-hide-empty" id="wallViewHideEmpty" title="Toggle grid/line view"><span class="line-icon">âŠž</span> GRID</button>
                <button class="wall-view-try-mode" id="wallViewTryMode" title="Try adding cities to your grid">âœ¦ TRY</button>

                <div class="collect-btn-wrapper">
                    <button class="about-mint-btn wall-view-mint-btn" id="wallViewMintBtn" onclick="toggleCollectPopover(this)"><span class="collect-seg cs-1"></span><span class="collect-seg cs-2"></span><span class="collect-seg cs-3"></span><span class="collect-seg cs-4"></span><span class="collect-seg cs-5"></span></button>
                    <div class="collect-popover" id="collectPopoverWall">
                        <a href="https://www.artblocks.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Get with ETH <span>Art Blocks</span></a>
                        <a href="https://shop.efdotstudio.com/collections/cities-collection/products/cities-1-1-500" target="_blank" class="collect-popover-option">Buy with Card <span>Efdot Shop</span></a>
                        <a href="https://opensea.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Browse Marketplace <span>OpenSea</span></a>
                    </div>
                </div>
                <button class="wall-view-close" id="wallViewClose">&times;</button>
            </div>
        </div>
        <button class="wall-view-nav prev" id="wallViewPrev">â€¹</button>
        <button class="wall-view-nav next" id="wallViewNext">â€º</button>
        <div class="wall-view-content" id="wallViewContent">
            <div class="wall-view-lighting" id="wallViewLightingEffect"></div>
            <div class="wall-view-haunted-effect" id="wallViewHauntedEffect">
                <div class="haunted-mist"></div>
            </div>
            <div class="wall-view-room" id="wallViewRoom">
                <div class="wall-view-wall-wrapper" id="wallViewWrapper">
                    <div class="wall-view-wall" id="wallViewWall">
                        <div class="wall-view-collector-info" id="wallViewCollectorInfo">
                            <div class="wall-view-collector-name" id="wallViewCollectorLabel"></div>
                        </div>
                        <!-- Artworks will be inserted here dynamically -->
                    </div>
                </div>
                <div class="wall-view-baseboard"></div>
                <div class="wall-view-floor"></div>
            </div>
        </div>
        <button class="wall-view-print-btn" id="wallViewPrint">ORDER PRINT</button>
        <div class="wall-view-zoom-controls">
            <button class="wall-view-zoom-btn" id="wallViewShuffle" title="Shuffle order">âŸ³</button>
            <button class="wall-view-zoom-btn" id="wallViewZoomIn" title="Zoom in">+</button>
            <button class="wall-view-zoom-btn" id="wallViewZoomOut" title="Zoom out">âˆ’</button>
            <button class="wall-view-zoom-btn" id="wallViewRecenter" title="Re-center view">
                <span class="recenter-btn-grid">
                    <span></span><span></span><span></span><span></span>
                </span>
            </button>
        </div>
        <!-- Grid status nudge bar -->
        <div class="wall-view-grid-nudge" id="wallViewGridNudge">
            <span class="wall-view-grid-nudge-text" id="wallViewGridNudgeText"></span>
        </div>
        <!-- Collector tips toggle button -->
        <button class="wall-view-tips-toggle" id="wallViewTipsToggle" title="Collection tips">
            <span class="tips-icon"><span>ðŸŒ‰</span><span>ðŸŒ‡</span><span>ðŸ™ï¸</span><span>ðŸŒƒ</span></span>
        </button>
        <div class="wall-view-tips-hover" id="wallViewTipsHover"></div>
        <!-- Collector pairing suggestion -->
        <div class="wall-view-suggestion" id="wallViewSuggestion">
            <button class="wall-view-suggestion-close" id="suggestionClose">Ã—</button>
            <div class="wall-view-suggestion-label" id="suggestionLabel">Complement this collection</div>
            <div class="wall-view-suggestion-text" id="suggestionText">These cities share energy and would pair beautifully on this wall.</div>
            <div class="wall-view-suggestion-cities" id="suggestionCities"></div>
        </div>
    </div>

    <!-- Print Inquiry Modal -->
    <div class="print-inquiry-modal" id="printInquiryModal">
        <div class="print-inquiry-content">
            <button class="print-inquiry-close" id="printInquiryClose">&times;</button>
            <div id="printInquiryForm">
                <div class="print-inquiry-title" id="printInquiryTitle">Get a Print</div>

                <!-- Frame preview with artwork -->
                <div class="print-inquiry-frame-preview" id="printInquiryFramePreview">
                    <button class="print-inquiry-wall-toggle" id="printInquiryWallToggle" title="Toggle wall color">â˜¾</button>
                    <div class="print-inquiry-mini-frame" id="printInquiryMiniFrame">
                        <div class="print-inquiry-mini-inner">
                            <img id="printInquiryPreviewImg" src="" alt="Print preview">
                        </div>
                    </div>
                    <div class="print-inquiry-frame-label" id="printInquiryFrameLabel"></div>
                    <!-- City strip for multiple cities -->
                    <div class="print-inquiry-city-strip" id="printInquiryCityStrip"></div>
                    <!-- Frame color picker -->
                    <div class="print-inquiry-frame-colors">
                        <button class="print-inquiry-frame-color active" data-color="light-wood" title="Light Wood"></button>
                        <button class="print-inquiry-frame-color" data-color="white" title="White"></button>
                        <button class="print-inquiry-frame-color" data-color="black" title="Black"></button>
                        <button class="print-inquiry-frame-color" data-color="dark-wood" title="Dark Wood"></button>
                    </div>
                </div>

                <div class="print-inquiry-field">
                    <label>Size</label>
                    <div class="print-inquiry-sizes">
                        <div class="print-inquiry-size-option" data-size="9x16" data-price="50" data-signed="false" data-framed="false">
                            <div class="size-dims">9 Ã— 16"</div>
                            <div class="size-cm">23 Ã— 41 cm</div>
                            <div class="size-price">$50</div>
                            <div class="size-price-converted"></div>
                        </div>
                        <div class="print-inquiry-size-option active" data-size="18x32" data-price="250" data-signed="true" data-framed="false">
                            <div class="size-dims">18 Ã— 32"</div>
                            <div class="size-cm">46 Ã— 81 cm</div>
                            <div class="size-price">$250</div>
                            <div class="size-price-converted"></div>
                            <div class="size-label">hand-signed</div>
                            <img class="size-signature" src="efdot-signature.png" alt="">
                        </div>
                        <div class="print-inquiry-size-option" data-size="18x32-framed" data-price="500" data-signed="true" data-framed="true">
                            <div class="size-dims">18 Ã— 32"</div>
                            <div class="size-cm">46 Ã— 81 cm</div>
                            <div class="size-price">$500</div>
                            <div class="size-price-converted"></div>
                            <div class="size-label">signed + framed</div>
                            <img class="size-signature" src="efdot-signature.png" alt="">
                        </div>
                    </div>
                    <div class="print-inquiry-shipping-note">+ shipping</div>
                </div>

                <div class="print-inquiry-field" id="printInquiryEmailField" style="display: none;">
                    <label>Email Address</label>
                    <input type="email" id="printInquiryEmail" placeholder="your@email.com">
                </div>

                <button class="print-inquiry-details-toggle" id="printInquiryDetailsToggle" style="display: none;">
                    <span class="toggle-arrow">â€º</span> Add details
                </button>
                <div class="print-inquiry-details-extra" id="printInquiryDetailsExtra" style="display: none;">
                    <div class="print-inquiry-field">
                        <label>Country (for shipping estimate)</label>
                        <input type="text" id="printInquiryCountry" placeholder="Country" value="United States">
                    </div>
                    <div class="print-inquiry-field">
                        <label>Notes (optional)</label>
                        <textarea id="printInquiryNotes" placeholder="Questions, special requests..."></textarea>
                    </div>
                </div>

                <div class="print-inquiry-type-note">Signed prints for <a href="https://opensea.io/collection/cities-by-efdot-x-diid" target="_blank">City owners</a> Â· Posters at <a href="https://shop.efdotstudio.com/collections/cities-collection" target="_blank">Efdot Studio Shop</a></div>

                <div class="print-inquiry-actions">
                    <button class="print-inquiry-btn primary" id="printInquirySend" style="flex: 2;">Check out in Efdot Shop</button>
                    <button class="print-inquiry-btn secondary" id="printInquiryCancel">Cancel</button>
                </div>
            </div>
            <div id="printInquirySuccess" style="display: none;">
                <div class="print-inquiry-success">
                    <div class="print-inquiry-success-icon">âœ¦</div>
                    <div class="print-inquiry-success-text">Request sent!</div>
                    <div class="print-inquiry-success-sub">Eric will get back to you soon.</div>
                </div>
                <button class="print-inquiry-btn primary" id="printInquiryDone" style="margin-top: 20px; width: 100%;">Back to Explorer</button>
            </div>
        </div>
    </div>

    <!-- OpenSea Warning Modal -->
    <div class="opensea-warning-modal" id="openseaWarningModal">
        <div class="opensea-warning-content">
            <div class="opensea-warning-icon">â›µ</div>
            <div class="opensea-warning-title">Taking a Detour to OpenSea</div>
            <div class="opensea-warning-actions">
                <button class="opensea-warning-btn primary" id="openseaWarningContinue">Continue to OpenSea</button>
                <button class="opensea-warning-btn secondary" id="openseaWarningCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Energy Quadrant View -->
    <div class="energy-quadrant-modal" id="energyQuadrantModal">
        <div class="energy-quadrant-container" id="energyQuadrantContainer">
            <div class="energy-quadrant-header">
                <span class="energy-quadrant-title">Collector Energy Map</span>
                <span class="energy-quadrant-subtitle" id="eqSubtitle"></span>
                <button class="eq-close-btn" id="eqCloseBtn" title="Close" onclick="closeEnergyQuadrant()">&times;</button>
            </div>
            <div class="eq-nudge" id="eqNudge"></div>
            <div class="energy-quadrant-grid">
                <div class="energy-quadrant eq-rising" data-energy="Rising">
                    <div class="eq-label"><span class="eq-label-icon">&#9728;</span> Rising <span class="eq-total" id="eqTotalRising"></span></div>
                    <div class="eq-collectors" id="eqRising"></div>
                </div>
                <div class="energy-quadrant eq-living" data-energy="Living">
                    <div class="eq-label"><span class="eq-label-icon">&#128694;</span> Living <span class="eq-total" id="eqTotalLiving"></span></div>
                    <div class="eq-collectors" id="eqLiving"></div>
                </div>
                <div class="energy-quadrant eq-fading" data-energy="Fading">
                    <div class="eq-label"><span class="eq-label-icon">&#9925;</span> Fading <span class="eq-total" id="eqTotalFading"></span></div>
                    <div class="eq-collectors" id="eqFading"></div>
                </div>
                <div class="energy-quadrant eq-resting" data-energy="Resting">
                    <div class="eq-label"><span class="eq-label-icon">&#127769;</span> Resting <span class="eq-total" id="eqTotalResting"></span></div>
                    <div class="eq-collectors" id="eqResting"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Perfect Sets View -->
    <div class="perfect-sets-modal" id="perfectSetsModal" onclick="if(event.target === this) closePerfectSets()">
        <div class="perfect-sets-content">
            <div class="perfect-sets-header">
                <span class="perfect-sets-title">City Sets</span>
                <span class="perfect-sets-subtitle" id="perfectSetsSubtitle"></span>
                <button class="perfect-sets-close" onclick="closePerfectSets()" title="Close">&times;</button>
            </div>
            <div id="perfectSetsBody"></div>
        </div>
    </div>

    <div class="palette-inspector" id="paletteInspector">
        <button class="palette-nav-arrow palette-nav-prev" id="paletteNavPrev" title="Previous palette (â†)">â€¹</button>
        <button class="palette-nav-arrow palette-nav-next" id="paletteNavNext" title="Next palette (â†’)">â€º</button>
        <div class="palette-inspector-content">
            <div class="palette-fan-container" id="paletteFanContainer" style="display: none;">
                <button class="palette-fan-arrow" id="fanArrowLeft">â†</button>
                <div class="palette-fan" id="paletteFan"></div>
                <button class="palette-fan-arrow" id="fanArrowRight">â†’</button>
            </div>
            <div class="pantone-swatch" id="pantoneSwatch">
                <div class="pantone-name-floating" id="pantoneName"></div>
                <div class="pantone-header-row">
                    <button class="pantone-fav-btn" id="pantoneFavBtn" title="Add to favorites">â™¡</button>
                    <button class="pantone-hex-toggle" id="pantoneHexToggle">Show Hex</button>
                </div>
                <div class="pantone-info">
                    <div class="pantone-meta" id="pantoneMeta"></div>
                    <div id="pantoneColors"></div>
                    <div class="pantone-hex-section" id="pantoneHexSection"></div>
                </div>
            </div>
            <div class="palette-inspector-similar" id="paletteInspectorSimilar"></div>
            <button class="palette-inspector-close" id="closePaletteInspector">CLOSE</button>
        </div>
        <div class="palette-gradient-nav" id="paletteGradientNav">
            <div class="palette-gradient-strip" id="paletteGradientStrip">
                <div class="palette-gradient-marker" id="paletteGradientMarker"></div>
            </div>
        </div>
    </div>

    <!-- Framed Mockup View -->
    <div class="frame-mockup" id="frameMockup">
        <button class="view-back-btn" id="frameMockupBack">â† BACK</button>
        <div class="frame-mockup-content">
            <div class="frame-mockup-artwork">
                <div class="frame-mockup-label" id="frameMockupLabel">#0</div>
                <div class="frame-mockup-collector" id="frameMockupCollector"></div>
                <div class="frame-wrapper" id="frameWrapper">
                    <div class="frame-inner">
                        <img id="frameMockupImage" src="" alt="Framed city artwork">
                    </div>
                </div>
            </div>
        </div>
        <button class="frame-mockup-mode" id="frameMockupMode" title="Toggle dark mode">â˜¾</button>
        <button class="frame-mockup-nav prev" id="frameMockupPrev" title="Previous city">â€¹</button>
        <button class="frame-mockup-nav next" id="frameMockupNext" title="Next city">â€º</button>
        <button class="frame-mockup-download" id="downloadFramed" title="Download framed image">â†“</button>
        <button class="frame-mockup-order" id="orderPrint" title="Order a print">Order a Print</button>
        <button class="frame-mockup-close" id="closeFrameMockup">Ã—</button>
        <div class="frame-mockup-colors">
            <button class="frame-color-btn active" data-color="light-wood" title="Light Wood"></button>
            <button class="frame-color-btn" data-color="white" title="White"></button>
            <button class="frame-color-btn" data-color="black" title="Black"></button>
            <button class="frame-color-btn" data-color="dark-wood" title="Dark Wood"></button>
        </div>
    </div>

    <!-- Immersive Gallery Room -->
    <div class="gallery-room" id="galleryRoom">
        <div class="gallery-room-ambient"></div>
        <div class="gallery-room-wall" id="galleryRoomWall"></div>
        <div class="gallery-room-top-left">
            <span class="gallery-room-title">Cities</span>
            <button class="view-back-btn" id="galleryRoomBack">â† BACK</button>
        </div>
        <a href="#" class="gallery-room-about" id="galleryRoomAbout" title="About" onclick="if(window.openAboutModal) window.openAboutModal(); return false;"><img src="info-icon.png" alt="About"></a>
        <div class="gallery-room-counter" id="galleryRoomCounter">12 Cities</div>
        <button class="gallery-room-close" id="galleryRoomClose">Ã—</button>
        <div class="gallery-room-controls">
            <button class="gallery-room-btn" id="galleryShuffleBtn" title="Shuffle">&#8635;</button>
            <button class="gallery-room-btn" id="galleryPauseBtn" title="Pause/Play">&#9208;</button>
            <button class="gallery-room-btn" id="gallerySpeedBtn" title="Change speed">1&times;</button>
        </div>
    </div>

    <!-- Keyboard Hint Overlay -->
    <div class="keyboard-hint-overlay" id="keyboardHintOverlay">Press<kbd>G</kbd>for grid view</div>

    <!-- Leave Your Mark -->
    <div class="playground-overlay" id="playgroundOverlay">
        <div class="playground-header">
            <div class="playground-header-left">
                <div class="playground-title">Leave Your Mark</div>
                <div class="playground-palette-name" id="playgroundPaletteName" title="Click for new palette">Loading...</div>
            </div>
            <div class="playground-controls">
                <button class="playground-btn" id="playgroundNewPalette">ðŸŽ² Shuffle</button>
                <button class="playground-btn" id="playgroundClear">Clear</button>
                <div class="playground-download-wrap">
                    <button class="playground-btn" id="playgroundDownloadBtn">Download â–¾</button>
                    <div class="playground-download-menu" id="playgroundDownloadMenu">
                        <div class="playground-download-option" data-ratio="4:5" data-size="1080">4:5 Portrait (1080Ã—1350)</div>
                        <div class="playground-download-option" data-ratio="1:1" data-size="1080">1:1 Square (1080px)</div>
                        <div class="playground-download-option" data-ratio="9:16" data-size="1080">9:16 Story (1080Ã—1920)</div>
                        <div class="playground-download-option" data-ratio="4:5" data-size="2160">4:5 Hi-Res (2160Ã—2700)</div>
                        <div class="playground-download-option" data-ratio="1:1" data-size="2160">1:1 Hi-Res (2160px)</div>
                        <div class="playground-download-option" data-ratio="9:16" data-size="2160">9:16 Hi-Res (2160Ã—3840)</div>
                    </div>
                </div>
                <button class="playground-close" id="playgroundClose">Ã—</button>
            </div>
        </div>
        <div class="playground-canvas-wrap">
            <canvas class="playground-canvas" id="playgroundCanvas" width="800" height="1000"></canvas>
        </div>
        <div class="playground-toolbar">
            <button class="playground-tool active" id="toolDot" title="Dot">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" fill="currentColor" stroke="none"/></svg>
            </button>
            <button class="playground-tool" id="toolLine" title="Line">
                <svg viewBox="0 0 24 24"><line x1="4" y1="20" x2="20" y2="4"/></svg>
            </button>
            <div class="playground-colors" id="playgroundColors">
                <span class="playground-color-label">Color:</span>
                <!-- Color buttons will be added dynamically -->
            </div>
            <div class="playground-multicolor">
                <button class="playground-multicolor-btn" id="playgroundMultiColor" title="Multi-color mode (cycles through palette)">
                    <span class="multicolor-icon">â—</span>
                    <span class="multicolor-label">Multi</span>
                </button>
            </div>
            <div class="playground-ratio">
                <button class="playground-ratio-btn" data-ratio="1:1" title="Square">1:1</button>
                <button class="playground-ratio-btn active" data-ratio="4:5" title="Portrait">4:5</button>
                <button class="playground-ratio-btn" data-ratio="9:16" title="Story">9:16</button>
            </div>
        </div>
    </div>

    <!-- About modal -->
    <div class="about-modal" id="aboutModal" onclick="if(event.target === this) { var m = document.getElementById('aboutModal'); if(m) m.classList.remove('open'); }">
        <button class="about-close" id="aboutCloseBtn" onclick="var m = document.getElementById('aboutModal'); if(m) m.classList.remove('open'); event.stopPropagation();">&times;</button>
        <div class="about-content">
            <h1 class="about-title">Cities</h1>
            <p class="about-collab"><span class="about-collab-short"><a href="https://efdotstudio.com" target="_blank">Efdot</a> Ã— <a href="https://diid.art" target="_blank">Diid</a></span><span class="about-collab-full">A code-based art collaboration between <a href="https://efdotstudio.com" target="_blank">Efdot</a> and <a href="https://diid.art" target="_blank">Diid</a>, on <a href="https://www.artblocks.io/collection/cities-by-efdot-x-diid" target="_blank">Art&nbsp;Blocks</a>.</span></p>
            <p class="about-intro">An imagined city never ends. It keeps growing past the edge of what you can see. Cities captures that from above: <span class="about-highlight teal">500 aerial grids</span> of one infinite concept.</p>
            <p class="about-journey-link"><a href="#" onclick="if(window.openTimeline) { window.openTimeline(); } event.preventDefault(); event.stopPropagation();">See the journey from hand to code â†’</a></p>

            <div class="about-video">
                <iframe src="https://player.vimeo.com/video/1162260399?title=0&byline=0&portrait=0&dnt=1" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe>
            </div>

            <div class="about-sections-grid">
                <div class="about-sections-col">
                    <div class="about-section" data-section="artists">
                        <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                            <span class="about-section-title">The Artists</span>
                            <span class="about-section-arrow">â–¼</span>
                        </div>
                        <div class="about-section-content">
                            <div class="about-artist">
                                <strong><a href="https://efdotstudio.com" target="_blank">Efdot</a></strong> is an NYC-based artist whose work lives on everything from walls, to screens, to skateboards. Trained as a designer, he left that world to draw full time. His semi-abstract style pulls from street art, murals, and a lifelong love of the city grid.
                                <div class="about-artist-links">
                                    <a href="http://www.efdotstudio.com" target="_blank">Portfolio</a>
                                    <a href="https://twitter.com/efdotstudio" target="_blank">X/Twitter</a>
                                    <a href="https://instagram.com/efdot" target="_blank">Instagram</a>
                                </div>
                            </div>
                            <div class="about-artist">
                                <strong><a href="https://diid.art" target="_blank">Diid</a></strong> is a generative artist and creative coder. His work bridges hand-drawn aesthetics with computational precision, building systems that give visual ideas a life of their own.
                                <div class="about-artist-links">
                                    <a href="http://www.diid.art" target="_blank">Portfolio</a>
                                    <a href="https://twitter.com/0xdiid" target="_blank">X/Twitter</a>
                                </div>
                            </div>
                        </div>
                    </div>

            <div class="about-section" data-section="aerial">
                <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                    <span class="about-section-title">The Aerial View</span>
                    <span class="about-section-arrow">â–¼</span>
                </div>
                <div class="about-section-content">
                    You know this grid. You would walk it every day. But when did you last <span class="about-highlight warm">see</span> it? Cities makes the familiar unfamiliar again. Zoomed way out, all details fall away. You stop being yourself. You become <span class="about-highlight teal">one dot among millions</span>, a witness to a collective consciousness. Each mark invites you to imagine a story. Millions of these stories overlap to form the <span class="about-highlight warm">fabric of the city</span>.
                </div>
            </div>

            <div class="about-section" data-section="algorithm">
                <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                    <span class="about-section-title">The Algorithm</span>
                    <span class="about-section-arrow">â–¼</span>
                </div>
                <div class="about-section-content">
                    Over three years, we built the Cities algorithm from rules developed through hand drawing. We repeated the same loop until the system started surprising us: <span class="about-highlight pink">expand</span>, <span class="about-highlight teal">simplify</span>, <span class="about-highlight warm">balance</span>. When you work by hand, the work carries your personality. When you work generatively, the system develops one of its own.
                </div>
            </div>
                </div>

                <div class="about-sections-col">
                    <div class="about-section" data-section="color">
                        <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                            <span class="about-section-title">Color as Time + Energy</span>
                            <span class="about-section-arrow">â–¼</span>
                        </div>
                        <div class="about-section-content">
                            Layer upon layer of color builds the illusion of time passing. <span class="about-highlight purple">112 palettes</span> capture every hour, from <span class="about-highlight warm">quiet dawn</span> to <span class="about-highlight teal">electric midnight</span>. Each City carries one of four energies: <strong>Rising</strong>, <strong>Living</strong>, <strong>Fading</strong>, or <strong>Resting</strong>. We wanted to reflect the full range of light experienced in real cities. Rare palettes mirror rare moments: a sunset over the river is a special find, just as it would be in life.
                        </div>
                    </div>

                    <div class="about-section" data-section="grid">
                        <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                            <span class="about-section-title">Find Your Grid</span>
                            <span class="about-section-arrow">â–¼</span>
                        </div>
                        <div class="about-section-content">
                            <p style="margin-bottom: 16px;">Each of the 112 palettes belongs to one of four energy groups. Collectors build grids around these energies.</p>

                            <div class="about-set-types">
                                <div class="about-set-type">
                                    <span class="about-set-icon">â˜€ï¸</span>
                                    <div class="about-set-info">
                                        <span class="about-set-name">Rising</span>
                                        <span class="about-set-desc">Morning light</span>
                                    </div>
                                </div>
                                <div class="about-set-type">
                                    <span class="about-set-icon">ðŸ™ï¸</span>
                                    <div class="about-set-info">
                                        <span class="about-set-name">Living</span>
                                        <span class="about-set-desc">Daytime</span>
                                    </div>
                                </div>
                                <div class="about-set-type">
                                    <span class="about-set-icon">ðŸŒ†</span>
                                    <div class="about-set-info">
                                        <span class="about-set-name">Fading</span>
                                        <span class="about-set-desc">Dusk and evening</span>
                                    </div>
                                </div>
                                <div class="about-set-type">
                                    <span class="about-set-icon">ðŸŒƒ</span>
                                    <div class="about-set-info">
                                        <span class="about-set-name">Resting</span>
                                        <span class="about-set-desc">Night</span>
                                    </div>
                                </div>
                                <div class="about-set-type">
                                    <span class="about-set-icon">âš¡ï¸</span>
                                    <div class="about-set-info">
                                        <span class="about-set-name">Energy Set âš¡ï¸</span>
                                        <span class="about-set-desc">One from each group</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="about-section" data-section="benefits">
                        <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                            <span class="about-section-title">Collector Benefits</span>
                            <span class="about-section-arrow">â–¼</span>
                        </div>
                        <div class="about-section-content">
                            <p style="margin-bottom: 12px;"><strong style="color: var(--text);">1 City</strong> <span style="color: var(--text-dim);">â†’ Allow list or early access spot on the upcoming project, *****</span></p>
                            <p style="margin-bottom: 12px;"><strong style="color: var(--text);">4 Cities</strong> <span style="color: var(--text-dim);">â†’ 1/1 airdrop of Efdot's upcoming project, *****</span></p>
                            <p style="margin-bottom: 12px;"><strong style="color: var(--text);">8 Cities</strong> <span style="color: var(--text-dim);">â†’ 2 airdrops + a commission from Efdot</span></p>
                        </div>
                    </div>

                    <div class="about-section" data-section="thanks">
                        <div class="about-section-header" onclick="this.closest('.about-section').classList.toggle('open'); event.stopPropagation();">
                            <span class="about-section-title">Special Thanks</span>
                            <span class="about-section-arrow">â–¼</span>
                        </div>
                        <div class="about-section-content">
                            <p>To every collector who believed in this project while it was still being built: thank you. Your early support gave us the confidence to keep pushing, experimenting, and refining. The streets are brighter because of you.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="about-collab-cta">
                <div class="about-collab-title">Be Part of It</div>
                <div class="about-collab-desc">Have a wall, a city, or an idea? Murals, prints, editions, and community projects happen through conversation.</div>
                <button class="about-collab-btn" onclick="this.style.display='none'; this.closest('.about-collab-cta').querySelector('.say-hey-form').style.display='flex';">Say Hey â†’</button>
                <div class="say-hey-form">
                    <input type="text" placeholder="Your name" class="say-hey-input">
                    <input type="email" placeholder="Your email" class="say-hey-input">
                    <textarea placeholder="What's on your mind?" class="say-hey-input say-hey-textarea"></textarea>
                    <button class="say-hey-submit" onclick="submitSayHey(this)">Send â†’</button>
                </div>
                <div class="say-hey-success" style="display: none;">Sent! We'll be in touch.</div>
            </div>

            <div class="about-footer">
                <div class="about-stats" id="aboutStats">
                    <span class="about-stat"><strong id="aboutMintedCount">320</strong>/500 collected</span>
                    <span class="about-stat-sep">Â·</span>
                    <span class="about-stat"><strong id="aboutCollectorCount">â€”</strong> collectors</span>
                    <span class="about-stat-sep">Â·</span>
                    <span class="about-stat"><strong>112</strong> palettes</span>
                </div>
                <div class="about-buttons">
                    <div class="collect-btn-wrapper">
                        <button class="about-mint-btn" id="aboutMintBtn" onclick="toggleCollectPopover(this)"><span class="collect-seg cs-1"></span><span class="collect-seg cs-2"></span><span class="collect-seg cs-3"></span><span class="collect-seg cs-4"></span><span class="collect-seg cs-5"></span></button>
                        <div class="collect-popover" id="collectPopoverAbout">
                            <a href="https://www.artblocks.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Get with ETH <span>Art Blocks</span></a>
                            <a href="https://shop.efdotstudio.com/collections/cities-collection/products/cities-1-1-500" target="_blank" class="collect-popover-option">Buy with Card <span>Efdot Shop</span></a>
                            <a href="https://opensea.io/collection/cities-by-efdot-x-diid" target="_blank" class="collect-popover-option">Browse Marketplace <span>OpenSea</span></a>
                        </div>
                    </div>
                </div>
                <div class="about-countdown" id="aboutCountdown">
                    <div class="countdown-cells">
                        <div class="countdown-cell"><span class="countdown-value" id="countdownDays">49</span><span class="countdown-label">days</span></div>
                        <div class="countdown-cell"><span class="countdown-value" id="countdownHours">06</span><span class="countdown-label">hrs</span></div>
                        <div class="countdown-cell"><span class="countdown-value" id="countdownMins">51</span><span class="countdown-label">min</span></div>
                        <div class="countdown-cell"><span class="countdown-value" id="countdownSecs">00</span><span class="countdown-label">sec</span></div>
                    </div>
                </div>
                <div class="about-newsletter" style="margin-top: 24px;">
                    <script async data-uid="95cd1fc649" src="https://efdot-studio.kit.com/95cd1fc649/index.js"></script>
                </div>
            </div>
        </div>
    </div>

    <!-- Origins Timeline -->
    <div class="timeline-view" id="timelineView">
        <nav class="timeline-year-nav" id="timelineYearNav">
            <a class="timeline-year-nav-item" data-year="2019">2019</a>
            <a class="timeline-year-nav-item" data-year="2020">2020</a>
            <a class="timeline-year-nav-item" data-year="2021">2021</a>
            <a class="timeline-year-nav-item" data-year="2022">2022</a>
            <a class="timeline-year-nav-item" data-year="2023">2023</a>
            <a class="timeline-year-nav-item" data-year="2024">2024</a>
            <a class="timeline-year-nav-item" data-year="2025">2025</a>
        </nav>
        <button class="timeline-grid-btn" id="timelineGridBtn">â–¦</button>
        <button class="timeline-close" id="timelineClose">&times;</button>
        <div class="timeline-header">
            <h1 class="timeline-logo">Cities</h1>
            <p class="timeline-tagline">From <em>hand</em> to <em>code</em></p>
            <p class="timeline-collab">Art by <a href="https://efdotstudio.com" target="_blank">Efdot</a> Â· 2019â€“2025</p>
        </div>
        <div class="timeline-container">
            <div class="timeline-line"></div>
            <div class="timeline-content">
                <!-- 2019: Physical Origins - Grouped Murals -->
                <div class="timeline-year" data-year="2019">2019</div>
                <div class="timeline-story">The aerial view becomes a canvas. Paint on walls, cities from above.</div>

                <div class="timeline-group">
                    <div class="timeline-group-title">Early Murals</div>
                    <div class="timeline-group-grid cols-3 murals-grid">
                        <div class="timeline-group-item mural-crop" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeihcmhw3utkt54cs4ewcdjvhouhcwce7irzltfnlq5sdjmoc7ubnpy" data-link="https://www.efdotstudio.com/murals" data-title="USA Network Mural" data-year="2019">
                            <div class="timeline-group-item-img">
                                <img src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeihcmhw3utkt54cs4ewcdjvhouhcwce7irzltfnlq5sdjmoc7ubnpy" alt="USA Network Mural">
                            </div>
                        </div>
                        <div class="timeline-group-item mural-crop" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiejzkb765kebuqllnykyturac7mtt2l3i45te26srbkrjvjdm273y" data-link="https://www.efdotstudio.com/murals" data-title="The Hall Mural" data-year="2019">
                            <div class="timeline-group-item-img">
                                <img src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiejzkb765kebuqllnykyturac7mtt2l3i45te26srbkrjvjdm273y" alt="The Hall Mural">
                            </div>
                        </div>
                        <div class="timeline-group-item mural-crop" data-img="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1578595775517-UEPOPTM1UYQAGIP68ADJ/muros-mural-web.jpg" data-link="https://www.efdotstudio.com/murals" data-title="SoNo Collection Mural" data-year="2019">
                            <div class="timeline-group-item-img">
                                <img src="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1578595775517-UEPOPTM1UYQAGIP68ADJ/muros-mural-web.jpg" alt="SoNo Collection Mural">
                            </div>
                        </div>
                    </div>
                    <div class="timeline-group-collectors">NYC Â· DC Â· Norwalk</div>
                </div>

                <!-- 2020: Open Minds - Grouped -->
                <div class="timeline-year" data-year="2020">2020</div>
                <div class="timeline-story">First digital cities. Hand-drawn, frame by frame. Every line placed by choice.</div>

                <div class="timeline-group">
                    <div class="timeline-group-title">Open Minds</div>
                    <div class="timeline-group-subtitle">What does the mind see,<br>as it expands and connects the dots?<br>Hand-drawn lines, frame by frame,<br>finding beauty in the spaces between.</div>
                    <div class="timeline-group-grid cols-2 openminds-grid">
                        <div class="timeline-group-item" data-img="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128130116-DDEYOHRNG1IRBEEXG1JD/Efdot_Open+Mind+1_You+Are+Here.gif" data-link="https://opensea.io/collection/efdot-openminds" data-title="You Are Here" data-year="2020">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128130116-DDEYOHRNG1IRBEEXG1JD/Efdot_Open+Mind+1_You+Are+Here.gif" alt="You Are Here">
                            </div>
                        </div>
                        <div class="timeline-group-item" data-img="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128174409-8EGQR3U2UDYK7SK91Z19/Efdot_Open+Mind+2_Night+Mode.gif" data-link="https://opensea.io/collection/efdot-openminds" data-title="Night Mode" data-year="2020">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128174409-8EGQR3U2UDYK7SK91Z19/Efdot_Open+Mind+2_Night+Mode.gif" alt="Night Mode">
                            </div>
                        </div>
                        <div class="timeline-group-item" data-img="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128270023-9JC2N4SS09UHMA4LR5NN/Efdot_Open+Minds+3_Passing+Through.gif" data-link="https://opensea.io/collection/efdot-openminds" data-title="Passing Through" data-year="2020">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128270023-9JC2N4SS09UHMA4LR5NN/Efdot_Open+Minds+3_Passing+Through.gif" alt="Passing Through">
                            </div>
                        </div>
                        <div class="timeline-group-item" data-img="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128443026-X974A5CT72RIUD8KFZY7/Efdot_Open+Minds+6_Sweet+Streets.gif" data-link="https://opensea.io/collection/efdot-openminds" data-title="Sweet Streets" data-year="2020">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128443026-X974A5CT72RIUD8KFZY7/Efdot_Open+Minds+6_Sweet+Streets.gif" alt="Sweet Streets">
                            </div>
                        </div>
                    </div>
                    <div class="timeline-group-collectors">Collected by Sighduck Â· Valdi Â· Fin444 Â· AMT Collections</div>
                </div>

                <!-- 2021: O.M.A.G.E. & Efdot Lab -->
                <div class="timeline-year" data-year="2021">2021</div>
                <div class="timeline-story">The turning point. Hand-drawn layers become a rules-based system. Same hand, new process.</div>

                <div class="timeline-item featured" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiek2l25mxxsd54ptgtmnlmr4gsd4tgtd7nnee3uckh4hn3zdb52ce" data-title="O.M.A.G.E." data-year="2021" data-link="https://opensea.io/collection/efdot-openminds">
                    <img loading="lazy" src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiek2l25mxxsd54ptgtmnlmr4gsd4tgtd7nnee3uckh4hn3zdb52ce" alt="O.M.A.G.E.">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">O.M.A.G.E.</span>
                        <span class="timeline-item-year">2021 Â· Open Minds Analog Generative Experiment</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">Where it all shifted. Hand-drawn layers stacked by rules, not random. Still analog, but thinking in probabilities, rules and physics. Screen print series.</span>
                        </div>
                        <a href="#" onclick="openOmageInquiry(); return false;" class="timeline-inquiry-link">Inquire about O.M.A.G.E. â†’</a>
                    </div>
                </div>

                <div class="timeline-group">
                    <div class="timeline-group-grid cols-2">
                        <div class="timeline-group-item" data-img="https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/1/nft.jpg?auto=format%2Ccompress&q=90&cs=srgb&h=3000&w=3000&fnd_key=v1" data-link="https://foundation.app/mint/eth/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/1" data-title="Summer 365" data-year="2021">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/1/nft.jpg?auto=format%2Ccompress&q=90&cs=srgb&h=3000&w=3000&fnd_key=v1" alt="Summer 365">
                            </div>
                            <div class="timeline-group-item-info">
                                <span class="timeline-group-item-title">Summer 365</span>
                            </div>
                        </div>
                        <div class="timeline-group-item" data-img="https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/2/nft.jpg?auto=format%2Ccompress&q=70&cs=srgb&h=1200&w=1200&fnd_key=v1" data-link="https://foundation.app/mint/eth/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/2" data-title="Winterplay" data-year="2021">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/2/nft.jpg?auto=format%2Ccompress&q=70&cs=srgb&h=1200&w=1200&fnd_key=v1" alt="Winterplay">
                            </div>
                            <div class="timeline-group-item-info">
                                <span class="timeline-group-item-title">Winterplay</span>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-group-collectors">Collected by 0x17Bf...072B Â· Coinbilly</div>
                </div>

                <!-- 2022 -->
                <div class="timeline-year" data-year="2022">2022</div>
                <div class="timeline-story">The grid gets an eye. Cities start looking back to history and forward to a greater form.</div>

                <div class="timeline-item featured" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiga6qzupgcz3joz3jdywwyk2fuzc2jukmohfij5tzs44rw5rzhqba" data-title="Eye of the City" data-year="2022" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/22">
                    <img loading="lazy" src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiga6qzupgcz3joz3jdywwyk2fuzc2jukmohfij5tzs44rw5rzhqba" alt="Eye of the City">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Eye of the City</span>
                        <span class="timeline-item-year">2022</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">Urban observations frozen in motion. A reflection of simplicity and chaos. Created live at The Gateway, Miami during Art Basel 2022.</span>
                        </div>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/22" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Reginald de la Grarbs</span>
                        </div>
                    </div>
                </div>

                <!-- Two Bridges -->
                <div class="timeline-item hero-center" data-img="https://ipfs.io/ipfs/bafybeidjajtk5byo2cg7ipid24lywtlqcnlnnkcztmfk3mu7fnqtwavaji" data-title="Two Bridges" data-year="2022" data-link="https://opensea.io/item/ethereum/0xc80d40e86c91dc4a713c5e2e9d8fc47c6b6a68fd/181000100001">
                    <img loading="lazy" src="https://ipfs.io/ipfs/bafybeidjajtk5byo2cg7ipid24lywtlqcnlnnkcztmfk3mu7fnqtwavaji" alt="Two Bridges">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Two Bridges</span>
                        <span class="timeline-item-year">2022 Â· Edition of 10</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">Changes color with the seasons.</span>
                        </div>
                    </div>
                </div>

                <!-- Light Pulp -->
                <div class="timeline-item featured" data-img="https://nft-cdn.alchemy.com/eth-mainnet/24cacdfcf8625283c2cd21244136ae80" data-title="Light Pulp" data-year="2022" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/17">
                    <img loading="lazy" src="https://nft-cdn.alchemy.com/eth-mainnet/24cacdfcf8625283c2cd21244136ae80" alt="Light Pulp">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Light Pulp</span>
                        <span class="timeline-item-year">2022</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/17" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Easp0rts</span>
                        </div>
                    </div>
                </div>

                <!-- Pair: Midnight in Manhattan + Hazy Day -->
                <div class="timeline-group midnight-hazy-group">
                    <div class="timeline-group-grid cols-2">
                        <div class="timeline-group-item" data-img="https://arweave.net/dUzBTD-4kZZHEITC_6HEWrHb4HzIxKzslAEeLznkHRQ" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/27" data-title="Midnight In Manhattan" data-year="2022">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://arweave.net/dUzBTD-4kZZHEITC_6HEWrHb4HzIxKzslAEeLznkHRQ" alt="Midnight In Manhattan">
                            </div>
                            <div class="timeline-group-item-info">
                                <span class="timeline-group-item-title">Midnight In Manhattan</span>
                                <span class="timeline-group-item-year">2022</span>
                            </div>
                        </div>
                        <div class="timeline-group-item" data-img="https://arweave.net/hEokztJ9b7fxAtGf1eiwi2QRWkMY5F8UlJOa0rlHqag" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/28" data-title="Hazy Day" data-year="2022">
                            <div class="timeline-group-item-img">
                                <img loading="lazy" src="https://arweave.net/hEokztJ9b7fxAtGf1eiwi2QRWkMY5F8UlJOa0rlHqag" alt="Hazy Day">
                            </div>
                            <div class="timeline-group-item-info">
                                <span class="timeline-group-item-title">Hazy Day</span>
                                <span class="timeline-group-item-year">2022</span>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-group-collectors">Collected by Sendrock Â· Cosimo Medici</div>
                </div>

                <!-- 2023 -->
                <div class="timeline-year" data-year="2023">2023</div>
                <div class="timeline-story">Color pushing boundaries. Blue fogs, yellow traffic, purple&nbsp;rounds. Generative experiments begin with&nbsp;Diid.</div>

                <!-- Luminosity -->
                <div class="timeline-item featured" data-img="https://e7bvegr35i4w3uqygtu2op3rwjaglmdnrovpbvwg6j66wh2a7mvq.arweave.net/J8NSGjvqOW3SGDTppz9xskBlsG2LqvDWxvJ96x9A-ys" data-title="Luminosity" data-year="2023" data-link="https://foundation.app/mint/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/23">
                    <img loading="lazy" src="https://e7bvegr35i4w3uqygtu2op3rwjaglmdnrovpbvwg6j66wh2a7mvq.arweave.net/J8NSGjvqOW3SGDTppz9xskBlsG2LqvDWxvJ96x9A-ys" alt="Luminosity">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Luminosity</span>
                        <span class="timeline-item-year">2023</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://foundation.app/mint/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/23" target="_blank" title="View on Foundation">âŸ</a> <span class="provenance-name">0x17Bf...072B</span>
                        </div>
                    </div>
                </div>

                <!-- Street View -->
                <div class="timeline-item right" data-img="https://arweave.net/pk00hY7LdV6c8q6l3OiVP6GSRYG-Sx_KeDIearNK878" data-title="Street View" data-year="2023" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/29">
                    <img loading="lazy" src="https://arweave.net/pk00hY7LdV6c8q6l3OiVP6GSRYG-Sx_KeDIearNK878" alt="Street View">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Street View</span>
                        <span class="timeline-item-year">2023</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/29" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Diid</span>
                        </div>
                    </div>
                </div>

                <!-- Brain Fog -->
                <div class="timeline-item left available" data-img="https://arweave.net/cTSB-Acjliv_eqJqlWFtsbNB5Wpwwr_j-ck1cshWaTk" data-title="Brain Fog" data-year="2023" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/31">
                    <img loading="lazy" src="https://arweave.net/cTSB-Acjliv_eqJqlWFtsbNB5Wpwwr_j-ck1cshWaTk" alt="Brain Fog">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Brain Fog</span>
                        <span class="timeline-item-year">2023 Â· Available</span>
                    </div>
                </div>

                <!-- Traffic on the Avenue -->
                <div class="timeline-item right" data-img="https://arweave.net/3Hlm3Mo0by9mqa7H2hH6TT4ioB0vI1LaVgWXD61Addk" data-title="Traffic on the Avenue" data-year="2023" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/33">
                    <img loading="lazy" src="https://arweave.net/3Hlm3Mo0by9mqa7H2hH6TT4ioB0vI1LaVgWXD61Addk" alt="Traffic on the Avenue">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Traffic on the Avenue</span>
                        <span class="timeline-item-year">2023</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/0x822f1418072e15e1d1f07533138b35a72a8a0f55/33" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Redbeard</span>
                        </div>
                    </div>
                </div>

                <!-- Roundabout -->
                <div class="timeline-item left" data-img="https://arweave.net/6ucEGXVGd9S5s2f9fnIEQqUc4-X0zCnuUD-_XNwpsVM" data-title="Roundabout" data-year="2023" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/34">
                    <img loading="lazy" src="https://arweave.net/6ucEGXVGd9S5s2f9fnIEQqUc4-X0zCnuUD-_XNwpsVM" alt="Roundabout">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Roundabout</span>
                        <span class="timeline-item-year">2023</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/0x822f1418072e15e1d1f07533138b35a72a8a0f55/34" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Paperbuddha</span>
                        </div>
                    </div>
                </div>

                <!-- 2024 -->
                <div class="timeline-year" data-year="2024">2024</div>
                <div class="timeline-story">The linework sharpens, the palettes expand.</div>

                <!-- Silent Skyline -->
                <div class="timeline-item right" data-img="https://arweave.net/qEiCFd9Y3U0UAE63z3sCZkmDDlZ1sKKQgkzQWZQkJBg" data-title="Silent Skyline" data-year="2024" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/36">
                    <img loading="lazy" src="https://arweave.net/qEiCFd9Y3U0UAE63z3sCZkmDDlZ1sKKQgkzQWZQkJBg" alt="Silent Skyline">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Silent Skyline</span>
                        <span class="timeline-item-year">2024</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/36" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Blondie</span>
                        </div>
                    </div>
                </div>

                <!-- Standalone: Vibrancy -->
                <div class="timeline-item featured" data-img="https://arweave.net/QovS8UL0HHe8Cex0owceng4YdWhW08gMm_zg-Jzx7dY" data-title="Vibrancy" data-year="2024" data-link="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/42">
                    <img loading="lazy" src="https://arweave.net/QovS8UL0HHe8Cex0owceng4YdWhW08gMm_zg-Jzx7dY" alt="Vibrancy">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Vibrancy</span>
                        <span class="timeline-item-year">2024</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">The introduction of glyph lines. A new layer of language woven into the grid.</span>
                        </div>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/42" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Batsoupyum</span>
                        </div>
                    </div>
                </div>

                <!-- Standalone: Over the Bridge -->
                <div class="timeline-item left over-the-bridge-item" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/Qmdo2hzEGfXV6Ep3A2K8KHK7mg4XVUvKMbDG4Xu2Pj8LB2" data-title="Over the Bridge" data-year="2024" data-link="https://opensea.io/item/ethereum/0xdb1f952239c6e89af76dd1226e7cb1fa57463e5e/127">
                    <div class="over-bridge-img-container">
                        <img loading="lazy" src="https://blush-worried-heron-358.mypinata.cloud/ipfs/Qmdo2hzEGfXV6Ep3A2K8KHK7mg4XVUvKMbDG4Xu2Pj8LB2" alt="Over the Bridge" class="over-bridge-static">
                        <img loading="lazy" src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiacjsh45e2uduoi2odkp4ldy4z5wxu2za3cgzwoyonscgudx75u3i" alt="Over the Bridge Animation" class="over-bridge-animated">
                    </div>
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Over the Bridge</span>
                        <span class="timeline-item-year">2024 Â· Mural Edition of 50</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">Painted in Georgia, USA at a wellness festival.</span>
                        </div>
                    </div>
                </div>

                <!-- Standalone: City in Bloom -->
                <div class="timeline-item right" data-img="https://nft-cdn.alchemy.com/eth-mainnet/bf524597b88d4936737d66df0ba5f368" data-title="City in Bloom" data-year="2024" data-link="https://superrare.com/artwork/eth/0x51650bf8cda4d93b00dbfa97f65aba14a82b2a9e/1">
                    <img loading="lazy" src="https://nft-cdn.alchemy.com/eth-mainnet/bf524597b88d4936737d66df0ba5f368" alt="City in Bloom">
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">City in Bloom</span>
                        <span class="timeline-item-year">2024 Â· Rio de Janeiro</span>
                        <div class="timeline-desc-wrapper">
                            <button class="timeline-more-btn">more</button>
                            <span class="timeline-item-desc">Wall to screen. A Rio mural turned digital.</span>
                        </div>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://superrare.com/artwork/eth/0x51650bf8cda4d93b00dbfa97f65aba14a82b2a9e/1" target="_blank" title="View on SuperRare">âŸ</a> <span class="provenance-name">Alex Zuttre</span>
                        </div>
                    </div>
                </div>

                <!-- 2025 -->
                <div class="timeline-year" data-year="2025">2025</div>
                <div class="timeline-story">Italy. Nine cities, one collection. The grid crosses the Atlantic.</div>

                <div class="timeline-item center italy" data-title="Cities // Italy" data-link="https://citiesitaly.ninfa.io/">
                    <div class="timeline-italy-grid">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/c8330669474b599172d9caf56c186cb5d60a1483ae7a114734313a20ca8b8df1.jpeg" alt="Echo Hill">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/ea9a2b42ef67db20ce7fb63c592e9f75036e874df9ea593835384ede046be449.jpeg" alt="Around the Duomo">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/e9ff95e5215d28b765cabcb3b2360520266c86d74683b7ecaa59630f5e0db086.jpeg" alt="Through The Piazza">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/c16d801ae69e5ed00046d63b8ed30be387e477297a62767d1178f142add4a31b.jpeg" alt="Shifted Shadow">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/ed64013129837544d5fe74e63f414a6c74fee743b95f9e5223e911ac0303a476.jpeg" alt="Last Lap">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/a2cc2905f3f49f56757890038b3cf715bcc4139a05660b378f43b4fa9c93b9af.jpeg" alt="Radial Intent">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/d3ca7d2aa862e1ff132864f703c8680d1038bc470c279db28909cbaa0c8c79ad.jpeg" alt="Across the Arno">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/fa42a57fcc480226220ec5cf90dd1a6b58a567ccf49b52f35c9ee91170498a63.jpeg" alt="Drawn To Center">
                        <img loading="lazy" src="https://images.ninfa.io/nfts/original/f9bd77a279884e9b4ed1edeaa8f213cec0f8c210a4558eb2f6c01c021f540200.jpeg" alt="Walled Memory">
                    </div>
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Cities // Italy</span>
                        <span class="timeline-item-year">2025 Â· 9 Connected Pieces</span>
                        <div class="timeline-item-actions-inline">
                            <a class="timeline-action-inline share-btn" href="#" title="Share on X">ð•</a>
                        </div>
                        <div class="timeline-italy-collectors">Collected by: Soren Wrenn Â· BatSoupYum Â· M Studio Â· Almost Serious Gallery Â· Georgie Â· R Alderman</div>
                    </div>
                </div>

                <!-- Generative Collection -->
                <!-- Video before the collection -->
                <div class="timeline-video-section">
                    <iframe id="timelineVimeoPlayer" src="https://player.vimeo.com/video/1162260399?title=0&byline=0&portrait=0&dnt=1&autoplay=1&muted=1&loop=1&background=1" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe>
                    <div class="video-controls">
                        <button class="video-control-btn" id="videoPlayPauseBtn" title="Play/Pause">
                            <span class="play-icon">â–¶</span>
                        </button>
                        <button class="video-control-btn" id="videoVolumeBtn" title="Volume">
                            <span class="volume-icon">ðŸ”‡</span>
                            <span class="volume-indicator">Muted</span>
                        </button>
                    </div>
                </div>

                <div class="timeline-item center culmination">
                    <div class="timeline-culmination">
                        <div class="timeline-culmination-title">Cities by Efdot x Diid</div>
                        <div class="timeline-culmination-subtitle">June 2025 Â· Art Blocks Curated</div>
                        <div class="timeline-culmination-desc">500 generative outputs built with Diid, who translated the system into code. Three years of 1/1s distilled into an algorithm.</div>
                        <div class="timeline-preview-grid" id="timelinePreviewGrid"></div>
                        <a href="https://www.artblocks.io/marketplace/collections/cities-by-efdot-x-diid" target="_blank" class="timeline-culmination-btn timeline-mint-btn">
                            <span class="mint-text">Explore Collection</span>
                            <span class="mint-animation"></span>
                        </a>
                    </div>
                </div>

                <!-- Desert Grid - Cities // Marfa (dynamic day/night states) -->
                <div class="timeline-item desert-grid-dual" data-img="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeigq7rytbitvgnmil3i5h3tqvekqcw5f2z4zy5pzfjcbk5dtnbc2yy" data-title="Desert Grid" data-year="2025" data-link="https://opensea.io/item/ethereum/0x10abb881add1de70d4a9b2c712b9a8ac8853418b/4">
                    <div class="desert-grid-container">
                        <img src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeigq7rytbitvgnmil3i5h3tqvekqcw5f2z4zy5pzfjcbk5dtnbc2yy" alt="Desert Grid (Day)" class="desert-day">
                        <img src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeibnhgcanareovbbvcferkkwbgf7lb4y55tkbjev4lozqd5imhrfo4" alt="Desert Grid (Night)" class="desert-night">
                    </div>
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Desert Grid</span>
                        <span class="timeline-item-year">2025 Â· Cities // Marfa</span>
                        <div class="timeline-provenance">
                            <a class="provenance-link" href="https://opensea.io/item/ethereum/0x10abb881add1de70d4a9b2c712b9a8ac8853418b/4" target="_blank" title="View on OpenSea">âŸ</a> <span class="provenance-name">Norcal & Klutch</span>
                        </div>
                    </div>
                    <span class="desert-grid-hint">Day / Night</span>
                </div>

                <!-- Cities in Marfa - Community Mural Video -->
                <div class="timeline-item center marfa-video-section">
                    <div class="marfa-video-container">
                        <iframe id="marfaVimeoPlayer" src="https://player.vimeo.com/video/1162644907?title=0&byline=0&portrait=0&dnt=1" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe>
                    </div>
                    <div class="marfa-video-controls">
                        <button class="marfa-control-btn" id="marfaPlayPauseBtn" title="Play/Pause">
                            <span class="play-icon">â–¶</span>
                            <span class="pause-icon" style="display:none;">âšâš</span>
                        </button>
                        <button class="marfa-control-btn" id="marfaMuteBtn" title="Mute/Unmute">
                            <span class="unmuted-icon">ðŸ”Š</span>
                            <span class="muted-icon" style="display:none;">ðŸ”‡</span>
                        </button>
                    </div>
                    <div class="timeline-item-info">
                        <span class="timeline-item-title">Cities in Marfa</span>
                        <span class="timeline-item-year">2025 Â· Community Mural</span>
                    </div>
                </div>

                <!-- What City Next? -->
                <div class="timeline-item center whats-next-section">
                    <div class="whats-next">
                        <div class="whats-next-title">What City Next?</div>
                        <div class="whats-next-desc">Have a wall, a city, or an idea? Murals, editions, and community projects happen through conversation.</div>
                        <button class="whats-next-btn" onclick="this.style.display='none'; this.closest('.whats-next').querySelector('.say-hey-form').style.display='flex';">Say Hey â†’</button>
                        <div class="say-hey-form">
                            <input type="text" placeholder="Your name" class="say-hey-input">
                            <input type="email" placeholder="Your email" class="say-hey-input">
                            <textarea placeholder="What's on your mind?" class="say-hey-input say-hey-textarea"></textarea>
                            <button class="say-hey-submit" onclick="submitSayHey(this)">Send â†’</button>
                        </div>
                        <div class="say-hey-success" style="display: none;">Sent! We'll be in touch.</div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Explore More Section -->
        <div class="timeline-explore-more">
            <h3 class="timeline-explore-headline">Continue Exploring</h3>
            <div class="timeline-explore-grid">
                <button class="timeline-explore-btn" id="exploreGridBtn">
                    <span class="explore-btn-icon">â—«</span>
                    <span class="explore-btn-label">Browse Palettes</span>
                    <span class="explore-btn-desc">112 unique color combinations</span>
                </button>
                <button class="timeline-explore-btn" id="exploreCollectorsBtn">
                    <span class="explore-btn-icon">â—‰</span>
                    <span class="explore-btn-label">Collector Grids</span>
                    <span class="explore-btn-desc">See who's building collections</span>
                </button>
                <button class="timeline-explore-btn" id="exploreOriginsBtn">
                    <span class="explore-btn-icon">âœ¦</span>
                    <span class="explore-btn-label">Past Chapters</span>
                    <span class="explore-btn-desc">Origins & 1/1s</span>
                </button>
                <a href="https://www.artblocks.io/collection/cities-by-efdot-x-diid" target="_blank" class="timeline-explore-btn">
                    <span class="explore-btn-icon">â–²</span>
                    <span class="explore-btn-label">Get on Art Blocks</span>
                    <span class="explore-btn-desc">Join the collection</span>
                </a>
            </div>
        </div>

    </div>

    <!-- Origins Lightbox -->
    <!-- Timeline Zoom View -->
    <div class="timeline-zoom" id="timelineZoom">
        <button class="timeline-zoom-close" id="timelineZoomClose">&times;</button>
        <div class="timeline-zoom-actions" id="timelineZoomActions">
            <button class="timeline-zoom-action-btn" id="zoomShareBtn" title="Share">â†—</button>
            <button class="timeline-zoom-action-btn" id="zoomDownloadBtn" title="Save">â†“</button>
            <button class="timeline-zoom-action-btn loupe-btn" id="loupeBtn" title="Magnify">ðŸ”</button>
        </div>
        <!-- Magnifying Loupe -->
        <div class="loupe" id="loupe">
            <div class="loupe-inner" id="loupeInner"></div>
            <div class="loupe-crosshair"></div>
            <div class="loupe-zoom-label">3Ã—</div>
        </div>
        <button class="timeline-zoom-nav prev" id="timelineZoomPrev">â€¹</button>
        <button class="timeline-zoom-nav next" id="timelineZoomNext">â€º</button>
        <div class="timeline-zoom-main">
            <img src="" alt="" class="timeline-zoom-artwork" id="timelineZoomArtwork">
            <div class="timeline-zoom-info">
                <div class="timeline-zoom-title" id="timelineZoomTitle"></div>
                <div class="timeline-zoom-year" id="timelineZoomYear"></div>
                <div class="timeline-zoom-desc" id="timelineZoomDesc"></div>
                <div class="timeline-zoom-provenance" id="timelineZoomProvenance"></div>
                <div class="timeline-zoom-buttons">
                    <a class="timeline-zoom-print-btn" id="timelineZoomPrint" href="#" target="_blank">ðŸ–¼ Print Available</a>
                    <a class="timeline-zoom-offer-btn" id="timelineZoomOffer" href="#" target="_blank">Make Offer</a>
                </div>
            </div>
        </div>
        <div class="timeline-zoom-strip" id="timelineZoomStrip"></div>
    </div>

    <!-- Italy Gallery View -->
    <div class="italy-gallery" id="italyGallery">
        <div class="italy-gallery-header">
            <h2 class="italy-gallery-title">Cities // Italy</h2>
            <p class="italy-gallery-subtitle">2025 Â· 9 Connected Pieces</p>
        </div>
        <div class="italy-gallery-grid" id="italyGalleryGrid">
            <!-- Populated by JS -->
        </div>
        <div style="text-align: center; padding-bottom: 60px;">
            <a href="https://citiesitaly.ninfa.io/" target="_blank" class="italy-gallery-link">View on Ninfa â†’</a>
        </div>
    </div>

    <!-- Timeline Framed View -->
    <div class="timeline-frame" id="timelineFrame">
        <div class="timeline-frame-content">
            <div class="timeline-frame-wrapper">
                <div class="timeline-frame-inner">
                    <img id="timelineFrameImage" src="" alt="">
                </div>
            </div>
            <div class="timeline-frame-info">
                <div class="timeline-frame-title" id="timelineFrameTitle"></div>
                <div class="timeline-frame-year" id="timelineFrameYear"></div>
            </div>
        </div>
        <button class="timeline-frame-mode" id="timelineFrameMode" title="Toggle light/dark">â˜¾</button>
        <button class="timeline-frame-nav prev" id="timelineFramePrev" title="Previous">â€¹</button>
        <button class="timeline-frame-nav next" id="timelineFrameNext" title="Next">â€º</button>
        <button class="timeline-frame-close" id="timelineFrameClose">Ã—</button>
        <button class="timeline-frame-view-btn" id="timelineFrameViewBtn">View Artwork â†’</button>
    </div>

    <!-- Origins Frame View - Dark gallery wall -->
    <div class="origins-frame" id="originsFrame">
        <div class="origins-frame-content">
            <div class="origins-frame-wrapper" id="originsFrameWrapper">
                <div class="origins-frame-inner">
                    <img id="originsFrameImage" src="" alt="">
                </div>
            </div>
            <div class="origins-frame-info">
                <div class="origins-frame-title" id="originsFrameTitle"></div>
                <div class="origins-frame-year" id="originsFrameYear"></div>
                <div class="origins-frame-collection" id="originsFrameCollection"></div>
            </div>
        </div>
        <button class="origins-frame-nav prev" id="originsFramePrev" title="Previous">â€¹</button>
        <button class="origins-frame-nav next" id="originsFrameNext" title="Next">â€º</button>
        <button class="origins-frame-close" id="originsFrameClose">Ã—</button>
        <div class="origins-frame-hint">Click artwork to view listing</div>
    </div>

    <div class="origins-lightbox" id="originsLightbox">
        <button class="origins-lightbox-close" id="originsLightboxClose">&times;</button>
        <img src="" alt="" class="origins-lightbox-img" id="originsLightboxImg">
        <div class="origins-lightbox-title" id="originsLightboxTitle"></div>
        <div class="origins-lightbox-year" id="originsLightboxYear"></div>
        <div class="origins-lightbox-price" id="originsLightboxPrice"></div>
        <a href="#" target="_blank" class="origins-lightbox-btn" id="originsLightboxBtn">View on SuperRare</a>
    </div>

    <script>
        const CONTRACT = '0x7c78f67700e700b4005c8a3d920a1a99e6004800';
        const GENERATOR = 'https://generator.artblocks.io';
        const MEDIA_BASE = 'https://media-proxy.artblocks.io/1';
        let MAX_TOKEN = 320; // Max token ID (321 minted, 0-indexed) - will be updated from API
        const CACHE_VERSION = 'v1';
        const TRAITS_CACHE_KEY = `cities-traits-${CACHE_VERSION}`;
        const CACHE_EXPIRY = 24 * 60 * 60 * 1000;

        const SIZES = { small: { width: 337, height: 600 }, medium: { width: 450, height: 800 }, large: { width: 540, height: 960 } };

        // Collectors data - will be fetched from API for live updates
        let COLLECTORS_DATA = [];
        // Token IDs owned by project wallets (Efdot, Diid, Deployer, Lost Cities) - excluded from try-mode suggestions
        let PROJECT_WALLET_TOKENS = new Set();

        // Trait counts for grid filtering (moved up for early access)
        const traitCounts = {
            palettes: {},
            times: {},
            zooms: {},
            bounds: {},
            traffic: {},
            lines: {},
            energy: {},
            commute: {},
            transit: {},
            water: {}
        };
        let totalMinted = 0;

        // Multi-select filter state (moved up for early access)
        const gridFilterState = {
            palettes: new Set(),
            times: new Set(),
            energy: new Set(),
            zooms: new Set(),
            bounds: new Set(),
            traffic: new Set()
        };

        // Flag: set to true after loadAllTokenData() completes
        let tokenDataReady = false;

        // Filter state variables (moved up for early access)
        let currentEnergyFilter = null;
        let showingFavoritesOnly = false;
        let gridSortOrder = 'desc'; // default: show newest first
        let gridMode = 'palette';
        let gridPage = 1;
        const gridPageSize = 24;

        // Forward declaration for wall view function (defined later, used by collector gallery)
        let openWallViewFn = null;

        // Wall view state (moved up for early access)
        let wallViewTryMode = false;
        let wallViewTempCities = [];

        // Global name alias mapping - map API names to preferred display names
        // Keys are LOWERCASE for case-insensitive matching
        const NAME_ALIASES = {
            // WillEP variations
            'valisdao': 'WillEP',
            'valisdao2': 'WillEP',
            'valisdao.eth': 'WillEP',
            'willep': 'WillEP',
            'willep.eth': 'WillEP',
            // Oblivion variations
            'nyc': 'Oblivion',
            'nftoblivion': 'Oblivion',
            'oblivionnft': 'Oblivion',
            'oblivionnft.eth': 'Oblivion',
            'oblivion': 'Oblivion',
            // Redbeard variations
            'dr. whet faartz': 'Redbeard',
            'dr whet faartz': 'Redbeard',
            'drwhetfaartz': 'Redbeard',
            'drwhetfaartz.eth': 'Redbeard',
            'redbeardnft': 'Redbeard',
            'redbeardnft.eth': 'Redbeard',
            'redbeard': 'Redbeard',
            // Unnikrishna variations
            'unnikrishna m damodaran': 'Unnikrishna',
            'unnikrishna': 'Unnikrishna',
            'unnikrishna.eth': 'Unnikrishna',
            // Specific ENS aliases
            'bsy.eth': 'BatSoupYum',
            'bsy': 'BatSoupYum',
            'zaz.eth': 'Zanzibar',
            'zaz': 'Zanzibar',
            // Vault.diid -> Diid (combined with main Diid)
            'vault.diid': 'Diid',
            'vault.diid.eth': 'Diid',
            'diid vault': 'Diid',
            // Mrelguapo -> OG
            'mrelguapo': 'OG',
            'mrelguapo.eth': 'OG',
            // hot.yigitduman -> Yigit Duman
            'hot.yigitduman': 'Yigit Duman',
            'hot.yigitduman.eth': 'Yigit Duman',
            // Cosimo.Demedici -> Cosimo De Medici
            'cosimo.demedici': 'Cosimo De Medici',
            'cosimo.demedici.eth': 'Cosimo De Medici',
            // JoellelB.art -> Joelle LB
            'joellelb.art': 'Joelle LB',
            'joellelb.art.eth': 'Joelle LB',
            'joellelb': 'Joelle LB',
            // macbethai -> Macbeth
            'macbethai': 'Macbeth',
            'macbethai.eth': 'Macbeth',
            // danielko -> Daniel Koeth
            'danielko': 'Daniel Koeth',
            'danielko.eth': 'Daniel Koeth',
            // codincowboy -> Codin Cowboy
            'codincowboy': 'Codin Cowboy',
            'codincowboy.eth': 'Codin Cowboy',
            // tortitatrades -> Tortita
            'tortitatrades': 'Tortita',
            'tortitatrades.eth': 'Tortita',
            // ogtheartist -> OG
            'ogtheartist': 'OG',
            'ogtheartist.eth': 'OG',
            'og the artist': 'OG',
            // paperbuddha -> Paper Buddha
            'paperbuddha': 'Paper Buddha',
            'paperbuddha.eth': 'Paper Buddha',
            // soren -> Soren Wrenn
            'soren': 'Soren Wrenn',
            'soren.eth': 'Soren Wrenn',
            // shillrmedia -> SHILLR
            'shillrmedia': 'SHILLR',
            'shillrmedia.eth': 'SHILLR'
        };

        // Function to apply name aliases and clean up ENS names
        function applyNameAlias(name) {
            if (!name) return name;
            const lowerName = name.toLowerCase();
            // Check for specific alias first
            if (NAME_ALIASES[lowerName]) return NAME_ALIASES[lowerName];
            // Remove .eth suffix
            if (name.toLowerCase().endsWith('.eth')) {
                return name.slice(0, -4);
            }
            return name;
        }

        // 10 vastly different Cities palettes for collector pills - randomized on each visit
        const CITIES_PALETTE_SETS = [
            // Set 1: Vibrant mix
            [
                { name: 'Brooklyn', bg: '#03071E', colors: ['#370617', '#DC2F02', '#FFBA08'], text: '#FFBA08' },
                { name: 'Beach Day', bg: '#f1e9d2', colors: ['#5e4f00', '#6F4E37', '#000080'], text: '#5e4f00' },
                { name: 'Bioluminescent', bg: '#1410af', colors: ['#d54981', '#007eff', '#affff7'], text: '#affff7' },
                { name: 'Heat Wave', bg: '#FF9100', colors: ['#da4801', '#FF4800', '#ffffff'], text: '#000' },
                { name: 'Marakata', bg: '#18382A', colors: ['#4FA98D', '#B5FF7B', '#5AE8AC'], text: '#B5FF7B' },
                { name: 'Joyride', bg: '#5b0060', colors: ['#800080', '#A020F0', '#B86BB5'], text: '#B86BB5' },
                { name: 'Blue Hour', bg: '#3856a1', colors: ['#7896e1', '#e0ab73', '#ff6600'], text: '#e0ab73' },
                { name: 'Autumnal', bg: '#f6efd9', colors: ['#f29c6b', '#b01e1e', '#ffcb05'], text: '#b01e1e' },
                { name: 'Cerulean', bg: '#12419a', colors: ['#20e3df', '#da0246', '#ffff1c'], text: '#20e3df' },
                { name: 'Concrete Cone', bg: '#ff5c00', colors: ['#000000', '#e8e0ca', '#f3eee0'], text: '#000' }
            ],
            // Set 2: Moody mix
            [
                { name: 'Midnight', bg: '#151722', colors: ['#6c7fae', '#c1ceea', '#d2e5ff'], text: '#c1ceea' },
                { name: 'Carioca', bg: '#fed2e2', colors: ['#fda1c2', '#251f6c', '#eeee5f'], text: '#251f6c' },
                { name: 'Into The Night', bg: '#0b0f1d', colors: ['#ffcb05', '#ff5f00', '#e54eb4'], text: '#ffcb05' },
                { name: 'Momentary Oasis', bg: '#4C956C', colors: ['#6AA889', '#FFF8F0', '#B7D5C7'], text: '#FFF8F0' },
                { name: 'Fly Solo', bg: '#240c42', colors: ['#59009b', '#f4b621', '#a3f0e8'], text: '#a3f0e8' },
                { name: 'Sunset Blush', bg: '#F47C74', colors: ['#FF5E52', '#FBE1DC', '#A96AFB'], text: '#fff' },
                { name: 'Live Jazz', bg: '#0d1a36', colors: ['#66a3ff', '#FFC400', '#d6f6e0'], text: '#FFC400' },
                { name: 'La Haze', bg: '#ffce46', colors: ['#ed25c8', '#860063', '#5b0000'], text: '#5b0000' },
                { name: 'New Resident', bg: '#1f043a', colors: ['#b858cb', '#12b9f4', '#10dd9c'], text: '#10dd9c' },
                { name: 'Brick Facade', bg: '#bc4a3c', colors: ['#c9c3b9', '#f9f8f7', '#dbd0f1'], text: '#f9f8f7' }
            ],
            // Set 3: Earthy/warm mix
            [
                { name: 'CDMX', bg: '#937159', colors: ['#1b1f3e', '#fdebf1', '#ffcd9f'], text: '#fdebf1' },
                { name: 'Renewal', bg: '#d8efff', colors: ['#32cbff', '#117df6', '#4ab5ff'], text: '#117df6' },
                { name: 'Bodega Run', bg: '#0d2b6d', colors: ['#adcdfe', '#ffcf32', '#edd6fe'], text: '#ffcf32' },
                { name: 'Golden Hum', bg: '#fffdf5', colors: ['#ffcf46', '#fc6e20', '#a1c35d'], text: '#fc6e20' },
                { name: 'Mental Mine', bg: '#363153', colors: ['#337699', '#5baecf', '#ffde66'], text: '#ffde66' },
                { name: 'Other Planet', bg: '#210754', colors: ['#7fd190', '#bd3f3e', '#effda1'], text: '#effda1' },
                { name: 'Minted Mile', bg: '#75aca1', colors: ['#bb86d8', '#b93043', '#0318f8'], text: '#fff' },
                { name: 'Marfa Memory', bg: '#D6B37C', colors: ['#B4653B', '#67FFFF', '#ffffff'], text: '#B4653B' },
                { name: 'Hyper Glow', bg: '#2b4483', colors: ['#e70688', '#54da82', '#67e4d7'], text: '#67e4d7' },
                { name: 'Boiling Point', bg: '#f1c232', colors: ['#f77f00', '#e84327', '#3f2f1b'], text: '#3f2f1b' }
            ]
        ];

        // Combine all palette sets and shuffle for more variety
        const ALL_PILL_PALETTES = CITIES_PALETTE_SETS.flat();

        // Shuffle array function
        function shuffleArray(arr) {
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Shuffle on load for variety
        const PILL_PALETTES = shuffleArray(ALL_PILL_PALETTES);

        // City emojis distributed across the palettes
        const CITY_EMOJIS = ['\u{1F3D9}', '\u{1F306}', '\u{1F303}', '\u{1F3D9}', '\u{1F306}', '\u{1F303}', '\u{1F3D9}', '\u{1F306}', '\u{1F303}', '\u{1F3D9}'];

        // Palette metadata: time of day, energy, hour
        const PALETTE_META = {
            'Aboveground Current': { time: 'Evening', energy: 'Resting', hour: '22:38' },
            'Alleyway': { time: 'Night', energy: 'Resting', hour: '19:17' },
            'Autumnal': { time: 'Daylight', energy: 'Living', hour: '14:30' },
            'Azulejos': { time: 'Morning', energy: 'Living', hour: '14:36' },
            'Beach Day': { time: 'Morning', energy: 'Living', hour: '10:15' },
            'Bee Line': { time: 'Dawn', energy: 'Rising', hour: '5:35' },
            'Berlin': { time: 'Evening', energy: 'Fading', hour: '21:21' },
            'Bioluminescent': { time: 'Night', energy: 'Resting', hour: 'Blue Hour' },
            'Bitter Haze': { time: 'Night', energy: 'Fading', hour: 'Anytime' },
            'Blinker': { time: 'Night', energy: 'Resting', hour: '0:33' },
            'Blue Hour': { time: 'Dusk', energy: 'Fading', hour: 'Blue Hour' },
            'Blue Skies': { time: 'Daylight', energy: 'Living', hour: '9:29' },
            'Blush Signal': { time: 'Dawn', energy: 'Rising', hour: '10:44' },
            'Bodega Run': { time: 'Night', energy: 'Resting', hour: '23:22' },
            'Boiling Point': { time: 'Afternoon', energy: 'Living', hour: '16:39' },
            'Brick Facade': { time: 'Dusk', energy: 'Fading', hour: '18:46' },
            'Broadway': { time: 'Afternoon', energy: 'Living', hour: '13:16' },
            'Brooklyn': { time: 'Night', energy: 'Resting', hour: '1:23' },
            'Buenos Aires': { time: 'Dusk', energy: 'Fading', hour: '13:21' },
            'Burnout': { time: 'Afternoon', energy: 'Fading', hour: '16:30' },
            'Burnt Impression': { time: 'Dusk', energy: 'Fading', hour: '18:30' },
            'Caffeine': { time: 'Afternoon', energy: 'Living', hour: '9:00' },
            'Caramel Collision': { time: 'Daylight', energy: 'Living', hour: '18:00' },
            'Carioca': { time: 'Afternoon', energy: 'Living', hour: '20:24' },
            'CDMX': { time: 'Evening', energy: 'Fading', hour: '16:12' },
            'Cerulean': { time: 'Evening', energy: 'Resting', hour: 'Blue Hour' },
            'Cinematic Site': { time: 'Evening', energy: 'Resting', hour: '7:50' },
            'Clear Sky Blues': { time: 'Dawn', energy: 'Rising', hour: '14:14' },
            'Concrete Cone': { time: 'Daylight', energy: 'Living', hour: '22:22' },
            'Concrete Heat': { time: 'Afternoon', energy: 'Living', hour: 'Anytime' },
            'Constellations': { time: 'Afternoon', energy: 'Fading', hour: '22:24' },
            'Cotton Candy Noise': { time: 'Night', energy: 'Resting', hour: '19:00' },
            'Crosstown': { time: 'Daylight', energy: 'Living', hour: 'Anytime' },
            'Cruiser': { time: 'Dawn', energy: 'Rising', hour: '20:25' },
            'Curious Blue': { time: 'Dawn', energy: 'Rising', hour: '12:12' },
            'Daybreak Dust': { time: 'Dawn', energy: 'Rising', hour: '8:15' },
            'Diffused Grays': { time: 'Night', energy: 'Fading', hour: 'Anytime' },
            'Downplay': { time: 'Dusk', energy: 'Fading', hour: '19:51' },
            'Dusk Session': { time: 'Dusk', energy: 'Fading', hour: '22:00' },
            'Dust Storm': { time: 'Dawn', energy: 'Rising', hour: '7:17' },
            'Evening Odds': { time: 'Evening', energy: 'Resting', hour: '2:51' },
            'Fly Solo': { time: 'Night', energy: 'Resting', hour: '23:01' },
            'Golden Hum': { time: 'Dawn', energy: 'Rising', hour: '8:29' },
            'Hard Shadow': { time: 'Daylight', energy: 'Living', hour: '11:11' },
            'Heat Wave': { time: 'Morning', energy: 'Living', hour: '15:12' },
            'Hudson Happening': { time: 'Night', energy: 'Fading', hour: '23:18' },
            'Hyper Glow': { time: 'Evening', energy: 'Fading', hour: '20:30' },
            'Impromptu Hue': { time: 'Afternoon', energy: 'Living', hour: '19:35' },
            'Indigo Steps': { time: 'Night', energy: 'Resting', hour: 'Blue Hour' },
            'Into The Night': { time: 'Night', energy: 'Resting', hour: '0:12' },
            'Island Summer': { time: 'Daylight', energy: 'Living', hour: '13:00' },
            'Jaipur Gem': { time: 'Daylight', energy: 'Living', hour: '7:30' },
            'Joyride': { time: 'Afternoon', energy: 'Fading', hour: '22:30' },
            'La Haze': { time: 'Afternoon', energy: 'Living', hour: '18:32' },
            'Last Train Home': { time: 'Evening', energy: 'Resting', hour: '23:28' },
            'Liberty Lane': { time: 'Afternoon', energy: 'Fading', hour: '17:55' },
            'Live Jazz': { time: 'Night', energy: 'Resting', hour: '23:11' },
            'London Fog': { time: 'Evening', energy: 'Resting', hour: 'Anytime' },
            'Low Sun Rush': { time: 'Dusk', energy: 'Fading', hour: '19:24' },
            'Lucid Blue': { time: 'Night', energy: 'Resting', hour: '23:41' },
            'Manhattan': { time: 'Night', energy: 'Resting', hour: '0:00' },
            'Marakata': { time: 'Night', energy: 'Resting', hour: '21:09' },
            'Marfa Memory': { time: 'Daylight', energy: 'Fading', hour: '16:32' },
            'Mauve Orleans': { time: 'Daylight', energy: 'Living', hour: '15:13' },
            'Mental Mine': { time: 'Night', energy: 'Resting', hour: '21:59' },
            'Miami': { time: 'Night', energy: 'Resting', hour: 'Blue Hour' },
            'Midday Brights': { time: 'Afternoon', energy: 'Living', hour: '14:01' },
            'Midnight': { time: 'Night', energy: 'Resting', hour: '0:00' },
            'Minted Mile': { time: 'Evening', energy: 'Fading', hour: '16:33' },
            'Momentary Oasis': { time: 'Evening', energy: 'Fading', hour: '13:40' },
            'Mono Contrast': { time: 'Daylight', energy: 'Living', hour: 'Anytime' },
            'Morning Meditation': { time: 'Dawn', energy: 'Rising', hour: '8:49' },
            'Mundane Morning': { time: 'Daylight', energy: 'Living', hour: '10:01' },
            'Naturalistic': { time: 'Dusk', energy: 'Fading', hour: '19:17' },
            'Neighborly Love': { time: 'Afternoon', energy: 'Living', hour: '18:06' },
            'New Resident': { time: 'Night', energy: 'Resting', hour: '11:51' },
            'Night Flow': { time: 'Night', energy: 'Resting', hour: '1:12' },
            'Night Light': { time: 'Night', energy: 'Resting', hour: '19:11' },
            'One Phone Call': { time: 'Night', energy: 'Resting', hour: '2:00' },
            'Other Planet': { time: 'Night', energy: 'Resting', hour: '21:30' },
            'Out Late': { time: 'Night', energy: 'Resting', hour: '23:34' },
            'Pepdot': { time: 'Morning', energy: 'Living', hour: '14:21' },
            'Present Moment': { time: 'Morning', energy: 'Living', hour: '15:21' },
            'Red Mirage': { time: 'Morning', energy: 'Living', hour: '13:11' },
            'Renewal': { time: 'Daylight', energy: 'Living', hour: '9:54' },
            'Restful Pause': { time: 'Afternoon', energy: 'Living', hour: '20:02' },
            'San Francisco': { time: 'Dusk', energy: 'Fading', hour: '16:20' },
            'Signal Arc': { time: 'Dusk', energy: 'Fading', hour: '19:38' },
            'Slow Collage': { time: 'Afternoon', energy: 'Fading', hour: '11:00' },
            'Soft Shadow': { time: 'Dusk', energy: 'Fading', hour: '19:41' },
            'Subtle Static': { time: 'Afternoon', energy: 'Fading', hour: '15:32' },
            'Sunset Blush': { time: 'Dusk', energy: 'Fading', hour: '9:12' },
            'Swift Transfer': { time: 'Night', energy: 'Resting', hour: '3:14' },
            'Taxi Station': { time: 'Dusk', energy: 'Fading', hour: '16:00' },
            'Thick Air': { time: 'Dusk', energy: 'Fading', hour: '20:18' },
            'Timeless Static': { time: 'Afternoon', energy: 'Living', hour: '15:00' },
            'Tinted Ink': { time: 'Daylight', energy: 'Living', hour: 'Anytime' },
            'Tourist Trap': { time: 'Afternoon', energy: 'Living', hour: '14:12' },
            'Tunnel Vision': { time: 'Dusk', energy: 'Fading', hour: '8:30' },
            'Ultra Violet': { time: 'Afternoon', energy: 'Living', hour: '14:28' },
            'Under Bloom': { time: 'Evening', energy: 'Fading', hour: '17:55' },
            'Underdog': { time: 'Afternoon', energy: 'Living', hour: '18:48' },
            'Underground': { time: 'Evening', energy: 'Resting', hour: 'Anytime' },
            'Uptown': { time: 'Afternoon', energy: 'Fading', hour: '18:16' },
            'Vanilla Pastelo': { time: 'Afternoon', energy: 'Living', hour: '15:54' },
            'Vibrating Blocks': { time: 'Afternoon', energy: 'Fading', hour: '20:31' },
            'Waverly Lavender': { time: 'Morning', energy: 'Living', hour: '8:37' },
            'Whisper Line': { time: 'Evening', energy: 'Fading', hour: 'Anytime' },
            'Wind Down': { time: 'Dusk', energy: 'Fading', hour: '18:33' },
            'World Fair': { time: 'Daylight', energy: 'Living', hour: '14:40' },
            'Woven Glow': { time: 'Afternoon', energy: 'Fading', hour: 'Anytime' },
            'X Ray Film': { time: 'Night', energy: 'Resting', hour: '2:22' }
        };

        // Palette hex data: name -> { bg, colors: [all palette colors] }
        const PALETTE_DATA = {
            'Aboveground Current': { bg: '#0d2049', colors: ['#081124', '#112044', '#2f7bee', '#f5df86', '#000000', '#bcb50f', '#eec7c9', '#e3d536', '#f8cb62', '#FFDDA0', '#cce0ff', '#b3ecc6'] },
            'Alleyway': { bg: '#a096bd', colors: ['#bfcce0', '#767579', '#58529f', '#7f5ac1', '#dabab7', '#dad9df', '#bbbbc2', '#b2b4c0', '#adabb9', '#ccff66', '#7c6b70', '#c0c8cc'] },
            'Autumnal': { bg: '#f6efd9', colors: ['#f29c6b', '#db5e35', '#b01e1e', '#591918', '#fff7f0', '#ffb76f', '#f8d3b1', '#ffebd6', '#E67424', '#ffa982', '#92340d', '#ffcb05'] },
            'Azulejos': { bg: '#f8f5f0', colors: ['#0A1D6F', '#3657B2', '#506AD8', '#6B7FF0', '#2A5CCF', '#192FAD', '#141F8A', '#728ED8', '#96B6D8', '#BBCFF0', '#2E3D7A', '#394CAF'] },
            'Beach Day': { bg: '#f1e9d2', colors: ['#5e4f00', '#423300', '#260700', '#a99746', '#6F4E37', '#5e4f00', '#1C1812', '#423b33', '#323030', '#d7d0aa', '#ccb78f', '#000080'] },
            'Bee Line': { bg: '#FFB300', colors: ['#000000', '#333333', '#222222', '#111111', '#e8e0ca', '#5c5c5c', '#000000', '#333333', '#222222', '#060606', '#f3eee0', '#5c5c5c'] },
            'Berlin': { bg: '#2C3E8E', colors: ['#58529f', '#7f5ac1', '#4c695c', '#a79986', '#d6d6d6', '#bcc3cd', '#a5a9b9', '#617392', '#556482', '#1b3d44', '#b1d5e6', '#eaeaea'] },
            'Bioluminescent': { bg: '#1410af', colors: ['#d54981', '#e7929b', '#007eff', '#702192', '#a23188', '#de5b7b', '#120e9d', '#1510b7', '#007eff', '#130fa6', '#affff7', '#00a0ff'] },
            'Bitter Haze': { bg: '#817681', colors: ['#b3a9b3', '#403640', '#ffcc00', '#ccc2cc', '#271c27', '#c1acb4', '#6b616b', '#655b65', '#635963', '#887e88', '#eb9123', '#7ec599'] },
            'Blinker': { bg: '#0d2049', colors: ['#bca10f', '#f0d54a', '#f4e87b', '#bc770f', '#f2c069', '#bc940f', '#0b1c41', '#0d214c', '#0e2453', '#060f25', '#0b1b3e', '#091633'] },
            'Blue Hour': { bg: '#3856a1', colors: ['#7896e1', '#05236e', '#000a54', '#91affa', '#e0ab73', '#ff6600', '#324d90', '#3a5aa9', '#4062b9', '#355198', '#2f4988', '#273c70'] },
            'Blue Skies': { bg: '#d8efff', colors: ['#87CEEB', '#ECE9F8', '#00BFFF', '#B0E0E6', '#66ccff', '#1569C7', '#b9daf1', '#eff8fe', '#ffffff', '#c0e5ff', '#91d2ff', '#5cb2ee'] },
            'Blush Signal': { bg: '#fffaf0', colors: ['#ffb3ab', '#ffc1c1', '#ca7f6d', '#fdf5f5', '#ebb189', '#fee2e1', '#fdf5ee', '#fcf1ec', '#faeada', '#845d5c', '#ffde66', '#fce3c3'] },
            'Bodega Run': { bg: '#0d2b6d', colors: ['#061a44', '#0c2c73', '#adcdfe', '#ffffff', '#000000', '#ffcf32', '#FFF4B2', '#d3990f', '#FFEB8F', '#f3daae', '#be9ad8', '#edd6fe'] },
            'Boiling Point': { bg: '#f1c232', colors: ['#83846d', '#3f2f1b', '#f77f00', '#eaeaea', '#eaeaea', '#4e2729', '#f1c232', '#83846d', '#e84327', '#ffba4a', '#3f2f1b', '#f77f00'] },
            'Brick Facade': { bg: '#bc4a3c', colors: ['#4e5358', '#c9c3b9', '#3d3e4d', '#202829', '#8d3024', '#f9f8f7', '#251e34', '#554478', '#8e80a9', '#2d2241', '#c0b3d9', '#dbd0f1'] },
            'Broadway': { bg: '#f0ede7', colors: ['#000000', '#000000', '#0033A0', '#FAE600', '#E53935', '#1E5B7E', '#11457E', '#3D26B3', '#214478', '#FFD700', '#fffc00', '#E2702A'] },
            'Brooklyn': { bg: '#03071E', colors: ['#370617', '#6A040F', '#9D0208', '#D00000', '#DC2F02', '#E85D04', '#F48C06', '#FAA307', '#FFBA08', '#61dbb2', '#7FFFD4', '#FF00FF'] },
            'Buenos Aires': { bg: '#eaeaea', colors: ['#ffa800', '#fc6e20', '#ffb300', '#b25d44', '#b25d44', '#fdedd2', '#fbe08d', '#ffd684', '#ffdb72', '#fca778', '#897d93', '#fafae4'] },
            'Burnout': { bg: '#f5937a', colors: ['#822007', '#690700', '#8ca5f6', '#ffac93', '#ffac93', '#99907a', '#a24a34', '#be573c', '#c5654c', '#ab4e37', '#994631', '#7e3a28'] },
            'Burnt Impression': { bg: '#8FA3AE', colors: ['#455560', '#1E1E1C', '#FF5C00', '#FF6E1A', '#FBC174', '#6A8CA5', '#7c93a0', '#98aab4', '#aab9c1', '#859ba7', '#738c9a', '#5d7480'] },
            'Caffeine': { bg: '#f7f6f5', colors: ['#453b05', '#302603', '#1c0702', '#81753d', '#060301', '#453b05', '#5f4a06', '#2A251F', '#000000', '#b7b08a', '#ccb78f', '#423300'] },
            'Caramel Collision': { bg: '#D1C4B2', colors: ['#5D3A00', '#E06C00', '#F5BA57', '#D94F00', '#872800', '#B23B00', '#E1C699', '#CFB38B', '#B89B78', '#F5DEB3', '#F79C5C', '#AF491F'] },
            'Carioca': { bg: '#fed2e2', colors: ['#fda1c2', '#eeee5f', '#251f6c', '#2c60a9', '#5e91b6', '#f25db4', '#fdb8d1', '#fee5ee', '#e3b0da', '#faedf2', '#b2d5a8', '#eeee5f'] },
            'CDMX': { bg: '#937159', colors: ['#af8c74', '#1b1f3e', '#ddb4c0', '#fdebf1', '#ffcd9f', '#ec9a76', '#4b382c', '#977a67', '#8a6d59', '#5b4638', '#665042', '#544236'] },
            'Cerulean': { bg: '#12419a', colors: ['#20e3df', '#1d4ea3', '#6e75d3', '#34877a', '#0051bb', '#cffada', '#17444d', '#123d87', '#7f9de8', '#203985', '#da0246', '#ffff1c'] },
            'Cinematic Site': { bg: '#607D8B', colors: ['#8EA0B8', '#5E7380', '#3C5A76', '#B0BEC5', '#263238', '#78909C', '#758B95', '#6D858F', '#5D6D75', '#4C5E66', '#D2F1F9', '#ADC7D4'] },
            'Clear Sky Blues': { bg: '#94d8ff', colors: ['#2a609e', '#0b7ed0', '#00adda', '#3d72c0', '#3d72c0', '#b6dfff', '#b1dcff', '#addaff', '#afd8fc', '#fcffc5', '#fdff8c', '#fff1c1'] },
            'Concrete Cone': { bg: '#ff5c00', colors: ['#000000', '#333333', '#222222', '#111111', '#444444', '#e8e0ca', '#cb530e', '#953e0d', '#222222', '#292929', '#444444', '#f3eee0'] },
            'Concrete Heat': { bg: '#A9A9A9', colors: ['#FFD67B', '#DDC07A', '#D6A461', '#F5E45C', '#A67C52', '#7A5B3E', '#C1B6A3', '#B5AFA1', '#fdf5ee', '#A2968C', '#CFCFCF', '#D64545'] },
            'Constellations': { bg: '#1b1420', colors: ['#1A2B1F', '#4A5A90', '#FEDD0D', '#F5F5CC', '#6588C7', '#48A662', '#50657A', '#3A4D7A', '#9CA8C8', '#4B3D28', '#FF8C00', '#FFC600'] },
            'Cotton Candy Noise': { bg: '#f4f4f4', colors: ['#d6d6d6', '#a4d5ff', '#fab6d4', '#22375e', '#22375e', '#fdf7f7', '#f2f2f2', '#e6e9eb', '#f6f9fc', '#6d4c5b', '#d3ff66', '#fffaf0'] },
            'Crosstown': { bg: '#FFFAF0', colors: ['#000000', '#333333', '#222222', '#111111', '#444444', '#5c5c5c', '#000000', '#333333', '#222222', '#353434', '#1f1f1f', '#5c5c5c'] },
            'Cruiser': { bg: '#3c3153', colors: ['#f0cd3a', '#a3c3b1', '#6b7075', '#c9ae00', '#3e484e', '#767d6a', '#f0cd3a', '#a3c3b1', '#2c2f38', '#abb49c', '#6b7075', '#c9ae00'] },
            'Curious Blue': { bg: '#d4f0ff', colors: ['#bae1ff', '#1e7cae', '#5baecf', '#fff1c1', '#fff1c1', '#d6e3ed', '#d4e8f8', '#badcfa', '#bbe0ff', '#3a475e', '#ffefa7', '#bfcce0'] },
            'Daybreak Dust': { bg: '#f0efec', colors: ['#f8ebbc', '#ffb300', '#fc6e20', '#a79986', '#a79986', '#fde1c0', '#e6d6c9', '#f7dfcb', '#efd3bb', '#29545c', '#b1d5e6', '#ffe0e0'] },
            'Diffused Grays': { bg: '#c3cbcf', colors: ['#4b4747', '#8a7670', '#6e6e6e', '#434343', '#434343', '#ced7d9', '#b1b1b1', '#cecece', '#e2e0d8', '#d65790', '#ff66c3', '#cbcecf'] },
            'Downplay': { bg: '#785f4e', colors: ['#5b4680', '#191c32', '#c58a9b', '#f1a6c1', '#ffaa5a', '#db784d', '#6c5546', '#7e6351', '#8a6d59', '#725a4a', '#665042', '#544236'] },
            'Dusk Session': { bg: '#463766', colors: ['#5c636a', '#ebe8e4', '#47495d', '#253032', '#303c41', '#ffffff', '#251e34', '#8272a3', '#8e80a9', '#749a71', '#c0b3d9', '#f2eefb'] },
            'Dust Storm': { bg: '#f9b9aa', colors: ['#d4a373', '#a65c3b', '#706353', '#f4e0c3', '#f4e0c3', '#b54a41', '#f9b9aa', '#d4a373', '#e8c3a3', '#ddbac3', '#a65c3b', '#706353'] },
            'Evening Odds': { bg: '#051437', colors: ['#ffdf32', '#fef8d9', '#040e22', '#1b3772', '#657fb8', '#ffcf32', '#0b1c41', '#ffad32', '#ffcf32', '#ffee2c', '#cce0ff', '#92d1a7'] },
            'Fly Solo': { bg: '#240c42', colors: ['#59009b', '#0a245d', '#eee378', '#f4b621', '#59009b', '#203369', '#0e1736', '#31084f', '#516090', '#223a87', '#a3f0e8', '#a3f0e8'] },
            'Golden Hum': { bg: '#fffdf5', colors: ['#151722', '#ffcf46', '#ffa800', '#fc6e20', '#fc6e20', '#fff6ee', '#fffbde', '#fff6d3', '#faf8cd', '#a1c35d', '#9b868c', '#fffdf5'] },
            'Hard Shadow': { bg: '#e3e3db', colors: ['#ffcf46', '#ffe46c', '#ffa800', '#fc6e20', '#fc6e20', '#fdf7f5', '#fffbf2', '#f7f5f1', '#f9f1e6', '#fca778', '#68b1b3', '#b7b2ae'] },
            'Heat Wave': { bg: '#FF9100', colors: ['#da4801', '#ff7f32', '#FF6D00', '#ffffff', '#fee6c1', '#FF4800', '#FF9E00', '#f9f8f7', '#fee6c1', '#FF8500', '#cc0f95', '#ffffa9'] },
            'Hudson Happening': { bg: '#191970', colors: ['#87CEEB', '#708090', '#2E8B57', '#FF4500', '#A9D0A9', '#000080', '#444C6D', '#5D6D84', '#75809A', '#dbb18c', '#FFA07A', '#4682B4'] },
            'Hyper Glow': { bg: '#2b4483', colors: ['#e70688', '#54da82', '#67e4d7', '#a6ac17', '#e54eb4', '#0e1596', '#263d75', '#2d4789', '#314e96', '#28407c', '#24396f', '#1e2f5b'] },
            'Impromptu Hue': { bg: '#db9215', colors: ['#001a33', '#001F3F', '#003366', '#3221A3', '#004080', '#468dd1', '#1c2835', '#7888CD', '#c9def5', '#B4C5E4', '#5361C7', '#4A53BB'] },
            'Indigo Steps': { bg: '#101a3c', colors: ['#263d75', '#2d4789', '#3a5caf', '#28407c', '#24396f', '#1f2d54', '#0e1736', '#1e2e61', '#121d45', '#0f1839', '#8497d1', '#556cb9'] },
            'Into The Night': { bg: '#0b0f1d', colors: ['#ffcb05', '#fef9c5', '#ffffff', '#ff5f00', '#fb8e2c', '#ff3b3b', '#131c3a', '#1f2b4d', '#45385f', '#392e4e', '#ffffa9', '#e54eb4'] },
            'Island Summer': { bg: '#F5DEB3', colors: ['#1E90FF', '#D72638', '#FFB6C1', '#FFA500', '#4B0082', '#00CED1', '#A0DFFF', '#FFE5CC', '#FFDDDD', '#F5CBA7', '#FF6347', '#20B2AA'] },
            'Jaipur Gem': { bg: '#D8A8B7', colors: ['#2E535B', '#3D2B56', '#1CA66A', '#475BB5', '#E67424', '#F080A0', '#cc8da1', '#ddb5c1', '#e9cfd7', '#d29aac', '#c68096', '#b45875'] },
            'Joyride': { bg: '#5b0060', colors: ['#800080', '#8A2BE2', '#A020F0', '#9370DB', '#9932CC', '#B86BB5', '#510056', '#5f0064', '#68006e', '#56005b', '#4d0051', '#3f0043'] },
            'La Haze': { bg: '#ffce46', colors: ['#a07600', '#ce6624', '#ed25c8', '#9f0000', '#860063', '#5b0000', '#ca7505', '#ff9eec', '#e7a7a1', '#a46566', '#f876df', '#ba9da2'] },
            'Last Train Home': { bg: '#2c2c2c', colors: ['#58529f', '#a79986', '#b7934c', '#df2049', '#df2049', '#393031', '#534f56', '#313839', '#3c3643', '#78615a', '#947fff', '#363153'] },
            'Liberty Lane': { bg: '#A9BA9D', colors: ['#708090', '#87CEEB', '#FFD700', '#B87333', '#FFFFFF', '#5A5A5A', '#C0C0B0', '#A0A0A0', '#E0E0E0', '#B0C0C0', '#FFB300', '#2F4F2F'] },
            'Live Jazz': { bg: '#0d1a36', colors: ['#091736', '#10275b', '#66a3ff', '#FFF8DC', '#000000', '#FFC400', '#cce0ff', '#bd675e', '#FFEB8F', '#dcba7d', '#FFF4B2', '#d6f6e0'] },
            'London Fog': { bg: '#c8c8c8', colors: ['#b1a5a1', '#a7a6a6', '#828282', '#a8a8a8', '#f05b67', '#ff0015', '#bdbdbd', '#d0d0d0', '#e2e2e2', '#7e554b', '#b6674e', '#ff0015'] },
            'Low Sun Rush': { bg: '#f9f7ed', colors: ['#fc6e20', '#ffb300', '#b7934c', '#876935', '#876935', '#fecfc3', '#fdcbaf', '#fab78a', '#fba676', '#523743', '#d3ff66', '#fce3c3'] },
            'Lucid Blue': { bg: '#00254b', colors: ['#008bf4', '#2f455c', '#003d7a', '#004c99', '#005fbd', '#008bf4', '#001b38', '#002042', '#002348', '#001d3b', '#001a35', '#00152c'] },
            'Manhattan': { bg: '#22375e', colors: ['#3c69be', '#1b2b4f', '#fe675e', '#00d0a0', '#1d2cff', '#3d69bd', '#857b6c', '#3b4e56', '#808da3', '#2c383d', '#877cff', '#3d4eff'] },
            'Marakata': { bg: '#18382A', colors: ['#4FA98D', '#2E6D57', '#60A280', '#15725C', '#3E8C6F', '#0F1C18', '#1B352B', '#244438', '#305E4B', '#102D21', '#B5FF7B', '#5AE8AC'] },
            'Marfa Memory': { bg: '#D6B37C', colors: ['#F4C882', '#B4653B', '#F5E1B9', '#F1C27B', '#C69C6D', '#9D7950', '#E0C79D', '#CFAE8A', '#ffffff', '#C7A376', '#67FFFF', '#9D7950'] },
            'Mauve Orleans': { bg: '#f1e9d2', colors: ['#800080', '#8A2BE2', '#A020F0', '#9370DB', '#9932CC', '#8B008B', '#800080', '#A546A8', '#B86BB5', '#CD8ACD', '#730077', '#5F0063'] },
            'Mental Mine': { bg: '#363153', colors: ['#22375e', '#337699', '#5baecf', '#58529f', '#58529f', '#515156', '#474649', '#5e5e5f', '#3f3d3d', '#845d5c', '#ffde66', '#1f1722'] },
            'Miami': { bg: '#182f5a', colors: ['#007BA7', '#1d4ea3', '#6e75d3', '#34877a', '#0051bb', '#59d8c5', '#20535d', '#e7929b', '#7f9de8', '#3251b0', '#e6a9f3', '#ffff1c'] },
            'Midday Brights': { bg: '#e9e4ab', colors: ['#ff9500', '#a37410', '#ff7b00', '#de7106', '#de7106', '#d6d6d4', '#e0e0dc', '#ebe9e5', '#f5f3ed', '#ef8a7f', '#ffc466', '#f9f7f0'] },
            'Midnight': { bg: '#151722', colors: ['#151628', '#242744', '#6c7fae', '#96adce', '#c1ceea', '#e9eff9', '#171927', '#1b1d2e', '#83a4d2', '#181a29', '#d2e5ff', '#12131e'] },
            'Minted Mile': { bg: '#75aca1', colors: ['#1a5e45', '#bb86d8', '#cccfda', '#b93043', '#0318f8', '#5f1bee', '#62a194', '#7eb1a7', '#90bcb3', '#6ba69a', '#5c998d', '#4b7e74'] },
            'Momentary Oasis': { bg: '#4C956C', colors: ['#6AA889', '#B7D5C7', '#E8F3F1', '#FFF8F0', '#FFF8F0', '#4C956C', '#448661', '#4f9c71', '#58aa7c', '#488d66', '#407e5b', '#35684b'] },
            'Mono Contrast': { bg: '#f5f5f5', colors: ['#111111', '#222222', '#d8d8d8', '#c7c7c7', '#b9b9b9', '#ababab', '#111111', '#333333', '#d5d5d5', '#c7c7c7', '#444444', '#d8d8d8'] },
            'Morning Meditation': { bg: '#f7ecbb', colors: ['#cfb720', '#fffc0f', '#e36a0f', '#f97a00', '#f97a00', '#b9a58f', '#cab299', '#dcbea2', '#edcbac', '#99b5df', '#9aafbd', '#fddbbe'] },
            'Mundane Morning': { bg: '#f8f8f8', colors: ['#a7c9d4', '#e6c5bc', '#627181', '#f5f9fc', '#ffffff', '#c9adb0', '#bababa', '#d9d9d9', '#eeeeee', '#c4c4c4', '#afafaf', '#909090'] },
            'Naturalistic': { bg: '#685b5b', colors: ['#e0857b', '#9f8000', '#d8dcdd', '#a759c7', '#52a0ef', '#3099df', '#4d4545', '#5a5050', '#625858', '#3c3535', '#e0acf5', '#fad022'] },
            'Neighborly Love': { bg: '#fff5f9', colors: ['#fc6e20', '#ffa800', '#a79986', '#337699', '#337699', '#fec9ba', '#fec4a0', '#f5a071', '#fc9151', '#73e5ea', '#ffce66', '#fce3c3'] },
            'New Resident': { bg: '#1f043a', colors: ['#b858cb', '#4b2f5a', '#ce06f3', '#12b9f4', '#e36de3', '#ffafcc', '#10dd9c', '#650976', '#dd66f3', '#98d8ef', '#ce06f3', '#e36de3'] },
            'Night Flow': { bg: '#101a3c', colors: ['#ffff33', '#fae599', '#ddd04e', '#d09a18', '#4B0082', '#1f2d54', '#0e1736', '#101b3e', '#121d45', '#0f1839', '#0d1632', '#0b122a'] },
            'Night Light': { bg: '#29023a', colors: ['#07938e', '#db60f8', '#455728', '#8342bf', '#f06e29', '#8aeeb8', '#240134', '#2b023c', '#2f0242', '#260137', '#ff66cb', '#ff66cb'] },
            'One Phone Call': { bg: '#1a1c2c', colors: ['#131421', '#202237', '#586994', '#738eb7', '#91a6d4', '#aec4e4', '#171927', '#1b1d2e', '#1d2032', '#181a29', '#404377', '#313448'] },
            'Other Planet': { bg: '#210754', colors: ['#27466d', '#0a423a', '#7fd190', '#bd3f3e', '#effda1', '#2e29ad', '#1d064b', '#220758', '#250860', '#1f064f', '#1c0547', '#fbfdf2'] },
            'Out Late': { bg: '#171010', colors: ['#f3f2f2', '#dcdcdc', '#2F2C29', '#3E3A36', '#1A1410', '#201C16', '#110F0D', '#2e2e2e', '#3C3935', '#514D48', '#E63B2E', '#00A652'] },
            'Pepdot': { bg: '#ecebed', colors: ['#05aa0e', '#0a8811', '#040406', '#1441ff', '#fc070d', '#158f1c', '#d4d2d6', '#f7f7f8', '#ffffff', '#e0dee1', '#c8c5cb', '#a5a0a9'] },
            'Present Moment': { bg: '#ecb317', colors: ['#ecd287', '#ce6624', '#ff59e0', '#9f0000', '#860063', '#5b0000', '#9e5d08', '#ff9eec', '#e7a7a1', '#a46566', '#f876df', '#ba9da2'] },
            'Red Mirage': { bg: '#f6efd9', colors: ['#DC143C', '#8B0000', '#A52A2A', '#B22222', '#800020', '#FF4500', '#DC143C', '#FF6347', '#FF7F50', '#FF6656', '#FFA07A', '#FFB6C1'] },
            'Renewal': { bg: '#d8efff', colors: ['#c2e9f9', '#8ccff2', '#32cbff', '#e2daea', '#ade3fe', '#117df6', '#82b7dd', '#eff8fe', '#ffffff', '#c0e5ff', '#91d2ff', '#4ab5ff'] },
            'Restful Pause': { bg: '#732da3', colors: ['#9b6eb9', '#ada9c0', '#d0e0eb', '#fefeff', '#fefeff', '#ffffff', '#8678b1', '#aba0c8', '#f2f1f7', '#c2bbd8', '#aba0c8', '#8678b1'] },
            'San Francisco': { bg: '#337699', colors: ['#73b6d9', '#004366', '#d4b96b', '#8ccff2', '#002a4c', '#3366ff', '#2d7093', '#1f6285', '#1e6184', '#216487', '#ffffa9', '#eb9123'] },
            'Signal Arc': { bg: '#58529f', colors: ['#9892df', '#251f6c', '#b1abf8', '#dda890', '#99907a', '#0c0652', '#4f498f', '#5c56a6', '#6b65af', '#534d97', '#4a4587', '#3d396f'] },
            'Slow Collage': { bg: '#5F658C', colors: ['#ACB5D7', '#FCFCF5', '#646472', '#F1A354', '#53577B', '#4D516B', '#EAC49F', '#B5B1BB', '#46495D', '#FF69B4', '#FF69B4', '#00CED1'] },
            'Soft Shadow': { bg: '#cfc9e0', colors: ['#4b2862', '#67497c', '#6e6a86', '#749ab3', '#d2bf9d', '#f3bc77', '#b7aed0', '#dbd6e7', '#f2f1f7', '#c2bbd8', '#aba0c8', '#8678b1'] },
            'Subtle Static': { bg: '#f0eeee', colors: ['#e2e6e9', '#363153', '#837c7c', '#fdf5f5', '#fdf5f5', '#e8e7e8', '#a5a5a5', '#e2e2e2', '#d0d3d8', '#52c7cc', '#ffce66', '#d6d6d6'] },
            'Sunset Blush': { bg: '#F47C74', colors: ['#FF867C', '#FF5E52', '#FFAA99', '#FBE1DC', '#FFD1C7', '#A34238', '#FBAEA6', '#E5948B', '#EED4CE', '#C9584E', '#FFEDE8', '#A96AFB'] },
            'Swift Transfer': { bg: '#0a0705', colors: ['#333333', '#606060', '#8c8c8c', '#b8b8b8', '#ffffff', '#f2f8f7', '#F21E2C', '#0d0907', '#0e0a08', '#0c0806', '#fec631', '#F9591F'] },
            'Taxi Station': { bg: '#d6cecf', colors: ['#635b5c', '#ffcc00', '#dcc9d2', '#efe7e8', '#efe7e8', '#4a4242', '#877e7f', '#9d9596', '#aba4a5', '#8e8687', '#807778', '#696263'] },
            'Thick Air': { bg: '#6f7369', colors: ['#afb3a9', '#3c4036', '#c8ccc2', '#99907a', '#a0cbbb', '#23271c', '#63675e', '#74786e', '#7f8478', '#696d63', '#5e6159', '#4d5049'] },
            'Timeless Static': { bg: '#e2e6e9', colors: ['#363153', '#58529f', '#837c7c', '#d6d6d6', '#d6d6d6', '#eeedee', '#eeeeee', '#f8f4f4', '#e7eaef', '#78615a', '#947fff', '#f4f4f4'] },
            'Tinted Ink': { bg: '#f1c1ea', colors: ['#001a33', '#3221A3', '#003366', '#001F3F', '#004080', '#00509E', '#2f4359', '#94a0d3', '#96a5b4', '#d1ddf2', '#838dd6', '#4A53BB'] },
            'Tourist Trap': { bg: '#fffaf0', colors: ['#ffcba1', '#ffcf46', '#d88c7a', '#ae5029', '#913f1d', '#fbf7e5', '#fef1f1', '#fff3ef', '#f8eaea', '#5e6d87', '#ffefa7', '#ffe0e0'] },
            'Tunnel Vision': { bg: '#968e8f', colors: ['#3f4245', '#dac5a1', '#31323c', '#1a1f20', '#21272a', '#cdc6bf', '#362c4a', '#3f3357', '#dac5a1', '#6d5c8d', '#332946', '#2a223a'] },
            'Ultra Violet': { bg: '#f4f2f7', colors: ['#E6E6FA', '#D8BFD8', '#9370DB', '#ffffff', '#6A5ACD', '#6959CD', '#d2c5e2', '#e2daea', '#f8f6fa', '#cbbfdb', '#b5a3cb', '#9479b4'] },
            'Under Bloom': { bg: '#2E535B', colors: ['#D8A8B7', '#F080A0', '#1CA66A', '#475BB5', '#E67424', '#3D2B56', '#294a51', '#30575f', '#345f68', '#2b4e56', '#27464d', '#203a3f'] },
            'Underdog': { bg: '#faf2f0', colors: ['#f37a37', '#ffa800', '#a79986', '#006BB6', '#006BB6', '#fec9ba', '#fec4a0', '#f5a071', '#fc9151', '#3ba1a6', '#ffce66', '#fce3c3'] },
            'Underground': { bg: '#1d2036', colors: ['#101019', '#1a1c2a', '#4a5572', '#567097', '#657fb8', '#7899c8', '#171927', '#173068', '#1d2032', '#181a29', '#161725', '#12131e'] },
            'Uptown': { bg: '#6b7b90', colors: ['#c1c1c3', '#fffd7b', '#ff0000', '#0002ff', '#fffc00', '#ff66cb', '#fffb7d', '#c1c1c3', '#f7f8c9', '#009bf7', '#4d545a', '#644cbe'] },
            'Vanilla Pastelo': { bg: '#fee6c1', colors: ['#929487', '#d41159', '#f26a8d', '#fee6c1', '#fae599', '#f9f8f7', '#fdd495', '#feeed6', '#ffffff', '#fdddab', '#fccb7f', '#fbb03d'] },
            'Vibrating Blocks': { bg: '#B7094C', colors: ['#A01A58', '#892B64', '#723C70', '#5C4D7D', '#455E89', '#2E6F95', '#1780A1', '#0091AD', '#000000', '#FFAA00', '#FFA500', '#2E8B57'] },
            'Waverly Lavender': { bg: '#d7cde3', colors: ['#ffffff', '#f7f1f7', '#b99fed', '#ffffff', '#8e81e0', '#8d7fe0', '#c0b1d3', '#e2daea', '#f8f6fa', '#cbbfdb', '#b5a3cb', '#9479b4'] },
            'Whisper Line': { bg: '#665b6c', colors: ['#e5e0e8', '#332839', '#1a0f20', '#aab2a9', '#bfb4c5', '#ff6600', '#5b5161', '#6b5f71', '#75687c', '#605666', '#564d5b', '#473f4b'] },
            'Wind Down': { bg: '#ae5029', colors: ['#ee9069', '#7b1d00', '#5e97ef', '#620400', '#ffa982', '#ff0033', '#a54720', '#b0522b', '#92340d', '#a74922', '#c37c57', '#3145a1'] },
            'World Fair': { bg: '#F3F0E8', colors: ['#89CFF0', '#FFB6C1', '#FFD700', '#8A2BE2', '#FFFFFF', '#A9A9A9', '#EDDDC5', '#D5C4A1', '#BFA47D', '#A78F5A', '#FF8C00', '#7B68EE'] },
            'Woven Glow': { bg: '#838293', colors: ['#504f60', '#363546', '#747385', '#ced7d9', '#ced7d9', '#5a5968', '#dcdbec', '#8a8999', '#df96b6', '#7b7a8c', '#fab6d4', '#fab6d4'] },
            'X Ray Film': { bg: '#0D0907', colors: ['#2b2b2b', '#505050', '#757575', '#9a9a9a', '#e6e6e6', '#f2f8f7', '#585454', '#302520', '#362f2b', '#201b18', '#fafafa', '#e6e6e6'] }
        };

        // Palette blurbs - short evocative descriptions
        const PALETTE_BLURBS = {
            'Aboveground Current': 'Electric blue pulse beneath the evening grid',
            'Alleyway': 'Neon haze through wet pavement at dusk',
            'Autumnal': 'Burnt leaves and brick, last warmth of the year',
            'Azulejos': 'Portuguese tile dreams, deep blue on white',
            'Beach Day': 'Sand in your shoes, salt on your skin',
            'Bee Line': 'High contrast, no detours, straight through',
            'Berlin': 'Club exit at 6am, grey sky salvation',
            'Bioluminescent': 'Deep sea glow, something alive down there',
            'Bitter Haze': 'Smoke break on the fire escape',
            'Blinker': 'Yellow caution through the midnight fog',
            'Blue Hour': 'That fifteen minutes when everything glows',
            'Blue Skies': 'Cloudless and wide open, nowhere to hide',
            'Blush Signal': 'Soft morning, coffee steam, bare feet',
            'Bodega Run': 'Fluorescent glow, corner store salvation',
            'Boiling Point': 'Summer concrete, tempers short, hydrant open',
            'Brick Facade': 'Old building, older stories, paint peeling',
            'Broadway': 'Marquee lights and taxi horns at curtain call',
            'Brooklyn': 'Fire escapes and rooftop sunsets',
            'Buenos Aires': 'Tango warmth, afternoon light through shutters',
            'Burnout': 'Running hot, fading fast, still beautiful',
            'Burnt Impression': 'Rust and sky, industrial coast',
            'Caffeine': 'First cup, newspaper ink, slow start',
            'Caramel Collision': 'Sticky sweet afternoon, golden hour spill',
            'Carioca': 'Carnival pink, sun-bleached and sweating',
            'CDMX': 'Terracotta and indigo, mercado morning',
            'Cerulean': 'Deep end of the pool, holding your breath',
            'Cinematic Site': 'Film noir fog, streetlight halo',
            'Clear Sky Blues': 'Not a cloud, not a worry, not today',
            'Concrete Cone': 'Construction orange, hard hat territory',
            'Concrete Heat': 'Pavement shimmer, ice cream truck distant',
            'Constellations': 'Rooftop stargazing, city lights below',
            'Cotton Candy Noise': 'Soft static, pastel frequencies',
            'Crosstown': 'Black and white, no grey area',
            'Cruiser': 'Low rider, windows down, bass heavy',
            'Curious Blue': 'Swimming pool light on the ceiling',
            'Daybreak Dust': 'First light on cracked earth, coffee in hand',
            'Diffused Grays': 'Overcast and okay with it',
            'Downplay': 'Muted tones, loud thoughts',
            'Dusk Session': 'Purple hour, skate park empty',
            'Dust Storm': 'Desert wind, eyes half-closed',
            'Evening Odds': 'Betting on the night, dealer takes all',
            'Fly Solo': 'Alone but not lonely, neon company',
            'Golden Hum': 'Honey light through dusty windows',
            'Hard Shadow': 'High noon, nowhere to hide',
            'Heat Wave': 'Too hot to move, too bright to see',
            'Hudson Happening': 'River breeze, downtown glitter',
            'Hyper Glow': 'Arcade cabinet, high score chase',
            'Impromptu Hue': 'Unplanned detour, better than expected',
            'Indigo Steps': 'Descending into the deep blue',
            'Into The Night': 'Past midnight, past caring',
            'Island Summer': 'Hammock weather, rum punch afternoon',
            'Jaipur Gem': 'Spice market shimmer, silk and stone',
            'Joyride': 'Borrowed car, empty highway, purple dusk',
            'La Haze': 'Smog and magic, city of angels',
            'Last Train Home': 'Platform shadows, midnight transfer',
            'Liberty Lane': 'Old glory, weathered but standing',
            'Live Jazz': 'Blue notes, brown liquor, red lips',
            'London Fog': 'Grey on grey, red bus cuts through',
            'Low Sun Rush': 'Golden hour traffic, windows down',
            'Lucid Blue': 'Clear thinking at impossible depths',
            'Manhattan': 'Concrete canyon, yellow cab flash',
            'Marakata': 'Emerald jungle, something ancient',
            'Marfa Memory': 'Desert art, mysterious lights',
            'Mauve Orleans': 'Wrought iron and wisteria',
            'Mental Mine': 'Deep in thought, digging for gold',
            'Miami': 'Vice colors, ocean drive, top down',
            'Midday Brights': 'Sun directly overhead, no shadows',
            'Midnight': 'City sleeps, you dont',
            'Minted Mile': 'Fresh start, green light, go',
            'Momentary Oasis': 'Brief respite, keep moving',
            'Mono Contrast': 'Black coffee, white walls, clear head',
            'Morning Meditation': 'Sunrise stretch, mind empty',
            'Mundane Morning': 'Regular day, regular way, okay',
            'Naturalistic': 'Earth tones, grounded feeling',
            'Neighborly Love': 'Philly warmth, front stoop summer',
            'New Resident': 'Just moved in, boxes everywhere',
            'Night Flow': 'Smooth ride through sleeping streets',
            'Night Light': 'Hallway glow, 3am thoughts',
            'One Phone Call': 'Late night dial, hoping they answer',
            'Other Planet': 'Somewhere else entirely, alien familiar',
            'Out Late': 'Should have left hours ago',
            'Pepdot': 'Primary colors, elementary joy',
            'Present Moment': 'Right here, right now, nowhere else',
            'Red Mirage': 'Heat shimmer, something approaching',
            'Renewal': 'Fresh coat, clean slate, try again',
            'Restful Pause': 'Lavender fields, eyes closed',
            'San Francisco': 'Fog rolling in, bridge barely visible',
            'Signal Arc': 'Radio waves, distant transmission',
            'Slow Collage': 'Cut and paste, take your time',
            'Soft Shadow': 'Gentle contrast, easy afternoon',
            'Subtle Static': 'White noise, background hum',
            'Sunset Blush': 'Sky embarrassed by its own beauty',
            'Swift Transfer': 'Platform to platform, dont miss it',
            'Taxi Station': 'Waiting for a ride, meter running',
            'Thick Air': 'Humid, heavy, hard to breathe',
            'Timeless Static': 'Always been here, always will be',
            'Tinted Ink': 'Love letter, purple prose',
            'Tourist Trap': 'Overpriced but worth the photo',
            'Tunnel Vision': 'One way forward, blinders on',
            'Ultra Violet': 'Beyond visible, feeling more than seeing',
            'Under Bloom': 'Cherry blossoms, looking up',
            'Underdog': 'Nobody expected this, watch closely',
            'Underground': 'Subway hum, stranger shoulders',
            'Uptown': 'Money moves, marble lobbies',
            'Vanilla Pastelo': 'Soft serve sunset, sweet and simple',
            'Vibrating Blocks': 'Cant sit still, too much energy',
            'Waverly Lavender': 'West Village morning, quiet street',
            'Whisper Line': 'Secrets passed, barely audible',
            'Wind Down': 'End of day, letting go',
            'World Fair': 'Retro future, optimism on display',
            'Woven Glow': 'Fabric of light, threaded through',
            'X Ray Film': 'See right through, nothing hidden'
        };

        let currentTokenId = 0;
        let currentSize = 'medium';
        let favorites = JSON.parse(localStorage.getItem('cities-favorites') || '[]');
        let tokenTraits = {};
        let tokenOwners = {};
        // OpenSea rarity ranks (from OpenRarity algorithm) - token ID to rank mapping
        // Source: OpenSea collection sorted by "Rarity" (321 items as of current snapshot)
        const OPENSEA_RARITY_RANKS = {
            // Ranks 1-33
            319: 1, 251: 1, 127: 2, 200: 3, 142: 4, 98: 5, 155: 6, 181: 7, 27: 8, 175: 9,
            199: 10, 34: 11, 136: 12, 314: 12, 303: 13, 133: 13, 117: 14, 279: 15, 281: 16, 29: 17,
            150: 18, 217: 19, 301: 19, 202: 20, 100: 21, 207: 22, 112: 22, 285: 23, 45: 24, 54: 25,
            300: 25, 164: 26, 58: 27, 242: 28, 73: 29, 277: 30, 36: 31, 82: 32, 272: 33, 316: 33,
            // Ranks 34-58
            299: 34, 250: 34, 223: 35, 11: 36, 91: 36, 165: 37, 0: 38, 114: 39, 60: 40, 219: 41,
            53: 42, 118: 43, 107: 44, 176: 45, 89: 46, 297: 46, 101: 47, 233: 48, 39: 49, 222: 50,
            191: 51, 157: 52, 171: 53, 260: 54, 4: 55, 274: 56, 232: 57, 148: 58,
            // Ranks 59-88
            26: 59, 32: 60, 193: 61, 90: 62, 296: 63, 269: 63, 283: 64, 9: 65, 134: 66, 173: 67,
            221: 68, 16: 69, 161: 70, 144: 71, 44: 72, 309: 73, 266: 73, 307: 74, 2: 74, 230: 75,
            86: 76, 56: 77, 265: 78, 160: 79, 108: 80, 194: 80, 7: 81, 311: 82, 204: 82, 119: 83,
            70: 84, 145: 85, 76: 86, 234: 87, 49: 88, 298: 88, 12: 88,
            // Ranks 89-118
            74: 89, 115: 90, 37: 91, 216: 92, 208: 93, 81: 94, 218: 95, 206: 96, 310: 97, 126: 97,
            247: 97, 203: 98, 52: 99, 3: 100, 190: 101, 66: 102, 256: 103, 121: 104, 48: 105, 255: 105,
            20: 106, 162: 107, 228: 108, 244: 109, 225: 110, 146: 111, 71: 112, 92: 113, 138: 114,
            43: 115, 94: 116, 262: 117, 238: 118,
            // Ranks 119-152
            229: 119, 30: 120, 147: 121, 113: 122, 87: 123, 163: 124, 318: 125, 172: 125, 210: 126,
            15: 127, 189: 128, 151: 129, 149: 130, 231: 131, 236: 132, 209: 133, 263: 134, 69: 135,
            197: 136, 170: 137, 267: 138, 282: 139, 132: 140, 141: 141, 214: 142, 131: 143, 212: 144,
            196: 145, 21: 146, 57: 147, 205: 147, 154: 149, 99: 150, 24: 151, 18: 152,
            // Ranks 153-179
            1: 153, 220: 154, 249: 155, 305: 156, 237: 156, 169: 157, 224: 158, 85: 158, 186: 159,
            294: 160, 174: 160, 177: 161, 51: 162, 317: 163, 88: 163, 135: 164, 153: 165, 143: 166,
            109: 167, 137: 168, 111: 169, 72: 169, 215: 169, 13: 171, 96: 171, 288: 172, 253: 173,
            308: 174, 83: 174, 122: 175, 178: 176, 248: 177, 10: 178, 304: 179, 184: 179,
            // Ranks 180-207
            195: 180, 166: 181, 312: 182, 125: 182, 292: 183, 254: 183, 59: 184, 183: 184, 124: 185,
            79: 186, 188: 187, 240: 188, 33: 189, 287: 190, 64: 191, 241: 192, 41: 193, 192: 193,
            286: 195, 246: 196, 273: 197, 55: 198, 139: 198, 315: 199, 201: 200, 264: 201, 198: 201,
            313: 202, 167: 203, 93: 204, 67: 204, 291: 204, 14: 205, 46: 205, 62: 207, 104: 207,
            // Ranks 208-237
            302: 208, 179: 208, 185: 208, 268: 208, 35: 211, 28: 211, 130: 212, 25: 213, 235: 214,
            226: 215, 278: 216, 258: 217, 182: 218, 227: 219, 47: 220, 38: 221, 105: 221, 270: 222,
            6: 223, 156: 224, 61: 224, 243: 226, 187: 227, 271: 228, 252: 229, 158: 229, 84: 231,
            280: 232, 180: 233, 159: 234, 19: 235, 289: 236, 120: 237, 77: 237,
            // Ranks 238-269
            259: 238, 22: 239, 116: 240, 40: 241, 213: 242, 211: 243, 80: 244, 50: 245, 275: 246,
            95: 247, 284: 248, 129: 249, 103: 250, 68: 251, 257: 252, 78: 252, 290: 253, 63: 254,
            276: 255, 295: 255, 65: 256, 152: 257, 42: 258, 8: 258, 239: 259, 17: 259, 106: 262,
            168: 263, 261: 264, 5: 264, 75: 266, 110: 266, 245: 267, 128: 268, 123: 269, 97: 269, 31: 269, 23: 269,
            // Ranks 273-295
            140: 273, 293: 293, 306: 294, 320: 295
        };
        let tokenRarityRanks = {...OPENSEA_RARITY_RANKS}; // OpenSea rarity data
        let traitValues = { timeOfDay: new Set(), energy: new Set(), palette: new Set(), bounds: new Set(), traffic: new Set(), line: new Set(), render: new Set(), zoom: new Set(), water: new Set() };
        let exploreInterval = null;
        let isFullscreen = false;
        let touchStartX = 0;
        let touchEndX = 0;

        const loadingBarContainer = document.getElementById('loadingBarContainer');
        const loadingBar = document.getElementById('loadingBar');
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        const frameContainer = document.getElementById('frameContainer');
        const previewImage = document.getElementById('preview-image');
        const tokenIdInput = document.getElementById('tokenId');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const displayToken = document.getElementById('displayToken');
        const ownerDisplay = document.getElementById('ownerDisplay');
        const galleryPanel = document.getElementById('galleryPanel');
        const galleryGrid = document.getElementById('galleryGrid');
        const favCount = document.getElementById('favCount');
        const statusMessage = document.getElementById('statusMessage');
        const traitsDisplay = document.getElementById('traitsDisplay');
        const matchCount = document.getElementById('matchCount');
        const collectorsPanel = document.getElementById('collectorsPanel');
        const supplyTracker = document.getElementById('supplyTracker');
        const filterTime = document.getElementById('filterTime');
        const filterEnergy = document.getElementById('filterEnergy');
        const filterPalette = document.getElementById('filterPalette');
        const filterBounds = document.getElementById('filterBounds');
        const filterTraffic = document.getElementById('filterTraffic');
        const filterLine = document.getElementById('filterLine');
        const filterRender = document.getElementById('filterRender');
        const filterZoom = document.getElementById('filterZoom');
        const filterWater = document.getElementById('filterWater');

        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return { token: params.get('token') || params.get('t') };
        }

        function updateUrlWithToken(tokenId) {
            const url = new URL(window.location);
            url.searchParams.set('token', tokenId);
            window.history.replaceState({}, '', url);
        }

        function loadCachedTraits() {
            try {
                const cached = localStorage.getItem(TRAITS_CACHE_KEY);
                if (cached) {
                    const { data, timestamp } = JSON.parse(cached);
                    if (Date.now() - timestamp < CACHE_EXPIRY) { tokenTraits = data; return true; }
                }
            } catch (e) { console.error('Cache error', e); }
            return false;
        }

        function saveCachedTraits() {
            try { localStorage.setItem(TRAITS_CACHE_KEY, JSON.stringify({ data: tokenTraits, timestamp: Date.now() })); } catch (e) {}
        }

        function getTokenRarityRank(tokenId) {
            return tokenRarityRanks[tokenId] || null;
        }

        function showLoadingBar() { loadingBarContainer.classList.add('visible'); }
        function hideLoadingBar() { loadingBarContainer.classList.remove('visible'); loadingBar.style.width = '0%'; }
        function updateLoadingBar(progress) { loadingBar.style.width = `${progress}%`; }

        function toggleMobileMenu() {
            const isOpen = sidebar.classList.toggle('open');
            mobileMenuToggle.classList.toggle('active', isOpen);
            sidebarOverlay.classList.toggle('visible', isOpen);
            document.body.style.overflow = isOpen ? 'hidden' : '';
        }

        function closeMobileMenu() {
            sidebar.classList.remove('open');
            mobileMenuToggle.classList.remove('active');
            sidebarOverlay.classList.remove('visible');
            document.body.style.overflow = '';
        }

        mobileMenuToggle.addEventListener('click', toggleMobileMenu);
        sidebarOverlay.addEventListener('click', closeMobileMenu);

        // Prevent browser zoom from Ctrl+wheel or pinch gestures
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
            }
        }, { passive: false });

        // Handle window resize to fix responsive state
        let resizeTimeout;
        let resizeEndTimeout;
        window.addEventListener('resize', () => {
            // Add resizing class immediately to disable animations
            document.body.classList.add('resizing');

            clearTimeout(resizeTimeout);
            clearTimeout(resizeEndTimeout);

            resizeTimeout = setTimeout(() => {
                const isMobile = window.innerWidth <= 768;
                if (!isMobile) {
                    // Reset mobile menu state when going to desktop
                    closeMobileMenu();
                    sidebar.classList.remove('open');
                }
            }, 100);

            // Remove resizing class after resize ends
            resizeEndTimeout = setTimeout(() => {
                document.body.classList.remove('resizing');
            }, 150);
        });

        function getGeneratorUrl(tokenId) { return `${GENERATOR}/${CONTRACT}/${tokenId}`; }
        function getPreviewUrl(tokenId) { return `${MEDIA_BASE}/${CONTRACT}/${tokenId}.png`; }
        function getThumbnailUrl(tokenId) { return `${MEDIA_BASE}/${CONTRACT}/${tokenId}.png?width=200`; }
        function getSmallThumbnailUrl(tokenId) { return `${MEDIA_BASE}/${CONTRACT}/${tokenId}.png?width=50`; }
        function getMicroThumbnailUrl(tokenId) { return `${MEDIA_BASE}/${CONTRACT}/${tokenId}.png?width=20`; }

        // Helper to parse hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 128, g: 128, b: 128 };
        }

        // Helper to convert RGB to hex
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => Math.round(Math.max(0, Math.min(255, x))).toString(16).padStart(2, '0')).join('');
        }

        // Calculate relative luminance
        function getLuminance(hex) {
            const rgb = hexToRgb(hex);
            const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(c => {
                c = c / 255;
                return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        // Get contrast ratio between two colors
        function getContrastRatio(hex1, hex2) {
            const l1 = getLuminance(hex1);
            const l2 = getLuminance(hex2);
            const lighter = Math.max(l1, l2);
            const darker = Math.min(l1, l2);
            return (lighter + 0.05) / (darker + 0.05);
        }

        // Adjust spot color for contrast against background
        function getContrastingSpotColor(spotColor, bgColor) {
            const contrast = getContrastRatio(spotColor, bgColor);
            if (contrast >= 2.5) return spotColor; // Good enough contrast

            const spotRgb = hexToRgb(spotColor);
            const bgLum = getLuminance(bgColor);

            // If background is dark, lighten the spot color; if light, darken it
            const factor = bgLum > 0.5 ? 0.6 : 1.6;
            const adjusted = rgbToHex(
                spotRgb.r * factor + (factor > 1 ? 40 : 0),
                spotRgb.g * factor + (factor > 1 ? 40 : 0),
                spotRgb.b * factor + (factor > 1 ? 40 : 0)
            );

            // If still not enough contrast, go more extreme
            if (getContrastRatio(adjusted, bgColor) < 2.5) {
                return bgLum > 0.5 ? '#333333' : '#FFFFFF';
            }
            return adjusted;
        }

        // Global handler for grid item clicks (inline onclick)
        window.handleGridItemClick = function(e, tokenId) {
            try {
                if (e.target.closest('.grid-item-fav')) return;
                e.stopPropagation();
                e.preventDefault();

                // Capture grid's visual order for prev/next navigation
                // This preserves the current view (gradient sort, palette groups, filters, etc.)
                var gridItems = document.querySelectorAll('#gridContent .grid-item[data-token]');
                if (gridItems.length > 0) {
                    var items = Array.from(gridItems);
                    // Sort by CSS order property (used by gradient mode), then DOM order
                    items.sort(function(a, b) {
                        var oA = a.style.order !== '' ? parseInt(a.style.order) : 9999999;
                        var oB = b.style.order !== '' ? parseInt(b.style.order) : 9999999;
                        if (oA !== oB) return oA - oB;
                        return 0; // preserve DOM order for non-ordered items
                    });
                    window.gridNavigationList = items.map(function(el) {
                        return parseInt(el.dataset.token);
                    }).filter(function(id) { return !isNaN(id); });
                }

                // Immediately hide the old image to prevent ghost effect
                var previewImg = document.getElementById('preview-image');
                if (previewImg) {
                    previewImg.classList.add('fade-out');
                }

                // Close the grid panel
                var gp = document.getElementById('gridPanel');
                var vtb = document.getElementById('viewToggleBtn');
                if (gp) gp.classList.remove('open');
                if (vtb) vtb.classList.remove('grid-open');
                document.body.classList.remove('grid-open');

                // Clear sidebar filters so navigation works through all cities
                if (typeof clearFilters === 'function') {
                    clearFilters();
                }

                // Load the output directly - use window.loadOutput for global access
                setTimeout(function() {
                    if (typeof window.loadOutput === 'function') {
                        window.loadOutput(tokenId, true);
                    }
                }, 50);
            } catch (err) {
                console.error('Grid click error:', err);
            }
        };

        // Global handler for + button (more controls toggle)
        window.toggleMoreControls = function(e) {
            e.stopPropagation();
            const toggle = document.getElementById('moreControlsToggle');
            const menu = document.getElementById('moreControlsMenu');
            if (toggle && menu) {
                toggle.classList.toggle('open');
                menu.classList.toggle('open');
            }
        };

        // Global handlers for + menu tools (inline onclick)
        window.openGalleryRoomGlobal = function(e) {
            e && e.stopPropagation();
            if (window.openGalleryRoom) window.openGalleryRoom();
        };
        window.openCompareModeGlobal = function(e) {
            e && e.stopPropagation();
            // Open grid first, then enable comparison select mode
            var gp = document.getElementById('gridPanel');
            if (gp && !gp.classList.contains('open')) {
                gp.classList.add('open');
                document.body.classList.add('grid-open');
            }
            if (window.showComparisonSelectUI) window.showComparisonSelectUI();
        };
        window.openPlaygroundGlobal = function(e) {
            e && e.stopPropagation();
            if (window.openPlayground) window.openPlayground();
        };
        window.openOriginalsGlobal = function(e) {
            e && e.stopPropagation();
            if (window.openTimeline) window.openTimeline();
        };

        // Global handlers for sidebar footer buttons (inline onclick)
        window.openCollectorsList = function() {
            const collectorsPanel = document.getElementById('collectorsPanel');
            if (collectorsPanel) {
                collectorsPanel.classList.add('open');
                document.body.classList.add('collectors-open');
                const galleryPanel = document.getElementById('galleryPanel');
                if (galleryPanel) galleryPanel.classList.remove('open');
                // Start auto-reveal timer for patrons section
                startPatronsAutoReveal();
            }
        };
        window.toggleFavoritesGallery = function() {
            const galleryPanel = document.getElementById('galleryPanel');
            const collectorsPanel = document.getElementById('collectorsPanel');
            if (galleryPanel) {
                galleryPanel.classList.toggle('open');
                if (collectorsPanel) collectorsPanel.classList.remove('open');
                if (typeof updateGallery === 'function') updateGallery();
            }
        };
        window.openCollectionPlanner = function() {
            const modal = document.getElementById('collectionPlannerModal');
            if (modal) {
                modal.classList.add('open');
                if (typeof updateCollectionPlanner === 'function') updateCollectionPlanner();
            }
        };
        window.toggleKeyboardShortcuts = function() {
            const hints = document.getElementById('keyboardHints');
            if (hints) {
                hints.style.display = hints.style.display === 'none' ? 'block' : 'none';
            }
        };

        function generateGridItem(id, showRank = false, rank = 0, eagerLoad = false) {
            const traits = tokenTraits[id];
            const palette = traits?.['Palette'];
            const paletteData = PALETTE_DATA[palette];
            const bgColor = paletteData?.bg || '#1a1a2e';
            const rawSpotColor = paletteData?.colors?.[10] || '#FFE135';
            const spotColor = getContrastingSpotColor(rawSpotColor, bgColor);
            // Find a contrasting color from the palette for the heart icon
            const colors = paletteData?.colors || [];
            let spotTextColor = getLuminance(spotColor) > 0.5 ? '#000' : '#fff';
            // Try to find a palette color that contrasts well with the spot color
            for (const c of [colors[0], colors[1], colors[2], colors[3], bgColor, colors[11]]) {
                if (c && getContrastRatio(c, spotColor) >= 3) {
                    spotTextColor = c;
                    break;
                }
            }
            const loadingAttr = eagerLoad ? 'eager' : 'lazy';
            return `
                <div class="grid-item" data-token="${id}" onclick="handleGridItemClick(event, ${id})" style="background:${bgColor}; --spot-color:${spotColor}; --spot-text:${spotTextColor};">
                    <button class="grid-item-fav ${isCityFavorited(id) ? 'favorited' : ''}" data-token="${id}">â™¥</button>
                    <div class="compare-check">âœ“</div>
                    <img src="${getSmallThumbnailUrl(id)}" alt="" loading="${loadingAttr}" decoding="async">
                    <div class="grid-item-label">#${id}</div>
                    ${showRank && rank ? `<div class="grid-item-rank">#${rank}</div>` : ''}
                    ${generateGridTooltip(id)}
                </div>
            `;
        }

        // ============================================
        // ORIGINS DATA - Timeline pieces that led to Cities
        // ============================================
        const ORIGINS_DATA = [
            // 2020 - Open Minds
            { id: 'om1', title: 'You Are Here', year: 2020, collection: 'Open Minds', collector: 'Sighduck', img: 'https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128130116-DDEYOHRNG1IRBEEXG1JD/Efdot_Open+Mind+1_You+Are+Here.gif', link: 'https://opensea.io/collection/efdot-openminds', desc: 'Places the viewer on top of a map, showing a cross section of a metaphysical city.', colors: ['#FFB347', '#87CEEB', '#DDA0DD'], energy: 'Living' },
            { id: 'om2', title: 'Night Mode', year: 2020, collection: 'Open Minds', collector: 'Valdi', img: 'https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128174409-8EGQR3U2UDYK7SK91Z19/Efdot_Open+Mind+2_Night+Mode.gif', link: 'https://opensea.io/collection/efdot-openminds', desc: 'The curiosity cruise control that comes on late at night.', colors: ['#1a1a2e', '#4a5568', '#6366f1'], energy: 'Resting' },
            { id: 'om3', title: 'Passing Through', year: 2020, collection: 'Open Minds', collector: 'Fin444', img: 'https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128270023-9JC2N4SS09UHMA4LR5NN/Efdot_Open+Minds+3_Passing+Through.gif', link: 'https://opensea.io/collection/efdot-openminds', desc: 'The transience of the moment, constant fluid motion.', colors: ['#FF6B6B', '#4ECDC4', '#FFE66D'], energy: 'Living' },
            { id: 'om6', title: 'Sweet Streets', year: 2020, collection: 'Open Minds', collector: 'AMT Collections', img: 'https://images.squarespace-cdn.com/content/v1/54a5c373e4b02cb3ce08c96f/1633128443026-X974A5CT72RIUD8KFZY7/Efdot_Open+Minds+6_Sweet+Streets.gif', link: 'https://opensea.io/collection/efdot-openminds', desc: 'A mind map of a place visited in the brain.', colors: ['#FF9A9E', '#FECFEF', '#A18CD1'], energy: 'Living' },

            // 2021 - O.M.A.G.E.
            { id: 'omage', title: 'O.M.A.G.E.', year: 2021, collection: 'O.M.A.G.E.', img: 'https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiek2l25mxxsd54ptgtmnlmr4gsd4tgtd7nnee3uckh4hn3zdb52ce', link: 'https://opensea.io/collection/efdot-openminds', desc: 'A major turning point. The first generative system.', colors: ['#E8B86D', '#FF8C42', '#D4A574'], energy: 'Rising', featured: true },
            { id: 'summer365', title: 'Summer 365', year: 2021, collection: 'O.M.A.G.E.', collector: '0x17Bf...072B', img: 'https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/1/nft.jpg?auto=format%2Ccompress&q=90&cs=srgb&h=3000&w=3000&fnd_key=v1', link: 'https://foundation.app/mint/eth/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/1', desc: '365 days of summer on one canvas.', colors: ['#FFE135', '#FF6B35', '#F7B267'], energy: 'Living' },
            { id: 'winterplay', title: 'Winterplay', year: 2021, collection: 'O.M.A.G.E.', collector: 'Coinbilly', img: 'https://f8n-production-collection-assets.imgix.net/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/2/nft.jpg?auto=format%2Ccompress&q=70&cs=srgb&h=1200&w=1200&fnd_key=v1', link: 'https://foundation.app/mint/eth/0xaE4b4f1Ec7fA311651Aa4DF1461b522F911F5Da2/2', desc: 'Cold gradients and warm corners.', colors: ['#A8DADC', '#457B9D', '#1D3557'], energy: 'Resting' },
            { id: 'luminosity', title: 'Luminosity', year: 2023, collection: 'Cities // Efdot Originals', collector: '0x17Bf...072B', img: 'https://e7bvegr35i4w3uqygtu2op3rwjaglmdnrovpbvwg6j66wh2a7mvq.arweave.net/J8NSGjvqOW3SGDTppz9xskBlsG2LqvDWxvJ96x9A-ys', link: 'https://foundation.app/mint/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/23', desc: 'Light radiating from the city center.', colors: ['#FFE4B5', '#FFA500', '#FF8C00'], energy: 'Rising' },

            // Additional Efdot Originals owned by collectors (hideFromGrid: true means only shown in collector profiles, not in origins grid)
            { id: 'inverted', title: 'Inverted Reality', year: 2021, collection: 'Cities // Efdot Originals', collector: 'WillEP', img: 'https://qld2vwvxjaq7lqoy36pbvgqnoipqegjl4xvl2kihw6vedyy3yb5a.arweave.net/gseq2rdIIfXB2N-eGpoNch8CGSvl6r0pB7eqQeMbwHo', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/11', desc: 'The city flipped. A new perspective on the familiar grid.', colors: ['#1a1a2e', '#4a5568', '#E8B86D'], energy: 'Living', hideFromGrid: true },

            // 2022-2024 - Cities // Efdot Originals (SuperRare)
            { id: 'eye', title: 'Eye of the City', year: 2022, collection: 'Cities // Efdot Originals', collector: 'Reginald de la Grarbs', img: 'https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiga6qzupgcz3joz3jdywwyk2fuzc2jukmohfij5tzs44rw5rzhqba', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/22', desc: 'Urban observations frozen in motion. A reflection of simplicity and chaos. Created live at The Gateway, Miami during Art Basel 2022.', colors: ['#2D3047', '#93B7BE', '#E0CA3C'], energy: 'Living', featured: true },
            { id: 'lightpulp', title: 'Light Pulp', year: 2022, collection: 'Cities // Efdot Originals', collector: 'Easp0rts', img: 'https://nft-cdn.alchemy.com/eth-mainnet/24cacdfcf8625283c2cd21244136ae80', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/17', desc: 'Like pulp floating in orange juice. A city on an island.', colors: ['#FF9500', '#FFB347', '#FFCC00'], energy: 'Rising' },
            { id: 'midnight', title: 'Midnight In Manhattan', year: 2022, collection: 'Cities // Efdot Originals', collector: 'Sendrock', img: 'https://arweave.net/dUzBTD-4kZZHEITC_6HEWrHb4HzIxKzslAEeLznkHRQ', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/27', desc: 'Manhattan at midnight. Could be more than one-offs.', colors: ['#0D0D0D', '#1A1A2E', '#4A5568'], energy: 'Resting' },
            { id: 'hazyday', title: 'Hazy Day', year: 2022, collection: 'Cities // Efdot Originals', collector: 'Cosimo De Medici', img: 'https://arweave.net/hEokztJ9b7fxAtGf1eiwi2QRWkMY5F8UlJOa0rlHqag', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/28', desc: 'Orange and pink fog. Some days you can\'t see past the next block.', colors: ['#FF8C42', '#FFA07A', '#DDA0DD'], energy: 'Fading' },
            { id: 'streetview', title: 'Street View', year: 2023, collection: 'Cities // Efdot Originals', collector: 'Diid', img: 'https://arweave.net/pk00hY7LdV6c8q6l3OiVP6GSRYG-Sx_KeDIearNK878', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/29', desc: 'Candy colors pooling at intersections.', colors: ['#FF6B6B', '#4ECDC4', '#FFE66D'], energy: 'Living' },
            { id: 'brainfog', title: 'Brain Fog', year: 2023, collection: 'Cities // Efdot Originals', img: 'https://arweave.net/cTSB-Acjliv_eqJqlWFtsbNB5Wpwwr_j-ck1cshWaTk', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/31', desc: 'Seven floors of foggy windows frame the blue world.', colors: ['#87CEEB', '#B0E0E6', '#ADD8E6'], energy: 'Living', available: true, price: '2 ETH' },
            { id: 'traffic', title: 'Traffic on the Avenue', year: 2023, collection: 'Cities // Efdot Originals', collector: 'Redbeard', img: 'https://arweave.net/3Hlm3Mo0by9mqa7H2hH6TT4ioB0vI1LaVgWXD61Addk', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/33', desc: 'Rush hour rendered in brushstrokes.', colors: ['#FFE135', '#FF6B35', '#DC2626'], energy: 'Living' },
            { id: 'roundabout', title: 'Roundabout', year: 2023, collection: 'Cities // Efdot Originals', collector: 'Paperbuddha', img: 'https://arweave.net/6ucEGXVGd9S5s2f9fnIEQqUc4-X0zCnuUD-_XNwpsVM', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/34', desc: 'Circular logic, circular roads.', colors: ['#9333EA', '#A855F7', '#C084FC'], energy: 'Living' },
            { id: 'silent', title: 'Silent Skyline', year: 2024, collection: 'Cities // Efdot Originals', collector: 'Blondie', img: 'https://arweave.net/qEiCFd9Y3U0UAE63z3sCZkmDDlZ1sKKQgkzQWZQkJBg', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/36', desc: 'Early morning, no traffic yet. The city holding its breath.', colors: ['#FDE68A', '#FCD34D', '#F59E0B'], energy: 'Rising' },
            { id: 'vibrancy', title: 'Vibrancy', year: 2024, collection: 'Cities // Efdot Originals', collector: 'BatSoupYum', img: 'https://arweave.net/QovS8UL0HHe8Cex0owceng4YdWhW08gMm_zg-Jzx7dY', link: 'https://superrare.com/artwork/eth/0x822F1418072e15e1d1f07533138b35A72a8a0f55/42', desc: 'Vibrant city energy.', colors: ['#FF6B6B', '#4ECDC4', '#FFE66D'], energy: 'Living' },
            { id: 'cityinbloom', title: 'City in Bloom', year: 2024, collection: 'Cities // Efdot Originals', collector: 'Alex Zuttre', img: 'https://nft-cdn.alchemy.com/eth-mainnet/bf524597b88d4936737d66df0ba5f368', link: 'https://superrare.com/artwork/eth/0x51650bf8cda4d93b00dbfa97f65aba14a82b2a9e/1', desc: 'Wall to screen. The Rio mural became digital.', colors: ['#EC4899', '#F472B6', '#10B981'], energy: 'Living', featured: true },
            { id: 'desertgrid', title: 'Desert Grid', year: 2025, collection: 'Cities // Marfa', collector: 'Norcal & Klutch', img: 'https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeigq7rytbitvgnmil3i5h3tqvekqcw5f2z4zy5pzfjcbk5dtnbc2yy', link: 'https://opensea.io/item/ethereum/0x10abb881add1de70d4a9b2c712b9a8ac8853418b/4', desc: 'One piece with two dynamic states. Day and night in the Texas desert.', colors: ['#F4A460', '#DEB887', '#1a1a2e'], energy: 'Living' },

            // 2025 - Cities // Italy (9 pieces on Ninfa)
            { id: 'italy1', title: 'Echo Hill', year: 2025, collection: 'Cities // Italy', collector: 'Soren Wrenn', img: 'https://images.ninfa.io/nfts/original/c8330669474b599172d9caf56c186cb5d60a1483ae7a114734313a20ca8b8df1.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Italian hilltop echoes.', colors: ['#D4A574', '#8B4513', '#CD853F'], energy: 'Living' },
            { id: 'italy2', title: 'Around the Duomo', year: 2025, collection: 'Cities // Italy', collector: 'Soren Wrenn', img: 'https://images.ninfa.io/nfts/original/ea9a2b42ef67db20ce7fb63c592e9f75036e874df9ea593835384ede046be449.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Circling the cathedral.', colors: ['#DAA520', '#B8860B', '#CD853F'], energy: 'Living' },
            { id: 'italy3', title: 'Through The Piazza', year: 2025, collection: 'Cities // Italy', collector: 'M Studio', img: 'https://images.ninfa.io/nfts/original/e9ff95e5215d28b765cabcb3b2360520266c86d74683b7ecaa59630f5e0db086.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Crossing the square.', colors: ['#4682B4', '#5F9EA0', '#20B2AA'], energy: 'Living' },
            { id: 'italy4', title: 'Shifted Shadow', year: 2025, collection: 'Cities // Italy', collector: 'Almost Serious Gallery', img: 'https://images.ninfa.io/nfts/original/c16d801ae69e5ed00046d63b8ed30be387e477297a62767d1178f142add4a31b.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Light moving across stone.', colors: ['#6B7280', '#9CA3AF', '#D1D5DB'], energy: 'Fading' },
            { id: 'italy5', title: 'Last Lap', year: 2025, collection: 'Cities // Italy', collector: 'Georgie', img: 'https://images.ninfa.io/nfts/original/ed64013129837544d5fe74e63f414a6c74fee743b95f9e5223e911ac0303a476.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Final circuit around the city.', colors: ['#FF6B6B', '#4ECDC4', '#FFE66D'], energy: 'Living' },
            { id: 'italy6', title: 'Radial Intent', year: 2025, collection: 'Cities // Italy', collector: 'R Alderman', img: 'https://images.ninfa.io/nfts/original/a2cc2905f3f49f56757890038b3cf715bcc4139a05660b378f43b4fa9c93b9af.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Radiating from center.', colors: ['#E8B86D', '#FF8C42', '#D4A574'], energy: 'Rising' },
            { id: 'italy7', title: 'Across the Arno', year: 2025, collection: 'Cities // Italy', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/d3ca7d2aa862e1ff132864f703c8680d1038bc470c279db28909cbaa0c8c79ad.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Bridging the river in Florence.', colors: ['#4682B4', '#87CEEB', '#B0E0E6'], energy: 'Living' },
            { id: 'italy8', title: 'Drawn To Center', year: 2025, collection: 'Cities // Italy', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/fa42a57fcc480226220ec5cf90dd1a6b58a567ccf49b52f35c9ee91170498a63.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Pulled toward the heart.', colors: ['#9333EA', '#A855F7', '#C084FC'], energy: 'Living' },
            { id: 'italy9', title: 'Walled Memory', year: 2025, collection: 'Cities // Italy', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/f9bd77a279884e9b4ed1edeaa8f213cec0f8c210a4558eb2f6c01c021f540200.jpeg', link: 'https://citiesitaly.ninfa.io/', desc: 'Ancient walls holding stories.', colors: ['#D4A574', '#A0522D', '#8B4513'], energy: 'Resting' },

            // Editions
            { id: 'twobridges', title: 'Two Bridges', year: 2022, collection: 'Editions', img: 'https://ipfs.io/ipfs/bafybeidjajtk5byo2cg7ipid24lywtlqcnlnnkcztmfk3mu7fnqtwavaji', link: 'https://opensea.io/item/ethereum/0xc80d40e86c91dc4a713c5e2e9d8fc47c6b6a68fd/181000100001', desc: 'An ode to the LES. Dynamic, changes with seasons.', colors: ['#4ECDC4', '#45B7D1', '#96E6A1'], energy: 'Living', edition: 10 },
            { id: 'overbridge', title: 'Over the Bridge', year: 2024, collection: 'Editions', img: 'https://blush-worried-heron-358.mypinata.cloud/ipfs/Qmdo2hzEGfXV6Ep3A2K8KHK7mg4XVUvKMbDG4Xu2Pj8LB2', link: 'https://opensea.io/item/ethereum/0xdb1f952239c6e89af76dd1226e7cb1fa57463e5e/127', desc: 'A traffic study painted as a mural in Brooklyn.', colors: ['#3B82F6', '#60A5FA', '#93C5FD'], energy: 'Living', edition: 50 }
        ];

        // Get originals owned by a collector (case-insensitive match with alias support)
        function getCollectorOriginals(collectorName) {
            if (!collectorName) return [];
            // Normalize the input name using alias system
            const normalizedInput = applyNameAlias(collectorName).toLowerCase();
            return ORIGINS_DATA.filter(o => {
                if (!o.collector) return false;
                // Normalize the origin's collector name too
                const normalizedCollector = applyNameAlias(o.collector).toLowerCase();
                return normalizedCollector === normalizedInput;
            });
        }

        // Get optimized thumbnail URL - reduces image size for faster loading
        function getThumbUrl(url, size = 300) {
            if (!url) return '';
            // Squarespace images - add format params
            if (url.includes('squarespace-cdn.com')) {
                return url + (url.includes('?') ? '&' : '?') + `format=auto&fit=crop&w=${size}&h=${size}`;
            }
            // Foundation images - already have imgix params, update them
            if (url.includes('f8n-production') && url.includes('imgix.net')) {
                return url.replace(/h=\d+/, `h=${size}`).replace(/w=\d+/, `w=${size}`);
            }
            // Ninfa images - use smaller variant (images.ninfa.io/nfts/original/)
            if (url.includes('images.ninfa.io/nfts/')) {
                // Ninfa supports resizing via query params
                return url + (url.includes('?') ? '&' : '?') + `w=${size}&h=${size}&fit=cover`;
            }
            // Alchemy NFT CDN - can add size
            if (url.includes('nft-cdn.alchemy.com')) {
                return url + `?w=${size}&h=${size}`;
            }
            // For IPFS/arweave/pinata - no reliable resize, return original
            return url;
        }

        // Generate origin grid item HTML
        function generateOriginItem(origin) {
            const availableClass = origin.available ? ' available' : '';
            // Only show edition size if it's an edition, otherwise no collection label (it's in the group header)
            const editionLabel = origin.edition ? `<span class="origin-item-edition">1/${origin.edition}</span>` : '';
            // Use optimized thumbnail URL for faster loading
            const thumbUrl = getThumbUrl(origin.img, 300);
            return `
                <div class="origin-item${availableClass}" data-origin="${origin.id}" onclick="handleOriginItemClick('${origin.id}')">
                    <img src="${thumbUrl}" alt="${origin.title}" loading="lazy" decoding="async" width="300" height="300">
                    <span class="origin-item-year">${origin.year}</span>
                    ${editionLabel}
                    <div class="origin-item-label">${origin.title}${origin.price ? ` Â· ${origin.price}` : ''}</div>
                </div>
            `;
        }

        // Origins Frame View state
        let currentOriginsFrameIndex = 0;
        const originsFrame = document.getElementById('originsFrame');
        const originsFrameImage = document.getElementById('originsFrameImage');
        const originsFrameTitle = document.getElementById('originsFrameTitle');
        const originsFrameYear = document.getElementById('originsFrameYear');
        const originsFrameCollection = document.getElementById('originsFrameCollection');
        const originsFrameWrapper = document.getElementById('originsFrameWrapper');
        const originsFrameClose = document.getElementById('originsFrameClose');
        const originsFramePrev = document.getElementById('originsFramePrev');
        const originsFrameNext = document.getElementById('originsFrameNext');

        function updateOriginsFrameView(index) {
            const origin = ORIGINS_DATA[index];
            if (!origin) return;

            originsFrameImage.src = origin.img;
            originsFrameTitle.textContent = origin.title;
            originsFrameYear.textContent = origin.year;
            originsFrameCollection.textContent = origin.collection;

            // Store link for clicking on artwork
            originsFrameWrapper.dataset.link = origin.link || '';

            // Update nav buttons
            originsFramePrev.disabled = ORIGINS_DATA.length <= 1;
            originsFrameNext.disabled = ORIGINS_DATA.length <= 1;

            currentOriginsFrameIndex = index;
        }

        function openOriginsFrame(originId) {
            const index = ORIGINS_DATA.findIndex(o => o.id === originId);
            if (index === -1) return;
            updateOriginsFrameView(index);
            originsFrame.classList.add('open');
        }

        function closeOriginsFrame() {
            originsFrame.classList.remove('open');
        }

        // Handle clicking on an origin item - opens frame view
        window.handleOriginItemClick = function(originId) {
            const origin = ORIGINS_DATA.find(o => o.id === originId);
            if (!origin) return;

            // Open the framed gallery view
            openOriginsFrame(originId);
        };

        // Origins frame navigation
        originsFrameClose?.addEventListener('click', closeOriginsFrame);
        originsFramePrev?.addEventListener('click', () => {
            const newIndex = (currentOriginsFrameIndex - 1 + ORIGINS_DATA.length) % ORIGINS_DATA.length;
            updateOriginsFrameView(newIndex);
        });
        originsFrameNext?.addEventListener('click', () => {
            const newIndex = (currentOriginsFrameIndex + 1) % ORIGINS_DATA.length;
            updateOriginsFrameView(newIndex);
        });

        // Click on framed artwork to go to marketplace (with warning on desktop)
        originsFrameWrapper?.addEventListener('click', () => {
            const link = originsFrameWrapper.dataset.link;
            if (link) {
                // Determine marketplace name from link
                let marketplace = 'the marketplace';
                if (link.includes('opensea.io')) marketplace = 'OpenSea';
                else if (link.includes('superrare.com')) marketplace = 'SuperRare';
                else if (link.includes('foundation.app')) marketplace = 'Foundation';
                else if (link.includes('ninfa.io')) marketplace = 'Ninfa';

                // Show warning on desktop (non-touch devices)
                const isDesktop = !('ontouchstart' in window);
                if (isDesktop) {
                    const confirmed = confirm(`You're about to leave Cities Explorer and visit ${marketplace}. Continue?`);
                    if (!confirmed) return;
                }
                window.open(link, '_blank');
            }
        });

        // Click outside to close
        originsFrame?.addEventListener('click', (e) => {
            if (e.target === originsFrame || e.target.classList.contains('origins-frame-content')) {
                closeOriginsFrame();
            }
        });

        // Keyboard navigation for origins frame
        document.addEventListener('keydown', (e) => {
            if (!originsFrame?.classList.contains('open')) return;

            if (e.key === 'Escape') {
                closeOriginsFrame();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const newIndex = (currentOriginsFrameIndex - 1 + ORIGINS_DATA.length) % ORIGINS_DATA.length;
                updateOriginsFrameView(newIndex);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const newIndex = (currentOriginsFrameIndex + 1) % ORIGINS_DATA.length;
                updateOriginsFrameView(newIndex);
            } else if (e.key === 'Enter') {
                const link = originsFrameWrapper?.dataset.link;
                if (link) window.open(link, '_blank');
            }
        });

        // O.M.A.G.E. Monoprint Inquiry Modal
        window.openOmageInquiry = function() {
            // Create modal if it doesn't exist
            let modal = document.getElementById('omageInquiryModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'omageInquiryModal';
                modal.className = 'omage-inquiry-modal';
                modal.innerHTML = `
                    <div class="omage-inquiry-content">
                        <button class="omage-inquiry-close" onclick="closeOmageInquiry()">Ã—</button>
                        <div class="omage-inquiry-header">
                            <div class="omage-inquiry-title">O.M.A.G.E. Monoprints</div>
                            <div class="omage-inquiry-subtitle">Open Minds Analog Generative Experiment</div>
                        </div>
                        <div class="omage-inquiry-body">
                            <div class="omage-inquiry-image">
                                <img loading="lazy" src="https://blush-worried-heron-358.mypinata.cloud/ipfs/bafybeiek2l25mxxsd54ptgtmnlmr4gsd4tgtd7nnee3uckh4hn3zdb52ce" alt="O.M.A.G.E.">
                            </div>
                            <div class="omage-inquiry-details">
                                <p><strong>18" Ã— 18" Screen Prints</strong></p>
                                <p>12 unique monoprints available via private sale. Each O.M.A.G.E. is one of a kind, layered by hand from three Open Minds pieces. This is Efdot's first generative series, created before Cities existed.</p>
                                <p style="margin-top: 12px; font-size: 11px; color: var(--text-muted);">Inquire for pricing and availability.</p>
                            </div>
                        </div>
                        <div class="omage-inquiry-form">
                            <input type="text" id="omageInquiryName" placeholder="Your name" class="omage-inquiry-input">
                            <input type="email" id="omageInquiryEmail" placeholder="Your email" class="omage-inquiry-input">
                            <textarea id="omageInquiryMessage" placeholder="Message (optional)" class="omage-inquiry-input omage-inquiry-textarea"></textarea>
                            <button class="omage-inquiry-submit" onclick="submitOmageInquiry()">Send Inquiry</button>
                        </div>
                        <div class="omage-inquiry-success" id="omageInquirySuccess" style="display: none;">
                            <div style="font-size: 24px; margin-bottom: 8px;">âœ“</div>
                            <div>Inquiry sent! Efdot will be in touch.</div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            modal.classList.add('open');
        };

        window.closeOmageInquiry = function() {
            const modal = document.getElementById('omageInquiryModal');
            if (modal) modal.classList.remove('open');
        };

        window.submitOmageInquiry = async function() {
            const name = document.getElementById('omageInquiryName').value.trim();
            const email = document.getElementById('omageInquiryEmail').value.trim();
            const message = document.getElementById('omageInquiryMessage').value.trim();

            if (!name || !email) {
                alert('Please enter your name and email.');
                return;
            }

            // Email validation
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                alert('Please enter a valid email address.');
                return;
            }

            const submitBtn = document.querySelector('.omage-inquiry-submit');
            submitBtn.textContent = 'Sending...';
            submitBtn.disabled = true;

            try {
                // Send via FormSubmit
                const response = await fetch('https://formsubmit.co/ajax/eric@efdotstudio.com', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        name: name,
                        email: email,
                        message: message || 'I am interested in purchasing an O.M.A.G.E. monoprint.',
                        _subject: 'O.M.A.G.E. Monoprint Inquiry from ' + name,
                        _replyto: email,
                        _template: 'table',
                        _captcha: 'false'
                    })
                });

                const result = await response.json();
                if (response.ok && result.success) {
                    // Show success state
                    document.querySelector('.omage-inquiry-form').style.display = 'none';
                    document.getElementById('omageInquirySuccess').style.display = 'block';

                    // Close after delay
                    setTimeout(() => {
                        closeOmageInquiry();
                        // Reset form
                        document.querySelector('.omage-inquiry-form').style.display = 'block';
                        document.getElementById('omageInquirySuccess').style.display = 'none';
                        document.getElementById('omageInquiryName').value = '';
                        document.getElementById('omageInquiryEmail').value = '';
                        document.getElementById('omageInquiryMessage').value = '';
                        submitBtn.textContent = 'Send Inquiry';
                        submitBtn.disabled = false;
                    }, 2500);
                } else {
                    throw new Error('Form submission failed');
                }
            } catch (e) {
                console.error('Form submission error:', e);
                // Fallback to mailto
                const subject = encodeURIComponent('O.M.A.G.E. Monoprint Inquiry');
                const body = encodeURIComponent(`Name: ${name}\nEmail: ${email}\n\nMessage:\n${message || 'I am interested in purchasing an O.M.A.G.E. monoprint.'}`);
                window.location.href = `mailto:eric@efdotstudio.com?subject=${subject}&body=${body}`;

                submitBtn.textContent = 'Send Inquiry';
                submitBtn.disabled = false;
            }
        };

        window.submitSayHey = async function(btn) {
            var container = btn.closest('.say-hey-form').parentElement;
            var form = container.querySelector('.say-hey-form');
            var inputs = form.querySelectorAll('.say-hey-input');
            var name = inputs[0].value.trim();
            var email = inputs[1].value.trim();
            var message = inputs[2].value.trim();

            if (!name || !email) {
                alert('Please enter your name and email.');
                return;
            }
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                alert('Please enter a valid email address.');
                return;
            }

            btn.textContent = 'Sending...';
            btn.disabled = true;

            try {
                var response = await fetch('https://formsubmit.co/ajax/eric@efdotstudio.com', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        name: name,
                        email: email,
                        message: message || 'Hey - Cities idea',
                        _subject: 'Hey - Cities idea from ' + name,
                        _replyto: email,
                        _template: 'table',
                        _captcha: 'false'
                    })
                });

                var result = await response.json();
                if (response.ok && result.success) {
                    form.style.display = 'none';
                    container.querySelector('.say-hey-success').style.display = 'block';
                } else {
                    throw new Error(result.message || 'Form submission failed');
                }
            } catch (e) {
                console.error('Say Hey form error:', e);
                var subject = encodeURIComponent('Hey - Cities idea');
                var body = encodeURIComponent('Name: ' + name + '\nEmail: ' + email + '\n\nMessage:\n' + message);
                window.location.href = 'mailto:eric@efdotstudio.com?subject=' + subject + '&body=' + body;
                btn.textContent = 'Send â†’';
                btn.disabled = false;
            }
        };

        // Render origins grid grouped by collection
        function renderOriginsGrid() {
            const groups = {};
            // Filter out items that should be hidden from grid view
            ORIGINS_DATA.filter(o => !o.hideFromGrid).forEach(origin => {
                const collection = origin.collection;
                if (!groups[collection]) groups[collection] = [];
                groups[collection].push(origin);
            });

            // Order: Open Minds, O.M.A.G.E., Cities // Efdot Originals, Cities // Marfa, Cities // Italy, Editions
            const collectionOrder = ['Open Minds', 'O.M.A.G.E.', 'Cities // Efdot Originals', 'Cities // Marfa', 'Cities // Italy', 'Editions'];
            const sortedCollections = collectionOrder.filter(c => groups[c]);

            // Build intro header with Past Chapters title and Timeline button
            const introHtml = `
                <div class="origins-intro" style="text-align: center; padding: 20px 16px 28px; margin-bottom: 8px;">
                    <div style="font-size: 12px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.2em; color: var(--warm); margin-bottom: 8px;">Past Chapters</div>
                    <div style="font-size: 10px; color: var(--text-muted); letter-spacing: 0.05em;">Cities from <em>hand</em> to <em>code</em> Â· 2019â€“2025</div>
                    <button class="origins-timeline-btn" onclick="if(window.openTimeline) window.openTimeline();" style="margin-top: 16px; background: transparent; border: 1px solid var(--border); color: var(--text-muted); padding: 8px 16px; border-radius: 20px; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 6px;">
                        <span style="filter: grayscale(100%); transition: filter 0.2s;">âœï¸</span> View Timeline
                    </button>
                </div>
            `;

            const groupsHtml = sortedCollections.map(collection => {
                const items = groups[collection].sort((a, b) => a.year - b.year || a.title.localeCompare(b.title));

                // Special CTA for O.M.A.G.E. monoprints - hidden by default, shown when OMAGE thumbnail clicked
                const omageCta = collection === 'O.M.A.G.E.' ? `
                    <div class="omage-print-cta" id="omagePrintCta" style="display: none; margin-top: 16px; padding: 16px; background: linear-gradient(135deg, rgba(232, 184, 109, 0.1), rgba(212, 165, 116, 0.1)); border-radius: 12px; border: 1px dashed rgba(232, 184, 109, 0.3);">
                        <div style="font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--warm); margin-bottom: 8px;">ðŸ–¼ O.M.A.G.E. Monoprints</div>
                        <div style="font-size: 11px; color: var(--text-dim); line-height: 1.5; margin-bottom: 12px;">18Ã—18" screen prints â€” Efdot's first analog generative system. Each one is unique, layered by hand from the Open Minds series.</div>
                        <button class="omage-inquiry-btn" onclick="openOmageInquiry()" style="background: transparent; border: 1px solid var(--warm); color: var(--warm); padding: 8px 16px; border-radius: 20px; font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease;">
                            Inquire About Prints
                        </button>
                    </div>
                ` : '';

                return `
                    <div class="origins-group" data-collection="${collection}">
                        <div class="origins-group-header">
                            <span class="origins-group-name">${collection}</span>
                            <span class="origins-group-count">${items.length} pieces</span>
                            <span class="origins-group-toggle">â–¼</span>
                        </div>
                        <div class="origins-group-items">
                            ${items.map(o => generateOriginItem(o)).join('')}
                        </div>
                        ${omageCta}
                    </div>
                `;
            }).join('');

            // "View More Efdot Originals" section - link to SuperRare
            const moreOriginalsHtml = `
                <a href="https://superrare.com/efdot" target="_blank" class="origins-group origins-more-link" data-collection="more" style="text-decoration: none; display: block;">
                    <div class="origins-group-header" style="background: linear-gradient(135deg, rgba(232, 184, 109, 0.15), rgba(255, 140, 66, 0.15)); cursor: pointer;">
                        <span class="origins-group-name" style="color: var(--warm);">View More Efdot Originals</span>
                        <span class="origins-group-count" style="color: var(--text-muted);">â†’ SuperRare</span>
                    </div>
                </a>
            `;

            gridContent.innerHTML = introHtml + groupsHtml + moreOriginalsHtml;
            document.getElementById('gridPagination').style.display = 'none';

            // Hide filter bar for origins view
            const filterBar = document.getElementById('gridFilterBar');
            const filterToggle = document.getElementById('filterToggleBar');
            if (filterBar) filterBar.classList.remove('open');
            if (filterToggle) filterToggle.classList.remove('open');

            // Add click handlers for group headers (skip the SuperRare link)
            gridContent.querySelectorAll('.origins-group-header').forEach(header => {
                const group = header.parentElement;
                // Skip if it's the SuperRare link
                if (group.classList.contains('origins-more-link')) return;

                header.addEventListener('click', () => {
                    group.classList.toggle('collapsed');
                });
            });

            // Add hover effect for timeline button
            const timelineBtn = gridContent.querySelector('.origins-timeline-btn');
            if (timelineBtn) {
                timelineBtn.addEventListener('mouseenter', () => {
                    timelineBtn.style.borderColor = 'var(--warm)';
                    timelineBtn.style.color = 'var(--warm)';
                    timelineBtn.querySelector('span').style.filter = 'grayscale(0%)';
                });
                timelineBtn.addEventListener('mouseleave', () => {
                    timelineBtn.style.borderColor = 'var(--border)';
                    timelineBtn.style.color = 'var(--text-muted)';
                    timelineBtn.querySelector('span').style.filter = 'grayscale(100%)';
                });
            }
        }

        // Load more Efdot originals from SuperRare contract
        let moreOriginalsLoaded = false;
        async function loadMoreEfdotOriginals() {
            if (moreOriginalsLoaded) return;
            moreOriginalsLoaded = true;

            const container = document.getElementById('moreOriginalsContent');
            if (!container) return;

            // Display link with warning about leaving
            container.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; padding: 20px;">
                    <div style="font-size: 12px; color: var(--text-dim); text-align: center; max-width: 400px; line-height: 1.6;">
                        Explore the full collection of Efdot originals, including works beyond the Cities series.
                    </div>
                    <button onclick="confirmLeaveToCityExternal('https://superrare.com/efdot')" style="background: transparent; border: 1px solid var(--warm); color: var(--warm); padding: 10px 20px; border-radius: 20px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; cursor: pointer; transition: all 0.2s ease;">
                        View Full Collection â†’
                    </button>
                </div>
            `;
        }

        // Warning when leaving the City to external sites
        window.confirmLeaveToCityExternal = function(url) {
            const proceed = confirm('You are leaving Cities Explorer to visit an external site. Continue?');
            if (proceed) {
                window.open(url, '_blank');
            }
        };

        // Image loading with retry
        function loadImageWithRetry(img, url, retries = 2) {
            img.onerror = () => {
                if (retries > 0) {
                    setTimeout(() => {
                        img.src = url + '&retry=' + (3 - retries);
                        loadImageWithRetry(img, url, retries - 1);
                    }, 1000);
                } else {
                    img.style.opacity = '0.3';
                    img.alt = 'Failed to load';
                }
            };
        }
        function shortenAddress(address) { return address ? address.slice(0, 6) + '...' + address.slice(-4) : ''; }
        function formatCollectorName(name) {
            if (!name) return '';
            // Check if it's a full wallet address (starts with 0x and is 42 chars)
            if (name.startsWith('0x') && name.length === 42) {
                return name.slice(0, 5) + '...' + name.slice(-5); // 5+...+5 = 10 digits
            }
            return name;
        }

        async function fetchTokenTraits(tokenId) {
            if (tokenTraits[tokenId]) return tokenTraits[tokenId];
            try {
                const response = await fetch(`https://token.artblocks.io/${CONTRACT}/${tokenId}`);
                const data = await response.json();
                const traits = {};
                if (data.features) { for (const [key, value] of Object.entries(data.features)) { traits[key] = value; } }
                tokenTraits[tokenId] = traits;
                return traits;
            } catch (e) { return null; }
        }

        async function fetchTokenOwner(tokenId) {
            if (tokenOwners[tokenId]) return tokenOwners[tokenId];
            try {
                // Use Art Blocks Hasura GraphQL API for owner data and user display name
                const query = `{
                    tokens_metadata(where: {contract_address: {_eq: "${CONTRACT}"}, token_id: {_eq: "${tokenId}"}}) {
                        token_id
                        owner_address
                    }
                }`;
                const response = await fetch('https://data.artblocks.io/v1/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await response.json();

                if (data.data?.tokens_metadata?.[0]?.owner_address) {
                    const ownerAddress = data.data.tokens_metadata[0].owner_address;
                    const owner = {
                        address: ownerAddress,
                        ens: null,
                        artblocksName: null
                    };

                    // Try to get Art Blocks display name for the owner
                    try {
                        // Lowercase the address for API query (Art Blocks stores addresses in lowercase)
                        const normalizedAddress = ownerAddress.toLowerCase();
                        const userQuery = `{ users(where: {public_address: {_eq: "${normalizedAddress}"}}) { display_name } }`;
                        const userResponse = await fetch('https://data.artblocks.io/v1/graphql', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ query: userQuery })
                        });
                        const userData = await userResponse.json();
                        if (userData.data?.users?.[0]?.display_name) {
                            owner.artblocksName = userData.data.users[0].display_name;
                        }
                    } catch (e) { /* User fetch failed */ }

                    // Try ENS lookup if no Art Blocks name
                    if (!owner.artblocksName) {
                        try {
                            const ensResponse = await fetch(`https://api.ensideas.com/ens/resolve/${ownerAddress}`);
                            if (ensResponse.ok) {
                                const ensData = await ensResponse.json();
                                if (ensData.name) owner.ens = ensData.name;
                            }
                        } catch (e) { /* ENS fetch failed */ }
                    }

                    tokenOwners[tokenId] = owner;
                    return owner;
                }
                return { address: null, ens: null, artblocksName: null };
            } catch (e) {
                console.log('Owner fetch error:', e);
                return { address: null, ens: null, artblocksName: null };
            }
        }

        async function fetchTokenData(tokenId) {
            const [traits, owner] = await Promise.all([fetchTokenTraits(tokenId), fetchTokenOwner(tokenId)]);
            return { traits, owner };
        }

        async function loadAllTokenData() {
            // First, fetch the current minted count to know how many tokens exist
            let mintedCountFetched = false;
            try {
                const response = await fetch(`https://token.artblocks.io/${CONTRACT}/0`);
                const data = await response.json();
                if (data.invocations) {
                    const minted = parseInt(data.invocations);
                    MAX_TOKEN = minted - 1; // Token IDs are 0-indexed
                    mintedCountFetched = true;
                    console.log(`Current minted count: ${minted}, MAX_TOKEN set to ${MAX_TOKEN}`);
                }
            } catch (e) {
                console.log('Token API unavailable for minted count, trying GraphQL...');
            }

            // Fallback: get minted count from GraphQL aggregate
            if (!mintedCountFetched) {
                try {
                    const countQuery = `{ tokens_metadata_aggregate(where: {contract_address: {_eq: "${CONTRACT}"}}) { aggregate { count } } }`;
                    const countResp = await fetch('https://data.artblocks.io/v1/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: countQuery })
                    });
                    const countData = await countResp.json();
                    const count = countData.data?.tokens_metadata_aggregate?.aggregate?.count;
                    if (count > 0) {
                        MAX_TOKEN = count - 1;
                        console.log(`GraphQL minted count: ${count}, MAX_TOKEN set to ${MAX_TOKEN}`);
                    }
                } catch (e2) {
                    console.log('Could not fetch minted count from any source, using default MAX_TOKEN');
                }
            }

            const hasCached = loadCachedTraits();
            const cachedCount = Object.keys(tokenTraits).length;

            // Use cache if we have enough data (at least 90% of minted tokens)
            if (hasCached && cachedCount > 0 && cachedCount >= MAX_TOKEN * 0.9) {
                matchCount.textContent = 'LOADING FROM CACHE...';
                tokenDataReady = true;
                extractTraitValues(); populateFilters(); updateMatchCount();
                // Always open grid on load
                openGridOnLoad();
                // Fetch any missing tokens in background
                if (cachedCount < MAX_TOKEN + 1) {
                    setTimeout(async () => {
                        for (let i = 0; i <= MAX_TOKEN; i++) {
                            if (!tokenTraits[i]) await fetchTokenTraits(i);
                        }
                        saveCachedTraits();
                        extractTraitValues(); populateFilters(); updateMatchCount();
                    }, 2000);
                }
                return;
            }
            matchCount.textContent = 'LOADING TRAITS...';
            showLoadingBar();

            // Strategy 1: Try GraphQL batch fetch (single request for all tokens)
            let graphqlSuccess = false;
            try {
                const query = `{
                    tokens_metadata(where: {contract_address: {_eq: "${CONTRACT}"}}) {
                        token_id
                        features
                    }
                }`;
                const response = await fetch('https://data.artblocks.io/v1/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await response.json();
                if (data.data?.tokens_metadata?.length > 0) {
                    const tokens = data.data.tokens_metadata;
                    let maxId = 0;
                    tokens.forEach((token, i) => {
                        const tokenId = parseInt(token.token_id);
                        if (tokenId > maxId) maxId = tokenId;
                        const traits = {};
                        const features = typeof token.features === 'string' ? JSON.parse(token.features) : token.features;
                        if (features) {
                            for (const [key, value] of Object.entries(features)) { traits[key] = value; }
                        }
                        if (Object.keys(traits).length > 0) tokenTraits[tokenId] = traits;
                        if (i % 50 === 0) updateLoadingBar(Math.round((i / tokens.length) * 100));
                    });
                    if (maxId > 0) MAX_TOKEN = maxId;
                    graphqlSuccess = Object.keys(tokenTraits).length > 0;
                    console.log(`GraphQL batch: loaded ${Object.keys(tokenTraits).length} tokens with traits`);
                }
            } catch (e) {
                console.log('GraphQL batch fetch failed:', e);
            }

            // Strategy 2: Fall back to individual REST calls
            if (!graphqlSuccess) {
                console.log('Falling back to individual token API calls...');
                const batchSize = 20;
                let loaded = 0;
                const total = MAX_TOKEN + 1;
                for (let i = 0; i <= MAX_TOKEN; i += batchSize) {
                    const batch = [];
                    for (let j = i; j < Math.min(i + batchSize, MAX_TOKEN + 1); j++) { batch.push(fetchTokenTraits(j)); }
                    await Promise.all(batch);
                    loaded += batch.length;
                    updateLoadingBar(Math.round((loaded / total) * 100));
                    matchCount.textContent = `TRAITS ${Math.min(loaded, total)}/${total}`;
                }
            }

            hideLoadingBar();
            saveCachedTraits();
            tokenDataReady = true;
            extractTraitValues(); populateFilters(); updateMatchCount();
            // Always open grid on load
            openGridOnLoad();
        }

        function extractTraitValues() {
            for (const [tokenId, traits] of Object.entries(tokenTraits)) {
                if (!traits) continue;
                if (traits['Time of Day']) traitValues.timeOfDay.add(traits['Time of Day']);
                if (traits['Energy']) traitValues.energy.add(traits['Energy']);
                if (traits['Palette']) traitValues.palette.add(traits['Palette']);
                if (traits['Bounds']) traitValues.bounds.add(traits['Bounds']);
                if (traits['Traffic']) traitValues.traffic.add(traits['Traffic']);
                if (traits['Line']) traitValues.line.add(traits['Line']);
                if (traits['Render']) traitValues.render.add(traits['Render']);
                if (traits['Zoom']) traitValues.zoom.add(traits['Zoom']);
                if (traits['Water Feature']) traitValues.water.add(traits['Water Feature']);
            }
        }

        function populateFilters() {
            populateFilter(filterTime, traitValues.timeOfDay);
            populateFilter(filterEnergy, traitValues.energy);
            populateFilter(filterPalette, traitValues.palette);
            populateFilter(filterBounds, traitValues.bounds, { 'Aboveground Current': 'AB Current' });
            populateFilter(filterTraffic, traitValues.traffic);
            populateFilter(filterLine, traitValues.line, { 'Lighter': 'Chisel' });
            populateFilter(filterRender, traitValues.render);
            populateFilter(filterZoom, traitValues.zoom);
            populateFilter(filterWater, traitValues.water);
            // Restore saved filters after populating options
            if (typeof loadFiltersFromStorage === 'function') loadFiltersFromStorage();
        }

        function populateFilter(select, values, displayMap = {}) {
            Array.from(values).sort().forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = displayMap[value] || value;
                select.appendChild(option);
            });
        }

        // Update dependent filters based on Time/Energy selection
        // Shows only palettes that exist within the current Time/Energy filter
        function updateDependentFilters() {
            const timeFilter = filterTime.value;
            const energyFilter = filterEnergy.value;

            // If no Time or Energy filter, show all palettes
            if (!timeFilter && !energyFilter) {
                // Reset palette dropdown to show all
                const currentPalette = filterPalette.value;
                filterPalette.innerHTML = '<option value="">ANY</option>';
                Array.from(traitValues.palette).sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    filterPalette.appendChild(option);
                });
                // Restore selection if still valid
                if (currentPalette && Array.from(traitValues.palette).includes(currentPalette)) {
                    filterPalette.value = currentPalette;
                }
                return;
            }

            // Find palettes that match current Time/Energy filters
            const matchingPalettes = new Set();
            for (const [tokenId, traits] of Object.entries(tokenTraits)) {
                if (!traits) continue;
                let matches = true;
                if (timeFilter && traits['Time of Day'] !== timeFilter) matches = false;
                if (energyFilter && traits['Energy'] !== energyFilter) matches = false;
                if (matches && traits['Palette']) {
                    matchingPalettes.add(traits['Palette']);
                }
            }

            // Update palette dropdown with only matching palettes
            const currentPalette = filterPalette.value;
            filterPalette.innerHTML = '<option value="">ANY</option>';
            Array.from(matchingPalettes).sort().forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                filterPalette.appendChild(option);
            });

            // Add count indicator to the label
            const paletteLabel = filterPalette.closest('.control-group')?.querySelector('label');
            if (paletteLabel) {
                paletteLabel.textContent = matchingPalettes.size < traitValues.palette.size
                    ? `PALETTE (${matchingPalettes.size})`
                    : 'PALETTE';
            }

            // Clear palette selection if it's no longer valid
            if (currentPalette && !matchingPalettes.has(currentPalette)) {
                filterPalette.value = '';
            } else if (currentPalette) {
                filterPalette.value = currentPalette;
            }
        }

        function getFilteredTokens() {
            const filters = { timeOfDay: filterTime.value, energy: filterEnergy.value, palette: filterPalette.value, bounds: filterBounds.value, traffic: filterTraffic.value, line: filterLine.value, render: filterRender.value, zoom: filterZoom.value, water: filterWater.value };
            const hasFilters = Object.values(filters).some(v => v);
            // Only return minted tokens (those with traits)
            const mintedTokens = Object.keys(tokenTraits).map(Number).sort((a, b) => a - b);
            // If no traits loaded yet, return empty array to prevent navigation to non-existent tokens
            if (!hasFilters) return mintedTokens;
            // Filter only through minted tokens, not all possible tokens
            const matches = [];
            for (const tokenId of mintedTokens) {
                const traits = tokenTraits[tokenId];
                if (!traits) continue;
                let match = true;
                if (filters.timeOfDay && traits['Time of Day'] !== filters.timeOfDay) match = false;
                if (filters.energy && traits['Energy'] !== filters.energy) match = false;
                if (filters.palette && traits['Palette'] !== filters.palette) match = false;
                if (filters.bounds && traits['Bounds'] !== filters.bounds) match = false;
                if (filters.traffic && traits['Traffic'] !== filters.traffic) match = false;
                if (filters.line && traits['Line'] !== filters.line) match = false;
                if (filters.render && traits['Render'] !== filters.render) match = false;
                if (filters.zoom && traits['Zoom'] !== filters.zoom) match = false;
                if (filters.water && traits['Water Feature'] !== filters.water) match = false;
                if (match) matches.push(tokenId);
            }
            return matches;
        }

        function updateMatchCount() {
            const matches = getFilteredTokens();
            const hasFilters = [filterTime, filterEnergy, filterPalette, filterBounds, filterTraffic, filterLine, filterRender, filterZoom, filterWater].some(f => f.value);
            matchCount.innerHTML = hasFilters ? `<strong>${matches.length}</strong> MATCHES` : '';
        }

        function renderCollectorsPills() {
            const pillsContainer = document.getElementById('collectorsPills');

            // Exclude "The Lost Cities" distribution wallet (by name or address prefix 0xcf22)
            const LOST_CITIES_PREFIX = '0xcf22';
            // Get top 3 collector names to exclude from pills (shown in top collectors highlight)
            const top3Names = new Set(
                COLLECTORS_DATA
                    .filter(c => c.count >= 2 &&
                        c.name !== 'The Lost Cities' &&
                        !(c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX)) &&
                        !(c.name.startsWith('0x') && c.name.length >= 40))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3)
                    .map(c => c.name)
            );
            const filteredCollectors = COLLECTORS_DATA.filter(c =>
                c.name !== 'The Lost Cities' &&
                !(c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX)) &&
                !top3Names.has(c.name)
            );

            // Helper to get full palette info from collector's tokens
            function getCollectorPaletteInfo(collector) {
                if (collector.tokens && collector.tokens.length > 0) {
                    const randomToken = collector.tokens[Math.floor(Math.random() * collector.tokens.length)];
                    const traits = tokenTraits[randomToken];
                    if (traits) {
                        const paletteName = traits['Palette'];
                        const paletteInfo = PALETTE_DATA[paletteName];
                        if (paletteInfo) {
                            return { bg: paletteInfo.bg, colors: paletteInfo.colors || [] };
                        }
                    }
                }
                return { bg: '#333333', colors: ['#666', '#888', '#aaa'] };
            }

            // Get a pop color from palette that contrasts with background
            function getPopTextColor(paletteInfo) {
                const bg = paletteInfo.bg;
                const colors = paletteInfo.colors || [];
                const hex = bg.replace('#', '');
                const bgR = parseInt(hex.substr(0, 2), 16);
                const bgG = parseInt(hex.substr(2, 2), 16);
                const bgB = parseInt(hex.substr(4, 2), 16);
                const bgLum = (0.299 * bgR + 0.587 * bgG + 0.114 * bgB) / 255;

                // Find the color with best contrast from the palette
                let bestColor = bgLum > 0.5 ? '#000000' : '#ffffff';
                let bestContrast = 0;

                for (const color of colors) {
                    if (!color || typeof color !== 'string') continue;
                    const cHex = color.replace('#', '');
                    if (cHex.length < 6) continue;
                    const cR = parseInt(cHex.substr(0, 2), 16);
                    const cG = parseInt(cHex.substr(2, 2), 16);
                    const cB = parseInt(cHex.substr(4, 2), 16);
                    const cLum = (0.299 * cR + 0.587 * cG + 0.114 * cB) / 255;
                    const contrast = Math.abs(bgLum - cLum);
                    const saturation = Math.max(cR, cG, cB) - Math.min(cR, cG, cB);
                    if (contrast > 0.25 && (contrast > bestContrast || (saturation > 60 && contrast > bestContrast * 0.8))) {
                        bestContrast = contrast;
                        bestColor = color;
                    }
                }
                return bestColor;
            }

            // Generate SVG texture using actual palette colors
            function generatePillTexture(colors) {
                const c = (colors || []).filter(Boolean);
                if (c.length < 2) return '';
                // Pick 6 spread-out colors from the palette for variety
                const pick = [];
                const step = Math.max(1, Math.floor(c.length / 6));
                for (let j = 0; j < 6 && j * step < c.length; j++) pick.push(c[j * step]);
                while (pick.length < 6) pick.push(c[pick.length % c.length]);
                const h = (col) => (col || '').replace('#', '');
                const svg = `%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' stroke-linecap='round'%3E%3Cline x1='0' y1='10' x2='28' y2='30' stroke='%23${h(pick[0])}' stroke-width='3.5' opacity='0.6'/%3E%3Cline x1='20' y1='4' x2='50' y2='24' stroke='%23${h(pick[1])}' stroke-width='2.5' stroke-dasharray='6 4' opacity='0.55'/%3E%3Cline x1='45' y1='0' x2='78' y2='22' stroke='%23${h(pick[2])}' stroke-width='2' opacity='0.5'/%3E%3Cline x1='5' y1='38' x2='38' y2='58' stroke='%23${h(pick[3])}' stroke-width='2.5' stroke-dasharray='2 3' opacity='0.55'/%3E%3Cline x1='30' y1='32' x2='62' y2='52' stroke='%23${h(pick[4])}' stroke-width='4' opacity='0.5'/%3E%3Cline x1='55' y1='40' x2='80' y2='56' stroke='%23${h(pick[5])}' stroke-width='2' stroke-dasharray='8 3' opacity='0.5'/%3E%3Cline x1='0' y1='62' x2='25' y2='78' stroke='%23${h(pick[1])}' stroke-width='2.5' opacity='0.45'/%3E%3Cline x1='80' y1='15' x2='55' y2='35' stroke='%23${h(pick[0])}' stroke-width='2' stroke-dasharray='5 3' opacity='0.48'/%3E%3Cline x1='70' y1='55' x2='42' y2='75' stroke='%23${h(pick[2])}' stroke-width='2.5' opacity='0.42'/%3E%3Cline x1='60' y1='0' x2='35' y2='18' stroke='%23${h(pick[4])}' stroke-width='1.5' stroke-dasharray='3 2' opacity='0.45'/%3E%3Ccircle cx='15' cy='48' r='3' fill='%23${h(pick[3])}' opacity='0.6'/%3E%3Ccircle cx='50' cy='18' r='2.5' fill='%23${h(pick[5])}' opacity='0.55'/%3E%3Ccircle cx='70' cy='50' r='3' fill='%23${h(pick[0])}' opacity='0.5'/%3E%3Ccircle cx='38' cy='70' r='2' fill='%23${h(pick[1])}' opacity='0.48'/%3E%3Ccircle cx='8' cy='25' r='2' fill='%23${h(pick[4])}' opacity='0.45'/%3E%3Ccircle cx='62' cy='68' r='2.5' fill='%23${h(pick[2])}' opacity='0.42'/%3E%3C/g%3E%3C/svg%3E`;
                return `url('data:image/svg+xml,${svg.replace(/'/g, '%27')}')`;
            }

            // Simple black/white text based on bg luminance
            function getBWTextColor(bgColor) {
                const hex = (bgColor || '#333').replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                return (0.299 * r + 0.587 * g + 0.114 * b) > 140 ? '#000' : '#fff';
            }

            const htmlParts = [];
            const len = filteredCollectors.length;
            for (let i = 0; i < len; i++) {
                const collector = filteredCollectors[i];
                const emoji = CITY_EMOJIS[i % CITY_EMOJIS.length];
                const multiClass = collector.count >= 2 ? ' multi-holder' : '';
                const isPatron = isFoundingPatron(collector.name);
                const patronClass = isPatron ? ' founding-patron' : '';
                const gridBadge = collector.count >= 4 ? '<span class="pill-grid-badge">âŠž</span>' : '';

                // Get palette info from one of their Cities
                const paletteInfo = getCollectorPaletteInfo(collector);
                const bgColor = paletteInfo.bg;
                // Patrons get colorful text from palette; everyone else gets black/white
                const textColor = isPatron ? getPopTextColor(paletteInfo) : getBWTextColor(bgColor);
                // Generate dynamic texture from actual palette colors for patrons
                const textureStyle = isPatron ? ` --pill-texture: ${generatePillTexture(paletteInfo.colors)};` : '';

                htmlParts.push(`<span class="collector-pill${multiClass}${patronClass}" data-collector="${collector.name}" style="background: ${bgColor}; color: ${textColor}; --pill-index: ${i};${textureStyle}">${collector.name}<span class="pill-count">Ã—${collector.count}</span>${gridBadge}<span class="pill-emoji">${emoji} Ã— ${collector.count}</span></span>`);
            }
            pillsContainer.innerHTML = htmlParts.join('');

            // Event delegation - single handler for all pills (faster)
            pillsContainer.onclick = (e) => {
                const pill = e.target.closest('.collector-pill');
                if (pill) {
                    const collectorName = pill.dataset.collector;
                    fetchCollectorTokens(collectorName);
                }
            };
        }

        let currentCollectorFilter = null;
        let enteredCollectorFromTimeline = false;

        async function fetchCollectorTokens(collectorName, fromTimeline = false) {
            enteredCollectorFromTimeline = fromTimeline;
            // Show loading state
            const banner = document.getElementById('collectorBanner');
            const bannerNameEl = document.getElementById('collectorBannerName');
            if (bannerNameEl) bannerNameEl.textContent = collectorName + '...';
            banner?.classList.add('visible');

            // Close collectors panel and open grid
            collectorsPanel?.classList.remove('open');
            document.body.classList.remove('collectors-open');
            const gp = document.getElementById('gridPanel');
            const vtb = document.getElementById('viewToggleBtn');
            if (gp) gp.classList.add('open');
            if (vtb) vtb.classList.add('grid-open');
            document.body.classList.add('grid-open');

            // First check if we already have this data from the collectors fetch
            const cachedCollector = COLLECTORS_DATA.find(c => c.name === collectorName);
            if (cachedCollector && cachedCollector.tokens && cachedCollector.tokens.length > 0) {
                showCollectorInGrid(collectorName, cachedCollector.tokens);
                return;
            }

            // Otherwise fetch from API
            try {
                // Query Art Blocks API for tokens owned by this collector
                const query = `{
                    users(where: {display_name: {_eq: "${collectorName}"}}) {
                        public_address
                    }
                }`;
                const response = await fetch('https://data.artblocks.io/v1/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await response.json();

                if (data.data?.users?.[0]?.public_address) {
                    const address = data.data.users[0].public_address;
                    // Now get tokens owned by this address for this contract
                    const tokensQuery = `{
                        tokens_metadata(where: {contract_address: {_eq: "${CONTRACT}"}, owner_address: {_eq: "${address}"}}) {
                            token_id
                        }
                    }`;
                    const tokensResponse = await fetch('https://data.artblocks.io/v1/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: tokensQuery })
                    });
                    const tokensData = await tokensResponse.json();

                    if (tokensData.data?.tokens_metadata) {
                        const tokens = tokensData.data.tokens_metadata.map(t => parseInt(t.token_id));
                        showCollectorInGrid(collectorName, tokens);
                        return;
                    }
                }
            } catch (e) {
                console.log('Error fetching collector tokens:', e);
            }

            // Fallback - just show empty state
            showCollectorInGrid(collectorName, []);
        }
        // Expose globally for inline onclick handlers
        window.fetchCollectorTokens = fetchCollectorTokens;

        function showCollectorInGrid(collectorName, tokens, skipWallView = false) {
            currentCollectorFilter = { name: collectorName, tokens: tokens };
            // Persist collector context for wall button fallback
            try { sessionStorage.setItem('cities-gallery-context', JSON.stringify(currentCollectorFilter)); } catch(e) {}

            // Check for originals owned by this collector
            const collectorOriginals = getCollectorOriginals(collectorName);
            const totalPieces = tokens.length + collectorOriginals.length;

            // Update banner with final name and count (includes both cities and originals)
            document.getElementById('collectorBannerName').textContent = collectorName;
            document.getElementById('collectorBannerCount').textContent = totalPieces;

            // Generate a phrase based on their collection
            const phrase = collectorOriginals.length > 0
                ? generateCollectorPhraseWithOriginals(tokens, collectorOriginals)
                : generateCollectorPhrase(tokens);
            document.getElementById('collectorBannerPhrase').textContent = phrase;

            // Store tokens on wall button for direct access
            const wallBtn = document.getElementById('collectorWallView');
            if (wallBtn) {
                wallBtn.dataset.collector = collectorName;
                wallBtn.dataset.tokens = tokens.join(',');
            }

            // Show the collector banner
            document.getElementById('collectorBanner').classList.add('visible');

            // Reset to simple grid mode for collector view
            gridMode = 'grid';
            document.querySelectorAll('.grid-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.grid-mode-btn[data-mode="grid"]')?.classList.add('active');

            renderGrid();

            // Auto-open wall view as default view for collectors
            if (!skipWallView && tokens.length > 0) {
                openWallView(collectorName, tokens);
            }
        }

        function generateCollectorPhraseWithOriginals(tokens, originals) {
            // Special phrases for collectors who own originals
            const originalsCount = originals.length;
            const citiesCount = tokens.length;
            const total = originalsCount + citiesCount;

            const phrases = [];

            if (originalsCount >= 2 && citiesCount >= 1) {
                phrases.push(
                    'From the beginning to the grid.',
                    'Hand-drawn roots, generative branches.',
                    'The full journey, collected.'
                );
            } else if (originalsCount === 1 && citiesCount >= 1) {
                phrases.push(
                    'One original, many cities.',
                    'Where it started and where it goes.',
                    'The seed and the skyline.'
                );
            } else if (originalsCount >= 1 && citiesCount === 0) {
                phrases.push(
                    'A piece of the origin story.',
                    'Before the algorithm.',
                    'Hand to code, the beginning.'
                );
            }

            // Add some standard phrases too
            if (total >= 5) {
                phrases.push('Building something special here.');
            }

            return phrases[Math.floor(Math.random() * phrases.length)] || 'A collector of the journey.';
        }

        function generateCollectorPhrase(tokens) {
            if (!tokens || tokens.length === 0) return '';

            const count = tokens.length;

            // Get traits for analysis
            const palettes = [];
            const times = [];
            const zooms = [];
            tokens.forEach(id => {
                const traits = tokenTraits[id];
                if (traits) {
                    if (traits['Palette']) palettes.push(traits['Palette']);
                    if (traits['Time of Day']) times.push(traits['Time of Day']);
                    if (traits['Zoom']) zooms.push(traits['Zoom']);
                }
            });

            // Find dominant traits
            const dominantPalette = getMostCommon(palettes);
            const dominantTime = getMostCommon(times);
            const dominantZoom = getMostCommon(zooms);

            // Phrases based on collection characteristics
            const phrases = [];

            // Count-based phrases
            if (count === 1) {
                phrases.push(
                    'One city, infinite stories.',
                    'A single window into the grid.',
                    'Every collection starts somewhere.'
                );
            } else if (count === 2) {
                phrases.push(
                    'Two perspectives, one vision.',
                    'A pair that speaks volumes.',
                    'A conversation between cities.'
                );
            } else if (count === 3) {
                phrases.push(
                    'Three corners of the city.',
                    'A triangle of light and line.',
                    'Where three roads meet.'
                );
            } else if (count >= 4 && count < 10) {
                phrases.push(
                    'See you around the block.',
                    'Building something here.',
                    'A proper neighborhood forming.'
                );
            } else if (count >= 10 && count < 20) {
                phrases.push(
                    'High up in the sky, watching the grid below.',
                    'The city reveals itself to those who stay.',
                    'A district of your own.'
                );
            } else if (count >= 20) {
                phrases.push(
                    'The whole city knows your name.',
                    'From here you can see everything.',
                    'Mayor of the collection.'
                );
            }

            // Time-based phrases
            if (dominantTime === 'Night') {
                phrases.push(
                    'The city never sleeps, neither do you.',
                    'Night owl, city lights.'
                );
            } else if (dominantTime === 'Dawn' || dominantTime === 'Sunrise') {
                phrases.push(
                    'First light, fresh start.',
                    'Early riser, empty streets.'
                );
            } else if (dominantTime === 'Golden Hour' || dominantTime === 'Sunset') {
                phrases.push(
                    'Chasing the golden hour.',
                    'When the light hits just right.'
                );
            }

            // Zoom-based phrases
            if (dominantZoom === 'Close' || dominantZoom === 'Very Close') {
                phrases.push(
                    'In the details, the truth.',
                    'Close enough to see the texture.'
                );
            } else if (dominantZoom === 'Far' || dominantZoom === 'Very Far') {
                phrases.push(
                    'The long view, the big picture.',
                    'From a distance, patterns emerge.'
                );
            }

            // Palette-based phrases with color references
            if (dominantPalette) {
                const paletteInfo = PALETTE_DATA[dominantPalette];
                if (paletteInfo && paletteInfo.colors) {
                    // Get two prominent colors for "meet me on the corner" phrase
                    const color1 = getColorName(paletteInfo.colors[0]);
                    const color2 = getColorName(paletteInfo.colors[2]);
                    if (color1 && color2) {
                        phrases.push(`Meet me on the corner of ${color1} and ${color2}.`);
                    }
                }
            }

            // Return a random phrase
            return phrases[Math.floor(Math.random() * phrases.length)] || '';
        }

        function getMostCommon(arr) {
            if (!arr || arr.length === 0) return null;
            const counts = {};
            arr.forEach(item => { counts[item] = (counts[item] || 0) + 1; });
            return Object.entries(counts).sort((a, b) => b[1] - a[1])[0]?.[0];
        }

        function getColorName(hex) {
            if (!hex) return null;
            // Convert hex to HSL for better color naming
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            h *= 360;
            s *= 100;
            l *= 100;

            // Simple color naming
            if (l < 15) return 'Midnight';
            if (l > 90) return 'Ivory';
            if (s < 10) return l < 50 ? 'Slate' : 'Pearl';

            // Hue-based names
            if (h < 15 || h >= 345) return 'Crimson';
            if (h < 45) return 'Amber';
            if (h < 70) return 'Gold';
            if (h < 150) return 'Jade';
            if (h < 200) return 'Cyan';
            if (h < 260) return 'Indigo';
            if (h < 290) return 'Violet';
            if (h < 345) return 'Rose';
            return 'Ember';
        }

        function clearCollectorFilter(returnToTimeline = false) {
            const wasFromTimeline = enteredCollectorFromTimeline;
            currentCollectorFilter = null;
            enteredCollectorFromTimeline = false;
            document.getElementById('collectorBanner').classList.remove('visible');

            // If came from timeline and escape is pressed, return to timeline
            if (returnToTimeline && wasFromTimeline) {
                closeGridView();
                openTimeline();
                return;
            }
            renderGrid();
        }

        function renderLeaderboard() {
            // Light, readable colors for leaderboard names
            const LEADERBOARD_COLORS = [
                '#E8B86D', '#D4A574', '#F5D6BA', '#FFB88C', '#FFC9A8',
                '#B8D4E3', '#A8E6CF', '#DCEDC1', '#FFD3B6', '#FFAAA5',
                '#C9B1FF', '#B5EAD7', '#E2F0CB', '#FFDAC1', '#FF9AA2',
                '#C7CEEA', '#E0BBE4', '#FEC8D8', '#D4F0F0', '#FCE1E4'
            ];

            // Helper to calculate achievement badges for a collector
            function getAchievementBadges(tokens, collectorName) {
                let badges = [];

                // Check for OG status (owns original or pre-Art Blocks piece)
                const ogCollectors = ['WILLEP', 'Shillr', 'SimonSays', 'BatSoupYum', 'Valdi', 'OG', 'Oblivion', 'DIID'];
                if (ogCollectors.some(og => og.toLowerCase() === collectorName.toLowerCase())) {
                    badges.push('<span class="achievement-badge og" title="Owns an Efdot Original">OG</span>');
                }

                // Count energies
                const energyCounts = { Rising: 0, Living: 0, Fading: 0, Resting: 0 };
                tokens.forEach(id => {
                    const traits = tokenTraits[id];
                    if (traits && traits.Energy) {
                        energyCounts[traits.Energy] = (energyCounts[traits.Energy] || 0) + 1;
                    }
                });

                const rising = energyCounts.Rising;
                const living = energyCounts.Living;
                const fading = energyCounts.Fading;
                const resting = energyCounts.Resting;
                const totalCities = tokens.length;

                // Grid badge (4+ cities)
                if (totalCities >= 4) {
                    const gridCount = Math.floor(totalCities / 4);
                    const multiplier = gridCount > 1 ? `<span class="grid-multiplier">x${gridCount}</span>` : '';
                    badges.push(`<span class="achievement-badge grid" title="Grid (${totalCities} cities)"><span class="grid-icon-mini"><b></b><b></b><b></b><b></b></span>${multiplier}</span>`);
                }

                // Energy Set badge (one of each energy)
                if (rising >= 1 && living >= 1 && fading >= 1 && resting >= 1) {
                    badges.push('<span class="achievement-badge spectrum" title="Energy Set âš¡ï¸ Â· one of each energy">âš¡ï¸</span>');
                }

                // Mono set badges (4+ of same energy)
                if (rising >= 4) {
                    const count = Math.floor(rising / 4);
                    badges.push(`<span class="achievement-badge rising-set" title="Rising City Set Â· ${rising} rising energy cities">â˜€ï¸${count > 1 ? count : ''}</span>`);
                }
                if (living >= 4) {
                    const count = Math.floor(living / 4);
                    badges.push(`<span class="achievement-badge living-set" title="Living City Set Â· ${living} living energy cities">ðŸ™ï¸${count > 1 ? count : ''}</span>`);
                }
                if (fading >= 4) {
                    const count = Math.floor(fading / 4);
                    badges.push(`<span class="achievement-badge fading-set" title="Fading City Set Â· ${fading} fading energy cities">ðŸŒ†${count > 1 ? count : ''}</span>`);
                }
                if (resting >= 4) {
                    const count = Math.floor(resting / 4);
                    const multiplier = count > 1 ? `<span class="resting-set-multiplier">x${count}</span>` : '';
                    badges.push(`<span class="achievement-badge resting-set" title="Resting City Set Â· ${resting} resting energy cities"><span class="resting-set-grid"><b></b><b></b><b></b><b></b></span>${multiplier}</span>`);
                }

                return badges.length > 0 ? `<span class="achievement-badges">${badges.join('')}</span>` : '';
            }

            const leaderboardList = document.getElementById('leaderboardList');
            // Filter to 2+ cities, exclude distribution wallet (by name or address prefix), sort by count
            const LOST_CITIES_PREFIX = '0xcf22';
            const multiCollectors = COLLECTORS_DATA
                .filter(c => c.count >= 2 &&
                    c.name !== 'The Lost Cities' &&
                    !(c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX)))
                .sort((a, b) => b.count - a.count);
            const maxCount = multiCollectors[0]?.count || 1;
            leaderboardList.innerHTML = multiCollectors.map((collector, i) => {
                const color = LEADERBOARD_COLORS[i % LEADERBOARD_COLORS.length];
                const barWidth = (collector.count / maxCount) * 100;
                const tokens = collector.tokens || [];
                const patronClass = isFoundingPatron(collector.name) ? ' founding-patron' : '';
                // Create 9:16 color swatches for each city using actual background color
                const swatchChipsHtml = tokens.slice(0, 12).map(id => {
                    const traits = tokenTraits[id];
                    const paletteName = traits?.['Palette'];
                    const paletteInfo = PALETTE_DATA[paletteName];
                    const bgColor = paletteInfo?.bg || '#333';
                    return `<div class="leaderboard-chip" title="#${id} - ${paletteName || 'Unknown'}" style="background: ${bgColor};"></div>`;
                }).join('');
                // Get achievement badges
                const achievementBadges = getAchievementBadges(tokens, collector.name);
                return `<li class="leaderboard-item${patronClass}" data-collector="${collector.name}" style="cursor: pointer;">
                    <div class="leaderboard-name-wrap">
                        <span class="leaderboard-rank">${i + 1}</span>
                        <span class="leaderboard-name" style="color: ${color}">${collector.name}</span>
                        ${achievementBadges}
                    </div>
                    <div class="leaderboard-chips-wrap">
                        <div class="leaderboard-chips">${swatchChipsHtml}</div>
                    </div>
                    <span class="leaderboard-count">${collector.count}</span>
                </li>`;
            }).join('');

            // Add click handlers for leaderboard items
            leaderboardList.querySelectorAll('.leaderboard-item').forEach(item => {
                item.addEventListener('click', () => {
                    const collectorName = item.dataset.collector;
                    fetchCollectorTokens(collectorName);
                });
            });
        }

        function renderTopCollectors() {
            const container = document.getElementById('topCollectorsHighlight');
            if (!container || COLLECTORS_DATA.length === 0) return;

            const LOST_CITIES_PREFIX = '0xcf22';
            const top3 = COLLECTORS_DATA
                .filter(c => c.count >= 2 &&
                    c.name !== 'The Lost Cities' &&
                    !(c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX)) &&
                    !(c.name.startsWith('0x') && c.name.length >= 40))
                .sort((a, b) => b.count - a.count)
                .slice(0, 3);

            if (top3.length === 0) { container.classList.remove('visible'); return; }

            const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
            const rows = top3.map((collector, i) => {
                const tokens = collector.tokens || [];
                // Get palette chips for first 5 cities
                const chipsHtml = tokens.slice(0, 5).map(id => {
                    const traits = tokenTraits[id];
                    const paletteName = traits?.['Palette'];
                    const paletteInfo = PALETTE_DATA[paletteName];
                    const bgColor = paletteInfo?.bg || '#333';
                    return `<div class="top-collector-chip" style="background: ${bgColor};"></div>`;
                }).join('');

                // Generate energy-based status for their collection
                const gridCount = Math.floor(tokens.length / 4);
                const energyCounts = { Rising: 0, Living: 0, Fading: 0, Resting: 0 };
                tokens.forEach(id => {
                    const traits = tokenTraits[id];
                    if (traits?.Energy) energyCounts[traits.Energy]++;
                });
                const hasEnergySet = energyCounts.Rising >= 1 && energyCounts.Living >= 1 && energyCounts.Fading >= 1 && energyCounts.Resting >= 1;

                // Determine primary status and dot color
                let statusLabel = '';
                let dotClass = '';
                if (hasEnergySet) {
                    statusLabel = 'Energy Set âš¡ï¸';
                    dotClass = 'energy-spectrum';
                } else {
                    // Find dominant energy set (4+ of same type)
                    const setEntries = [
                        { name: 'Rising', count: energyCounts.Rising },
                        { name: 'Living', count: energyCounts.Living },
                        { name: 'Fading', count: energyCounts.Fading },
                        { name: 'Resting', count: energyCounts.Resting }
                    ].filter(e => e.count >= 4).sort((a, b) => b.count - a.count);
                    if (setEntries.length > 0) {
                        statusLabel = setEntries[0].name + ' City Set';
                        dotClass = 'energy-' + setEntries[0].name.toLowerCase();
                    }
                }
                // Grid status as fallback
                if (!statusLabel && gridCount >= 1) {
                    statusLabel = gridCount > 1 ? gridCount + 'Ã— Grid' : 'Grid';
                    dotClass = 'energy-grid';
                }

                const statusBadge = statusLabel
                    ? `<span class="top-collector-status"><span class="top-collector-status-dot ${dotClass}"></span><span class="top-collector-status-label">${statusLabel}</span></span>`
                    : '';

                const meta = i === 0 ? `Top Collector Â· ${collector.count} cities` : `${collector.count} cities`;

                return `<div class="top-collector-row" data-collector="${collector.name}">
                    <span class="top-collector-rank">${medals[i]}</span>
                    <div class="top-collector-info">
                        <div class="top-collector-name"><span>${collector.name}</span>${statusBadge}</div>
                        <div class="top-collector-meta">${meta}</div>
                    </div>
                    <div class="top-collector-chips">${chipsHtml}</div>
                    <span class="top-collector-count">${collector.count}</span>
                </div>`;
            }).join('');

            container.innerHTML = `<div class="top-collectors-highlight-label">Top Collectors</div>${rows}`;
            container.classList.add('visible');

            // Click to view collector
            container.querySelectorAll('.top-collector-row').forEach(row => {
                row.addEventListener('click', () => {
                    fetchCollectorTokens(row.dataset.collector);
                });
            });
        }

        function showLeaderboardView() {
            document.getElementById('pillsView').classList.add('hidden');
            document.getElementById('leaderboardView').classList.add('active');
            document.getElementById('aspiringCollectorView')?.classList.remove('active');
            document.querySelector('.collectors-title-text').textContent = 'LEADERBOARD';
        }

        function showPillsView() {
            document.getElementById('pillsView').classList.remove('hidden');
            document.getElementById('leaderboardView').classList.remove('active');
            document.getElementById('collectorGuideView')?.classList.remove('active');
            document.querySelector('.collectors-title-text').textContent = 'COLLECTORS';
        }

        // Citizen Guide functionality - step-by-step onboarding
        let currentGuideStep = 1;
        const totalGuideSteps = 3;

        function showCollectorGuideView() {
            document.getElementById('pillsView').classList.add('hidden');
            document.getElementById('leaderboardView').classList.remove('active');
            document.getElementById('collectorGuideView').classList.add('active');
            document.querySelector('.collectors-title-text').textContent = 'BECOME A CITIZEN';
            currentGuideStep = 1;
            updateGuideStep();
        }

        function updateGuideStep() {
            // Update step numbers
            const stepNums = document.querySelectorAll('.collector-guide-step-num');
            stepNums.forEach((num, i) => {
                const stepNum = i + 1;
                num.classList.toggle('active', stepNum === currentGuideStep);
                num.classList.toggle('completed', stepNum < currentGuideStep);
            });

            // Update steps visibility
            const steps = document.querySelectorAll('.collector-guide-step');
            steps.forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.toggle('active', stepNum === currentGuideStep);
            });

            // Update nav arrows
            const prevBtn = document.getElementById('guidePrevBtn');
            const nextBtn = document.getElementById('guideNextBtn');
            if (prevBtn) prevBtn.disabled = currentGuideStep === 1;
            if (nextBtn) nextBtn.style.visibility = currentGuideStep === totalGuideSteps ? 'hidden' : 'visible';
        }

        function initCollectorGuide() {
            const becomeBtn = document.getElementById('becomeCollectorBtn');
            const backBtn = document.getElementById('backFromGuide');
            const prevBtn = document.getElementById('guidePrevBtn');
            const nextBtn = document.getElementById('guideNextBtn');
            const exploreBtn = document.getElementById('guideExploreGrid');

            if (becomeBtn) {
                becomeBtn.addEventListener('click', showCollectorGuideView);
            }

            const notCollectorTop = document.getElementById('notCollectorTop');
            if (notCollectorTop) {
                notCollectorTop.addEventListener('click', showCollectorGuideView);
            }

            if (backBtn) {
                backBtn.addEventListener('click', showPillsView);
            }

            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentGuideStep > 1) {
                        currentGuideStep--;
                        updateGuideStep();
                    }
                });
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentGuideStep < totalGuideSteps) {
                        currentGuideStep++;
                        updateGuideStep();
                    }
                });
            }

            if (exploreBtn) {
                exploreBtn.addEventListener('click', () => {
                    showPillsView();
                    setTimeout(() => openGridView(), 100);
                });
            }

            const guideDreamBtn = document.getElementById('guideDreamGrid');
            if (guideDreamBtn) {
                guideDreamBtn.addEventListener('click', () => {
                    if (typeof openDreamGrid === 'function') openDreamGrid();
                });
            }

            // Allow clicking step numbers to navigate
            const stepNums = document.querySelectorAll('.collector-guide-step-num');
            stepNums.forEach(num => {
                num.addEventListener('click', () => {
                    currentGuideStep = parseInt(num.dataset.step);
                    updateGuideStep();
                });
            });
        }

        async function fetchCollectorsData() {
            try {
                // Fetch all tokens with their owners from Art Blocks API
                const query = `{
                    tokens_metadata(where: {contract_address: {_eq: "${CONTRACT}"}}) {
                        token_id
                        owner_address
                    }
                }`;
                const response = await fetch('https://data.artblocks.io/v1/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await response.json();

                if (data.data?.tokens_metadata) {
                    // Group by owner address
                    const ownerCounts = {};
                    data.data.tokens_metadata.forEach(token => {
                        const addr = token.owner_address;
                        if (!ownerCounts[addr]) ownerCounts[addr] = { count: 0, tokens: [] };
                        ownerCounts[addr].count++;
                        ownerCounts[addr].tokens.push(parseInt(token.token_id));
                    });

                    // Fetch display names for all owners
                    const addresses = Object.keys(ownerCounts);
                    const usersQuery = `{
                        users(where: {public_address: {_in: [${addresses.map(a => `"${a}"`).join(',')}]}}) {
                            public_address
                            display_name
                        }
                    }`;
                    const usersResponse = await fetch('https://data.artblocks.io/v1/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: usersQuery })
                    });
                    const usersData = await usersResponse.json();

                    // Map addresses to display names
                    const addressToName = {};
                    if (usersData.data?.users) {
                        usersData.data.users.forEach(u => {
                            if (u.display_name) addressToName[u.public_address] = u.display_name;
                        });
                    }

                    // Use global NAME_ALIASES and applyNameAlias function for consistency

                    // Direct wallet address to name mappings (exact match)
                    const walletAddressAliases = {
                        '0x5e3ace83a12c4e46c675dabe2935d379fb40b139': 'Healing Lens',
                        '0xfcdd256267ade068babfb94f526a47aadf143a55': 'Soren Wrenn',
                        '0x9ec022d5d0b2540941ce76b3ec65936542246fa6': 'Watt',
                        '0xce53dd21732b73d72e546c184be0c0c10ab2fd8c': 'Alderman',
                        '0xe85041b675b616f635798a63db467289e5aa1e4d': 'Meowski',
                        '0x81c21cce0616a54018de7fa8d284a430a1edfbd8': 'ceiba',
                        '0x3a661a18cb0258119636dfdde098648c6ad5ba62': 'MRC Arte',
                        '0xf4872eb5b0edc03be22e5d8c2b3d7bb0693b73c8': 'Eric Booc',
                        '0x218a211431d5592316717bb9ac07d36f18d3c8ef': 'Ol1y',
                        '0xd3c624134166c385256f125cac3aed2ff18134a3': 'Basechain',
                        '0x1fffac0101e4604a83bbb5bb0d783c965c2c6f21': '0xAmanda',
                        '0x5932ff2c8b86dde43c9920beb1e58c278d9e0d42': 'Max Pretends',
                        '0x3a88bc828083eadea53f87520250e092b72350f2': 'X Lansky',
                        '0xec9e512fe7e90134d8ca7295329ccb0a57c91ecb': 'Max Karlan',
                        '0x2531b2ff6a7f08c6ab12c29d1b394788f819deb1': 'Raul On A Stool',
                        '0x1b052edc4df735f0a5e62c1335c94667e7fdc55e': 'Goonie Goo Goo',
                        '0x56bdc5fe7f9752e7f5a381e394acfe72a724462b': 'Cath Simard',
                        '0x9128233a0e77dca38c5abc0810bcfb3663120123': 'OG',
                        '0xdf1fa21aad71c50e642fca3aa4332da17bbea409': 'metaminthr',
                        '0x2979e31f072891bebe9fa3bf41e0f3a6ee3201a0': 'metaminthr',
                        '0x478087e12db15302a364c64cdb79f14ae6c5c9b7': 'archivist',
                        '0x697c89c4bc5344960c26da9517e39204186d7efa': 'archivist',
                        '0xd7e32b8a326ffd9e784a1ee1eea37684a7512171': 'benevity',
                        '0x2285ec40f3618718edf88a305fdf4b9fe89ba5ce': 'm0dest',
                        '0x1e30cd2b897c13ea7217d31d7e26529463c8d078': 'chipmouse',
                        '0x7a72b9d304f90ebacd52d4f43567f6cef46cc4bb': 'chipmouse',
                        '0x97fd6f72f66632df35a2065ccee99f54dd8b3608': 'chipmouse',
                        '0x68db9722b96702b1b9b8847a347765184b32ef74': 'chipmouse',
                        '0x9e2d175b89ae9f3b5f1985c6633ae0251539c70a': 'chipmouse',
                        '0x13c5e835177aaf86488412badeab977ad717bcc1': 'Rich Thorne',
                        '0x1115e7bed26542bf247a7f800a9f48d530c3f955': 'Eddie Wharton',
                        '0xe330b0ab6d18e3f523890403a9df284feb4ba2b8': 'Eddie Wharton',
                        '0x30b7b41e299f90ae78a11b764ad2804ab2bf272b': 'Eddie Wharton',
                        '0x1d95b0b6d3582feec7ef35d2ccf91564ded0cf7f': 'desultor',
                        '0x5858eafe41ca64eeaf404c4cf511c24526bea1a2': 'desultor',
                        '0x57f1c8d52bafcbddcaaa71be11fea6e48e11af11': 'vertufineart',
                        '0x9798ff4491c34a2047966b6682379f6b4d4797e7': 'sheipiter',
                        '0xa421d48e2f17402c8165fc4c46ac78cadbd858a9': 'Alimo',
                        '0xe1afe10b5fa6d06c2dcb8a51a185337a07f467a1': 'sirenAI',
                        '0x37ba996dd7eb738af38af7839a17ad19cad5f155': 'Clavdio',
                        '0xe0d209b7324d982bacb757f724ebe00a9792ac28': 'Clavdio',
                        '0x3ec943d60ff956abc2a9e607ae1d66c9b5c4751d': 'lawsonmc90',
                        '0xef2ccdb65f276891fcc615dcdcbcade767c894e8': 'plox9',
                        '0x6263b9edc7a9ee22789ec45995d17d9d21b8a609': 'warren',
                        '0xbe58a1b85d11e2083bb7c5766284ed7848448d1d': 'Marco Peyfuss'
                    };

                    // Prefix-based aliases (for partial matching)
                    const walletPrefixAliases = {
                        '0x6a08': 'WillEP'
                    };

                    // Apply exact wallet address aliases first
                    addresses.forEach(addr => {
                        const lowerAddr = addr.toLowerCase();
                        if (walletAddressAliases[lowerAddr] && !addressToName[addr]) {
                            addressToName[addr] = walletAddressAliases[lowerAddr];
                        }
                    });

                    // Apply wallet prefix aliases - match addresses by their starting characters
                    addresses.forEach(addr => {
                        const lowerAddr = addr.toLowerCase();
                        Object.keys(walletPrefixAliases).forEach(prefix => {
                            if (lowerAddr.startsWith(prefix.toLowerCase()) && !addressToName[addr]) {
                                addressToName[addr] = walletPrefixAliases[prefix];
                            }
                        });
                    });

                    // Apply applyNameAlias to existing names (removes .eth, applies aliases)
                    Object.keys(addressToName).forEach(addr => {
                        addressToName[addr] = applyNameAlias(addressToName[addr]);
                    });

                    // Try ENS resolution for ALL addresses without names
                    // Process in batches to avoid overwhelming the API
                    const addressesWithoutNames = addresses.filter(addr => !addressToName[addr]);
                    const batchSize = 25;

                    for (let i = 0; i < addressesWithoutNames.length; i += batchSize) {
                        const batch = addressesWithoutNames.slice(i, i + batchSize);
                        const ensPromises = batch.map(async addr => {
                            try {
                                const ensResponse = await fetch(`https://api.ensideas.com/ens/resolve/${addr}`);
                                if (ensResponse.ok) {
                                    const ensData = await ensResponse.json();
                                    if (ensData.name) {
                                        addressToName[addr] = ensData.name;
                                    }
                                }
                            } catch (e) { /* ENS fetch failed, continue */ }
                        });
                        await Promise.all(ensPromises);
                    }

                    // Apply applyNameAlias to all names (removes .eth, applies aliases)
                    Object.keys(addressToName).forEach(addr => {
                        addressToName[addr] = applyNameAlias(addressToName[addr]);
                    });

                    // Build collectors array (exclude efdot and efdot x diid)
                    const excludeNames = ['efdot', 'efdot x diid', 'efdotxdiid'];
                    // Names whose tokens should be excluded from try-mode suggestions
                    const tryModeExcludeNames = ['efdot', 'efdot x diid', 'efdotxdiid', 'diid', 'the lost cities'];
                    const LOST_CITIES_PREFIX = '0xcf22';

                    const allCollectorsRaw = addresses.map(addr => ({
                        name: addressToName[addr] || addr.slice(0, 6) + '...' + addr.slice(-4),
                        address: addr,
                        count: ownerCounts[addr].count,
                        tokens: ownerCounts[addr].tokens,
                        hasName: !!addressToName[addr]
                    }));

                    // Collect project wallet tokens for try-mode exclusion
                    PROJECT_WALLET_TOKENS = new Set();
                    allCollectorsRaw.forEach(c => {
                        const nameLower = c.name.toLowerCase();
                        const isExcluded = tryModeExcludeNames.some(ex => nameLower.includes(ex)) ||
                            (c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX));
                        if (isExcluded) {
                            c.tokens.forEach(t => PROJECT_WALLET_TOKENS.add(t));
                        }
                    });

                    const rawCollectors = allCollectorsRaw.filter(c => !excludeNames.some(ex => c.name.toLowerCase().includes(ex.toLowerCase())));

                    // Merge collectors with same display name (e.g., WillEP from multiple wallets)
                    const mergedByName = {};
                    rawCollectors.forEach(c => {
                        if (mergedByName[c.name]) {
                            mergedByName[c.name].count += c.count;
                            mergedByName[c.name].tokens = mergedByName[c.name].tokens.concat(c.tokens);
                        } else {
                            mergedByName[c.name] = { ...c };
                        }
                    });

                    COLLECTORS_DATA = Object.values(mergedByName)
                    // Sort: named collectors first (by count), then wallet-only (by count)
                    .sort((a, b) => {
                        if (a.hasName && !b.hasName) return -1;
                        if (!a.hasName && b.hasName) return 1;
                        return b.count - a.count;
                    });

                    // Update stats
                    const totalCollectors = COLLECTORS_DATA.length;
                    const totalCollected = data.data.tokens_metadata.length;
                    document.querySelector('.collectors-stats').innerHTML = `<strong>${totalCollected}</strong> ðŸ™ï¸ collected by <strong>${totalCollectors}</strong> citizens`;
                    const statsEl = document.getElementById('statsCollectors');
                    if (statsEl) statsEl.textContent = totalCollectors;

                    // Re-render
                    renderCollectorsPills();
                    renderLeaderboard();
                    renderTopCollectors();

                    // Re-render grid to show collectors on palette bars
                    if (tokenDataReady && document.getElementById('gridPanel')?.classList.contains('open')) {
                        renderGrid();
                    }

                    // Initialize daily spotlight
                    initSpotlight();
                }
            } catch (e) {
                console.log('Error fetching collectors:', e);
                // Show error state instead of infinite loading
                const pillsEl = document.getElementById('collectorsPills');
                if (pillsEl && pillsEl.innerHTML.includes('Loading')) {
                    pillsEl.innerHTML = '<span style="color: var(--text-muted); font-size: 10px; cursor: pointer;" onclick="initCollectorsPanel()">Collectors unavailable â€” tap to retry</span>';
                }
            }
        }

        // Print inquiry modal - defined at top level so all handlers can access directly
        let printInquirySelectedCities = [];
        let printInquiryPreviewIndex = 0;
        let printInquiryFrameColor = 'light-wood';
        let printInquiryDarkWall = false;

        const printFrameColorMap = {
            'light-wood': { frame: '#c4a47a', inner: '#ffffff' },
            'white': { frame: '#faf9f7', inner: '#ffffff' },
            'black': { frame: '#1a1a1a', inner: '#f5f3f0' },
            'dark-wood': { frame: '#5a3d2b', inner: '#faf9f7' }
        };

        function openPrintInquiryModal(cities) {
            const modal = document.getElementById('printInquiryModal');
            const form = document.getElementById('printInquiryForm');
            const success = document.getElementById('printInquirySuccess');

            // Show form, hide success
            if (form) form.style.display = 'block';
            if (success) success.style.display = 'none';

            // Inherit dark mode from wall view or frame mockup
            const wallModal = document.getElementById('wallViewModal');
            const frameMockup = document.getElementById('frameMockup');
            const wallDark = wallModal && wallModal.classList.contains('open') && wallModal.classList.contains('wall-black');
            const frameDark = frameMockup && frameMockup.classList.contains('dark-mode');
            if (wallDark || frameDark) {
                modal?.classList.add('dark');
                printInquiryDarkWall = true;
            } else {
                modal?.classList.remove('dark');
                printInquiryDarkWall = false;
            }

            // Inherit frame color from frame mockup if available
            if (typeof currentFrameColor !== 'undefined' && currentFrameColor) {
                printInquiryFrameColor = currentFrameColor;
            } else {
                printInquiryFrameColor = 'light-wood';
            }

            // Initialize selected cities - use passed cities, wall view, or current token
            if (cities && cities.length > 0) {
                printInquirySelectedCities = [...cities];
            } else if (typeof wallViewTokenIds !== 'undefined' && wallViewTokenIds && wallViewTokenIds.length > 0) {
                printInquirySelectedCities = [...wallViewTokenIds];
            } else if (typeof currentTokenId !== 'undefined' && currentTokenId !== null) {
                printInquirySelectedCities = [currentTokenId];
            } else {
                printInquirySelectedCities = [];
            }
            printInquiryPreviewIndex = 0;
            renderPrintInquiryPreview();

            // Reset details toggle
            document.getElementById('printInquiryDetailsToggle')?.classList.remove('open');
            document.getElementById('printInquiryDetailsExtra')?.classList.remove('open');

            // Always show preview; toggle frameless mode and frame colors based on framed option
            const activeSize = document.querySelector('.print-inquiry-size-option.active');
            const framePreviewEl = document.getElementById('printInquiryFramePreview');
            const miniFrameEl = document.getElementById('printInquiryMiniFrame');
            const frameColorsEl = document.querySelector('.print-inquiry-frame-colors');
            const wallToggleEl = document.getElementById('printInquiryWallToggle');
            const isFramed = activeSize && activeSize.dataset.framed === 'true';
            if (framePreviewEl) framePreviewEl.style.display = '';
            if (miniFrameEl) miniFrameEl.classList.toggle('frameless', !isFramed);
            if (frameColorsEl) frameColorsEl.style.display = isFramed ? '' : 'none';
            if (wallToggleEl) wallToggleEl.style.display = isFramed ? '' : 'none';

            // Set title based on active selection
            const titleEl = document.getElementById('printInquiryTitle');
            if (titleEl && activeSize) {
                if (activeSize.dataset.size === '9x16') titleEl.textContent = 'Get a Poster';
                else if (activeSize.dataset.framed === 'true') titleEl.textContent = 'Get a Framed Print';
                else titleEl.textContent = 'Get a Print';
            }

            if (modal) modal.classList.add('open');
        }
        window.openPrintInquiryModal = openPrintInquiryModal;

        function renderPrintInquiryPreview() {
            const previewImg = document.getElementById('printInquiryPreviewImg');
            const frameLabel = document.getElementById('printInquiryFrameLabel');
            const cityStrip = document.getElementById('printInquiryCityStrip');
            const miniFrame = document.getElementById('printInquiryMiniFrame');
            const framePreview = document.getElementById('printInquiryFramePreview');

            if (!previewImg || !miniFrame) return;

            // Show first (or selected) city in the frame preview
            const previewCity = printInquirySelectedCities[printInquiryPreviewIndex] || printInquirySelectedCities[0];
            if (previewCity !== undefined) {
                previewImg.src = `${MEDIA_BASE}/${CONTRACT}/${previewCity}.png?width=400`;
                if (frameLabel) frameLabel.textContent = `#${previewCity}`;
            }

            // Apply frame color
            miniFrame.classList.remove('frame-white', 'frame-black', 'frame-dark-wood');
            if (printInquiryFrameColor !== 'light-wood') {
                miniFrame.classList.add('frame-' + printInquiryFrameColor);
            }
            const colors = printFrameColorMap[printInquiryFrameColor];
            miniFrame.style.background = colors.frame;
            miniFrame.querySelector('.print-inquiry-mini-inner').style.background = colors.inner;

            // Sync frame color picker
            document.querySelectorAll('.print-inquiry-frame-color').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === printInquiryFrameColor);
            });

            // Apply dark wall
            if (framePreview) {
                framePreview.classList.toggle('dark-wall', printInquiryDarkWall);
            }
            const wallToggle = document.getElementById('printInquiryWallToggle');
            if (wallToggle) wallToggle.textContent = printInquiryDarkWall ? '\u2600' : '\u263E';

            // Render city strip for multiple cities
            if (cityStrip) {
                if (printInquirySelectedCities.length > 1) {
                    const maxShow = 6;
                    const visible = printInquirySelectedCities.slice(0, maxShow);
                    const extra = printInquirySelectedCities.length - maxShow;
                    cityStrip.innerHTML = visible.map((id, i) =>
                        `<div class="print-inquiry-city-strip-thumb ${i === printInquiryPreviewIndex ? 'active' : ''}" data-index="${i}">
                            <img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=60" alt="#${id}">
                        </div>`
                    ).join('') + (extra > 0 ? `<div class="print-inquiry-city-strip-more">+${extra}</div>` : '');

                    // Click to switch preview
                    cityStrip.querySelectorAll('.print-inquiry-city-strip-thumb').forEach(thumb => {
                        thumb.addEventListener('click', () => {
                            printInquiryPreviewIndex = parseInt(thumb.dataset.index);
                            renderPrintInquiryPreview();
                        });
                    });
                    cityStrip.style.display = 'flex';
                } else {
                    cityStrip.style.display = 'none';
                }
            }
        }

        function initCollectorsPanel() {
            // Show loading state
            document.getElementById('collectorsPills').innerHTML = '<span style="color: var(--text-muted); font-size: 10px;">Loading collectors...</span>';

            // Setup patrons section
            setupPatronsSection();

            // Fetch live data
            fetchCollectorsData();

            document.getElementById('showLeaderboard')?.addEventListener('click', () => {
                const leaderboardView = document.getElementById('leaderboardView');
                if (leaderboardView.classList.contains('active')) {
                    showPillsView();
                } else {
                    showLeaderboardView();
                }
            });
            document.getElementById('backToPills')?.addEventListener('click', showPillsView);
            document.getElementById('collectorBannerClose')?.addEventListener('click', (e) => {
                e.stopPropagation();
                clearCollectorFilter();
            });

            // Clicking the banner opens wall view (except close/nav buttons)
            document.getElementById('collectorBanner')?.addEventListener('click', (e) => {
                if (e.target.closest('.collector-banner-close') ||
                    e.target.closest('.collector-banner-nav')) {
                    return;
                }
                handleWallButtonClick();
            });

            // Helper function to open wall for current collector (in dark mode)
            async function openCurrentCollectorWall() {
                let opened = false;

                // First try currentCollectorFilter
                if (currentCollectorFilter && currentCollectorFilter.tokens && currentCollectorFilter.tokens.length > 0) {
                    openWallView(currentCollectorFilter.name, currentCollectorFilter.tokens);
                    opened = true;
                } else {
                    // Fallback: try to get collector from banner name
                    const bannerName = document.getElementById('collectorBannerName')?.textContent;
                    if (bannerName) {
                        // Try to find collector in data
                        const collector = COLLECTORS_DATA.find(c => c.name === bannerName);
                        if (collector && collector.tokens && collector.tokens.length > 0) {
                            openWallView(collector.name, collector.tokens);
                            opened = true;
                        } else if (collector && collector.address) {
                            // Try fetching tokens for this collector if we have their address
                            try {
                                const response = await fetch(`https://token-api.artblocks.io/0x99a9b7c1116f9ceeb1652de04d5969cce509b069-0/tokens?owner=${collector.address}`);
                                const data = await response.json();
                                const tokens = data.tokens ? data.tokens.map(t => parseInt(t.tokenId.split('-').pop())) : [];
                                if (tokens.length > 0) {
                                    openWallView(bannerName, tokens);
                                    opened = true;
                                }
                            } catch (e) {
                                console.error('Error fetching collector tokens:', e);
                            }
                        }
                    }
                }

                // Ensure dark/black mode after opening
                if (opened) {
                    setTimeout(() => {
                        const modal = document.getElementById('wallViewModal');
                        if (modal) {
                            modal.classList.remove('wall-gray');
                            modal.classList.add('wall-black');
                            currentWallColor = 'black';
                        }
                    }, 50);
                    return true;
                }

                console.warn('Could not open wall view - no collector data found');
                return false;
            }

            // Helper to set dark mode on wall view
            function setWallDarkMode() {
                setTimeout(() => {
                    const modal = document.getElementById('wallViewModal');
                    if (modal) {
                        modal.classList.remove('wall-gray');
                        modal.classList.add('wall-black');
                        currentWallColor = 'black';
                    }
                }, 10);
            }

            // Helper to call openWallView (handles timing issues)
            function callOpenWallView(name, tokens) {
                const fn = window.openWallView || openWallViewFn;
                if (typeof fn === 'function') {
                    fn(name, tokens);
                    setWallDarkMode();
                    return true;
                }
                console.error('openWallView not available yet');
                return false;
            }

            // Collector name and wall button use inline onclick handlers
            // (handleCollectorNameClick and handleWallButtonClick)
            document.getElementById('wallViewClose')?.addEventListener('click', closeWallView);

            // Back to all collectors button
            document.getElementById('wallViewBackBtn')?.addEventListener('click', () => {
                closeWallView();
                currentCollectorFilter = null;
                document.getElementById('collectorBanner')?.classList.remove('visible');
                collectorsPanel.classList.add('open');
                document.body.classList.add('collectors-open');
                startPatronsAutoReveal();
                renderGrid();
            });

            // Double-click on wall to exit
            document.getElementById('wallViewContent')?.addEventListener('dblclick', (e) => {
                if (e.target.closest('.wall-view-frame')) return;
                closeWallView();
            });

            // Click collector name to return to wall view
            document.getElementById('wallViewCollectorName')?.addEventListener('click', () => {
                // Refresh the wall view (in case coming from grid)
                if (currentCollectorFilter) {
                    openWallView(currentCollectorFilter.name, currentCollectorFilter.tokens);
                }
            });

            // Note: Dark mode toggle removed - now using wall color options instead

            // Collector navigation
            document.getElementById('wallViewPrev')?.addEventListener('click', navigateToPrevCollector);
            document.getElementById('wallViewNext')?.addEventListener('click', navigateToNextCollector);


            // Wall color options
            document.getElementById('wallViewWallToggle')?.addEventListener('click', () => {
                const modal = document.getElementById('wallViewModal');
                const isBlack = modal.classList.contains('wall-black');
                modal.classList.remove('wall-gray', 'wall-black', 'wall-colorful', 'dark-mode');
                if (isBlack) {
                    modal.classList.add('wall-gray');
                    currentWallColor = 'gray';
                } else {
                    modal.classList.add('wall-black');
                    currentWallColor = 'black';
                }
            });

            // Grid / Line view toggle - button shows CURRENT state
            document.getElementById('wallViewHideEmpty')?.addEventListener('click', () => {
                const btn = document.getElementById('wallViewHideEmpty');
                const modal = document.getElementById('wallViewModal');
                modal?.classList.toggle('line-view');
                btn?.classList.toggle('active');

                // Toggle button icon and text - shows CURRENT state (GRID when in grid, LINE when in line)
                if (btn) {
                    const isLine = modal?.classList.contains('line-view');
                    btn.innerHTML = isLine ? '<span class="line-icon">â–­</span> LINE' : '<span class="line-icon">âŠž</span> GRID';
                }
            });

            // Layout toggle - switch between wide (more columns) and default layout
            document.getElementById('wallViewLayoutToggle')?.addEventListener('click', () => {
                const btn = document.getElementById('wallViewLayoutToggle');
                const wall = document.getElementById('wallViewWall');
                const modal = document.getElementById('wallViewModal');

                wideLayoutMode = !wideLayoutMode;
                btn?.classList.toggle('active', wideLayoutMode);

                // Get current city count
                const cityCount = wall?.querySelectorAll('.wall-view-artwork').length || 0;

                // Remove all column classes
                wall.className = wall.className.replace(/cols-\d+/g, '').trim();
                wall.classList.add('wall-view-wall');

                if (wideLayoutMode) {
                    // Wide layout - more columns, fewer rows
                    let cols;
                    if (cityCount <= 4) cols = cityCount;
                    else if (cityCount <= 8) cols = Math.min(cityCount, 4);
                    else if (cityCount <= 12) cols = 6;
                    else if (cityCount <= 16) cols = 8;
                    else cols = Math.min(10, Math.ceil(cityCount / 2));
                    wall.classList.add(`cols-${cols}`);
                    // Zoom out more for wide view
                    wallViewZoom = cityCount > 8 ? 0.7 : 0.85;
                } else {
                    // Default layout
                    const layout = getOptimalGridLayout(cityCount);
                    wall.classList.add(`cols-${layout.cols}`);
                    // Reset zoom based on grid size - match openWallView logic
                    if (layout.rows >= 3 && layout.cols >= 7) wallViewZoom = 0.55;
                    else if (layout.rows >= 3) wallViewZoom = 0.6;
                    else if (layout.rows >= 2 && layout.cols >= 5) wallViewZoom = 0.65;
                    else if (cityCount === 4) wallViewZoom = 0.72;
                    else if (layout.rows >= 2) wallViewZoom = 0.7;
                    else if (cityCount === 2) wallViewZoom = 0.75;
                    else if (cityCount <= 3) wallViewZoom = 0.8;
                    else wallViewZoom = 1;
                }
                applyWallZoom();
            });

            // Try mode toggle - allows temporarily adding cities to see how they'd look
            document.getElementById('wallViewTryMode')?.addEventListener('click', (e) => {
                const btn = document.getElementById('wallViewTryMode');
                const modal = document.getElementById('wallViewModal');
                const wall = document.getElementById('wallViewWall');

                btn?.classList.toggle('active');
                wallViewTryMode = btn?.classList.contains('active') || false;

                if (wallViewTryMode && wall) {
                    // Add one empty try-mode slot
                    const existingTrySlots = wall.querySelectorAll('.wall-view-artwork.try-mode-slot').length;

                    if (existingTrySlots === 0) {
                        const realCities = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
                        const tempCities = wall.querySelectorAll('.wall-view-frame.temp-city').length;
                        const totalCities = realCities + tempCities;

                        // Add exactly one try slot and recalculate grid for count + 1
                        addTryModeSlot(wall);
                        const newLayout = getOptimalGridLayout(totalCities + 1);
                        wall.className = wall.className.replace(/cols-\d+/, '');
                        wall.classList.add(`cols-${newLayout.cols}`);
                        modal.classList.add('has-empty-slots');
                    }
                } else if (!wallViewTryMode && wall) {
                    // Remove try-mode empty slots (keep temp cities)
                    const tryModeSlots = wall.querySelectorAll('.wall-view-artwork.try-mode-slot');
                    tryModeSlots.forEach(slot => slot.remove());

                    // Restore original grid layout for small collections
                    const realCities = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
                    const tempCities = wall.querySelectorAll('.wall-view-frame.temp-city').length;
                    const totalCities = realCities + tempCities;
                    const newLayout = getOptimalGridLayout(totalCities);
                    wall.className = wall.className.replace(/cols-\d+/, '');
                    wall.classList.add(`cols-${newLayout.cols}`);
                    modal.classList.remove('has-empty-slots');
                }

                updateGridNudge();
            });

            // Print button - opens inquiry modal
            document.getElementById('wallViewPrint')?.addEventListener('click', () => {
                openPrintInquiryModal();
            });

            // Print inquiry state and rendering now at top-level scope (before initCollectorsPanel)
            // so handlers outside initCollectorsPanel can access them directly

            // Size toggle
            let printInquirySize = '18x32';
            let printInquiryPrice = 250;
            document.querySelectorAll('.print-inquiry-size-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    document.querySelectorAll('.print-inquiry-size-option').forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    printInquirySize = opt.dataset.size;
                    printInquiryPrice = parseInt(opt.dataset.price);
                    // Toggle frameless mode and frame controls based on framed option
                    const isFramed = opt.dataset.framed === 'true';
                    const miniFrame = document.getElementById('printInquiryMiniFrame');
                    const frameColors = document.querySelector('.print-inquiry-frame-colors');
                    const wallToggle = document.getElementById('printInquiryWallToggle');
                    if (miniFrame) miniFrame.classList.toggle('frameless', !isFramed);
                    if (frameColors) frameColors.style.display = isFramed ? '' : 'none';
                    if (wallToggle) wallToggle.style.display = isFramed ? '' : 'none';
                    // Update title based on selected product
                    const titleEl = document.getElementById('printInquiryTitle');
                    if (titleEl) {
                        if (opt.dataset.size === '9x16') titleEl.textContent = 'Get a Poster';
                        else if (opt.dataset.framed === 'true') titleEl.textContent = 'Get a Framed Print';
                        else titleEl.textContent = 'Get a Print';
                    }
                });
            });

            // Currency conversion for international visitors (IP-based geolocation)
            (function initCurrencyConversion() {
                fetch('https://ipapi.co/json/')
                    .then(r => r.json())
                    .then(geo => {
                        const country = geo.country_code;
                        const userCurrency = geo.currency;
                        // Skip if user is in the US or currency couldn't be determined
                        if (!userCurrency || userCurrency === 'USD' || country === 'US') return;
                        // Fetch exchange rate
                        return fetch('https://open.er-api.com/v6/latest/USD')
                            .then(r => r.json())
                            .then(data => {
                                if (!data.rates || !data.rates[userCurrency]) return;
                                const rate = data.rates[userCurrency];
                                document.querySelectorAll('.print-inquiry-size-option').forEach(opt => {
                                    const usdPrice = parseInt(opt.dataset.price);
                                    const converted = Math.round(usdPrice * rate);
                                    const formatted = new Intl.NumberFormat(navigator.language, {
                                        style: 'currency',
                                        currency: userCurrency,
                                        maximumFractionDigits: 0,
                                    }).format(converted);
                                    const el = opt.querySelector('.size-price-converted');
                                    if (el) el.textContent = 'â‰ˆ ' + formatted;
                                });
                            });
                    })
                    .catch(() => { /* silently fail - conversion is supplementary */ });
            })();

            // Frame color picker in print form
            document.querySelectorAll('.print-inquiry-frame-color').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    printInquiryFrameColor = btn.dataset.color;
                    renderPrintInquiryPreview();
                });
            });

            // Wall color toggle in print form
            document.getElementById('printInquiryWallToggle')?.addEventListener('click', (e) => {
                e.stopPropagation();
                printInquiryDarkWall = !printInquiryDarkWall;
                const modal = document.getElementById('printInquiryModal');
                if (printInquiryDarkWall) {
                    modal?.classList.add('dark');
                } else {
                    modal?.classList.remove('dark');
                }
                renderPrintInquiryPreview();
            });

            // Details toggle
            document.getElementById('printInquiryDetailsToggle')?.addEventListener('click', () => {
                const toggle = document.getElementById('printInquiryDetailsToggle');
                const extra = document.getElementById('printInquiryDetailsExtra');
                toggle?.classList.toggle('open');
                extra?.classList.toggle('open');
            });

            document.getElementById('printInquiryClose')?.addEventListener('click', () => {
                document.getElementById('printInquiryModal').classList.remove('open');
            });

            document.getElementById('printInquiryCancel')?.addEventListener('click', () => {
                document.getElementById('printInquiryModal').classList.remove('open');
            });

            document.getElementById('printInquiryDone')?.addEventListener('click', () => {
                document.getElementById('printInquiryModal').classList.remove('open');
                // Reset form for next time
                document.getElementById('printInquiryForm').style.display = 'block';
                document.getElementById('printInquirySuccess').style.display = 'none';
                document.getElementById('printInquiryEmail').value = '';
                document.getElementById('printInquiryCountry').value = 'United States';
                document.getElementById('printInquiryNotes').value = '';
                // Reset size toggle to default (signed print, index 1)
                document.querySelectorAll('.print-inquiry-size-option').forEach((o, i) => o.classList.toggle('active', i === 1));
                printInquirySize = '18x32';
                printInquiryPrice = 250;
                // Reset title
                const titleEl = document.getElementById('printInquiryTitle');
                if (titleEl) titleEl.textContent = 'Get a Print';
                // Reset frame preview for non-framed default
                const fp = document.getElementById('printInquiryFramePreview');
                const mf = document.getElementById('printInquiryMiniFrame');
                const fc = document.querySelector('.print-inquiry-frame-colors');
                const wt = document.getElementById('printInquiryWallToggle');
                if (mf) mf.classList.add('frameless');
                if (fc) fc.style.display = 'none';
                if (wt) wt.style.display = 'none';
            });

            document.getElementById('printInquirySend')?.addEventListener('click', () => {
                // Open Efdot Shop in a new tab
                window.open('https://shop.efdotstudio.com/collections/cities-collection', '_blank');

                // Close the print inquiry modal
                document.getElementById('printInquiryModal').classList.remove('open');
            });

            // Close modal on backdrop click
            document.getElementById('printInquiryModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'printInquiryModal') {
                    document.getElementById('printInquiryModal').classList.remove('open');
                }
            });

            // OpenSea warning modal for Make Offer button
            document.getElementById('makeOfferBtn')?.addEventListener('click', (e) => {
                e.preventDefault();
                const url = e.currentTarget.dataset.openseaUrl;
                if (!url) return;
                const modal = document.getElementById('openseaWarningModal');
                modal.dataset.targetUrl = url;
                modal.classList.add('open');
            });
            document.getElementById('openseaWarningContinue')?.addEventListener('click', () => {
                const modal = document.getElementById('openseaWarningModal');
                const url = modal.dataset.targetUrl;
                modal.classList.remove('open');
                if (url) window.open(url, '_blank');
            });
            document.getElementById('openseaWarningCancel')?.addEventListener('click', () => {
                document.getElementById('openseaWarningModal').classList.remove('open');
            });
            document.getElementById('openseaWarningModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'openseaWarningModal') {
                    document.getElementById('openseaWarningModal').classList.remove('open');
                }
            });

            // Shuffle button - randomize city positions
            document.getElementById('wallViewShuffle')?.addEventListener('click', () => {
                const wall = document.getElementById('wallViewWall');
                const artworks = Array.from(wall.querySelectorAll('.wall-view-artwork'));
                // Fisher-Yates shuffle
                for (let i = artworks.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    wall.appendChild(artworks[j]);
                    [artworks[i], artworks[j]] = [artworks[j], artworks[i]];
                }
                // Update wallViewTokenIds to match new order
                wallViewTokenIds = Array.from(wall.querySelectorAll('.wall-view-frame')).map(f => parseInt(f.dataset.tokenId));
                saveWallOrder();
            });

            // Drag-to-swap: click and drag one city onto another to swap positions
            let dragSourceArtwork = null;
            let dragStartPos = { x: 0, y: 0 };
            const DRAG_THRESHOLD = 8; // px before drag activates

            function setupDragSwap(wall) {
                if (!wall) return;

                wall.addEventListener('mousedown', (e) => {
                    const artwork = e.target.closest('.wall-view-artwork');
                    if (!artwork || !artwork.querySelector('.wall-view-frame:not(.empty-slot)')) return;
                    // Don't initiate drag on buttons or action elements
                    if (e.target.closest('button') || e.target.closest('.temp-city-actions')) return;

                    dragStartPos = { x: e.clientX, y: e.clientY };
                    dragSourceArtwork = artwork;
                    isDragSwapping = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!dragSourceArtwork) return;
                    const dx = e.clientX - dragStartPos.x;
                    const dy = e.clientY - dragStartPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (!isDragSwapping && dist > DRAG_THRESHOLD) {
                        isDragSwapping = true;
                        dragSourceArtwork.classList.add('dragging');
                        e.preventDefault();
                    }

                    if (isDragSwapping) {
                        e.preventDefault();
                        // Find artwork under cursor
                        const allArtworks = wall.querySelectorAll('.wall-view-artwork');
                        allArtworks.forEach(a => a.classList.remove('drag-over'));

                        const target = getArtworkAtPoint(e.clientX, e.clientY, wall);
                        if (target && target !== dragSourceArtwork && target.querySelector('.wall-view-frame:not(.empty-slot)')) {
                            target.classList.add('drag-over');
                        }
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (!dragSourceArtwork) return;

                    if (isDragSwapping) {
                        const target = getArtworkAtPoint(e.clientX, e.clientY, wall);
                        if (target && target !== dragSourceArtwork && target.querySelector('.wall-view-frame:not(.empty-slot)')) {
                            swapArtworks(dragSourceArtwork, target, wall);
                        }
                    }

                    // Clean up all drag states
                    wall.querySelectorAll('.wall-view-artwork').forEach(a => {
                        a.classList.remove('dragging', 'drag-over');
                    });
                    dragSourceArtwork = null;
                    isDragSwapping = false;
                });

                // Touch support
                wall.addEventListener('touchstart', (e) => {
                    const artwork = e.target.closest('.wall-view-artwork');
                    if (!artwork || !artwork.querySelector('.wall-view-frame:not(.empty-slot)')) return;
                    if (e.target.closest('button') || e.target.closest('.temp-city-actions')) return;

                    const touch = e.touches[0];
                    dragStartPos = { x: touch.clientX, y: touch.clientY };
                    dragSourceArtwork = artwork;
                    isDragSwapping = false;
                }, { passive: true });

                wall.addEventListener('touchmove', (e) => {
                    if (!dragSourceArtwork) return;
                    const touch = e.touches[0];
                    const dx = touch.clientX - dragStartPos.x;
                    const dy = touch.clientY - dragStartPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (!isDragSwapping && dist > DRAG_THRESHOLD) {
                        isDragSwapping = true;
                        dragSourceArtwork.classList.add('dragging');
                    }

                    if (isDragSwapping) {
                        e.preventDefault();
                        wall.querySelectorAll('.wall-view-artwork').forEach(a => a.classList.remove('drag-over'));
                        const target = getArtworkAtPoint(touch.clientX, touch.clientY, wall);
                        if (target && target !== dragSourceArtwork && target.querySelector('.wall-view-frame:not(.empty-slot)')) {
                            target.classList.add('drag-over');
                        }
                    }
                }, { passive: false });

                wall.addEventListener('touchend', (e) => {
                    if (!dragSourceArtwork) return;

                    if (isDragSwapping) {
                        const touch = e.changedTouches[0];
                        const target = getArtworkAtPoint(touch.clientX, touch.clientY, wall);
                        if (target && target !== dragSourceArtwork && target.querySelector('.wall-view-frame:not(.empty-slot)')) {
                            swapArtworks(dragSourceArtwork, target, wall);
                        }
                    }

                    wall.querySelectorAll('.wall-view-artwork').forEach(a => {
                        a.classList.remove('dragging', 'drag-over');
                    });
                    dragSourceArtwork = null;
                    isDragSwapping = false;
                });
            }

            function getArtworkAtPoint(x, y, wall) {
                const artworks = wall.querySelectorAll('.wall-view-artwork');
                for (const artwork of artworks) {
                    const rect = artwork.getBoundingClientRect();
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        return artwork;
                    }
                }
                return null;
            }

            function swapArtworks(a, b, wall) {
                // Swap DOM positions
                const aNext = a.nextElementSibling;
                const bNext = b.nextElementSibling;
                const parent = wall;

                if (aNext === b) {
                    // a is right before b
                    parent.insertBefore(b, a);
                } else if (bNext === a) {
                    // b is right before a
                    parent.insertBefore(a, b);
                } else {
                    // Not adjacent - use placeholder approach
                    const placeholder = document.createElement('div');
                    parent.insertBefore(placeholder, a);
                    parent.insertBefore(a, bNext);
                    parent.insertBefore(b, placeholder);
                    placeholder.remove();
                }

                // Flash animation
                a.classList.add('swap-flash');
                b.classList.add('swap-flash');
                setTimeout(() => {
                    a.classList.remove('swap-flash');
                    b.classList.remove('swap-flash');
                }, 350);

                // Update tracking
                wallViewTokenIds = Array.from(wall.querySelectorAll('.wall-view-frame')).map(f => parseInt(f.dataset.tokenId));
                saveWallOrder();
            }

            // Initialize drag-swap on wall
            setupDragSwap(document.getElementById('wallViewWall'));

            // Zoom controls - smaller increments for smoother zooming
            document.getElementById('wallViewZoomIn')?.addEventListener('click', () => {
                wallViewZoom = Math.min(wallViewZoom + 0.1, 4);
                applyWallZoom();
            });
            document.getElementById('wallViewZoomOut')?.addEventListener('click', () => {
                wallViewZoom = Math.max(wallViewZoom - 0.1, 0.3);
                applyWallZoom();
            });
            document.getElementById('wallViewZoomReset')?.addEventListener('click', () => {
                wallViewZoom = 1;
                wallPanX = 0;
                wallPanY = 0;
                applyWallZoom();
            });

            // Recenter button - resets pan and zoom
            document.getElementById('wallViewRecenter')?.addEventListener('click', () => {
                wallViewZoom = 1;
                wallPanX = 0;
                wallPanY = 0;
                applyWallZoom();
            });

            // Nudge bar wall button - opens wall view for current collector
            document.getElementById('wallViewNudgeBtn')?.addEventListener('click', () => {
                const labelEl = document.getElementById('wallViewCollectorLabel');
                const rawName = labelEl?.dataset.rawName;
                if (rawName) {
                    const collector = COLLECTORS_DATA.find(c => c.name === rawName);
                    if (collector && collector.tokens && collector.tokens.length > 0) {
                        openWallView(collector.name, collector.tokens);
                    }
                }
            });

            // Pan with mouse drag
            const wallRoom = document.getElementById('wallViewRoom');
            let isPanning = false;
            let panStartX, panStartY;
            let wallDragDistance = 0;
            let wallMouseDownX = 0, wallMouseDownY = 0;

            wallRoom?.addEventListener('mousedown', (e) => {
                if (e.target.closest('.wall-view-frame') || e.target.closest('.wall-view-empty-frame')) return;
                isPanning = true;
                wallDragDistance = 0;
                wallMouseDownX = e.clientX;
                wallMouseDownY = e.clientY;
                panStartX = e.clientX - wallPanX;
                panStartY = e.clientY - wallPanY;
                wallRoom.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                wallPanX = e.clientX - panStartX;
                wallPanY = e.clientY - panStartY;
                wallDragDistance = Math.abs(e.clientX - wallMouseDownX) + Math.abs(e.clientY - wallMouseDownY);
                applyWallZoom();
            });

            document.addEventListener('mouseup', () => {
                isPanning = false;
                if (wallRoom) wallRoom.style.cursor = 'grab';
            });

            // Click on empty wall area (not a drag) â€” no longer auto-closes
            // Use the âœ• close button or BACK button in the header instead
            // This prevents accidental closure when clicking between frames

            // Mouse wheel / trackpad zoom - very smooth and gradual
            wallRoom?.addEventListener('wheel', (e) => {
                e.preventDefault();
                // Use smaller delta for smoother pinch/trackpad zoom
                const sensitivity = e.ctrlKey ? 0.01 : 0.02; // ctrlKey indicates pinch gesture
                const delta = e.deltaY > 0 ? -sensitivity : sensitivity;
                wallViewZoom = Math.max(0.3, Math.min(4, wallViewZoom + delta));
                applyWallZoom();
            }, { passive: false });

            // Touch pinch zoom for mobile/iPad
            let lastTouchDistance = 0;
            wallRoom?.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: true });

            wallRoom?.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (lastTouchDistance > 0) {
                        const delta = (distance - lastTouchDistance) * 0.005; // Very smooth
                        wallViewZoom = Math.max(0.3, Math.min(4, wallViewZoom + delta));
                        applyWallZoom();
                    }
                    lastTouchDistance = distance;
                }
            }, { passive: true });

            wallRoom?.addEventListener('touchend', () => {
                lastTouchDistance = 0;
            }, { passive: true });

            // Show nudge bar only when mouse is near bottom of screen
            const wallModal = document.getElementById('wallViewModal');
            let nudgeHideTimer = null;
            wallModal?.addEventListener('mousemove', (e) => {
                const nudge = document.getElementById('wallViewGridNudge');
                if (!nudge || !nudge.classList.contains('ready')) return;
                const distFromBottom = window.innerHeight - e.clientY;
                if (distFromBottom < 100) {
                    nudge.classList.add('show');
                    if (nudgeHideTimer) { clearTimeout(nudgeHideTimer); nudgeHideTimer = null; }
                } else {
                    if (!nudgeHideTimer) {
                        nudgeHideTimer = setTimeout(() => {
                            nudge.classList.remove('show');
                            nudgeHideTimer = null;
                        }, 400);
                    }
                }
            });
            wallModal?.addEventListener('mouseleave', () => {
                const nudge = document.getElementById('wallViewGridNudge');
                if (nudge) nudge.classList.remove('show');
                if (nudgeHideTimer) { clearTimeout(nudgeHideTimer); nudgeHideTimer = null; }
            });

        }

        let wallViewTokenIds = [];
        let currentWallCollectorIndex = -1;
        let currentWallColor = 'gray';
        let currentWallAccentColor = '#888';
        let wallViewZoom = 1;
        let wallPanX = 0;
        let wallPanY = 0;
        let wideLayoutMode = false;
        let isDragSwapping = false;

        // Save custom wall order to localStorage
        function saveWallOrder() {
            const wall = document.getElementById('wallViewWall');
            if (!wall) return;
            const labelEl = document.getElementById('wallViewCollectorLabel');
            const collectorName = labelEl?.dataset.rawName;
            if (!collectorName) return;

            const order = Array.from(wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)'))
                .map(f => parseInt(f.dataset.tokenId));
            if (order.length === 0) return;

            try {
                const saved = JSON.parse(localStorage.getItem('cities-wall-orders') || '{}');
                saved[collectorName] = { order, timestamp: Date.now() };
                localStorage.setItem('cities-wall-orders', JSON.stringify(saved));
            } catch(e) {}
        }

        // Get saved wall order for a collector
        function getSavedWallOrder(collectorName) {
            try {
                const saved = JSON.parse(localStorage.getItem('cities-wall-orders') || '{}');
                return saved[collectorName]?.order || null;
            } catch(e) { return null; }
        }

        // Save try-grid cities for a collector (48-hour expiry)
        function saveTryCities(collectorName, tokenIds) {
            if (!collectorName) return;
            try {
                const saved = JSON.parse(localStorage.getItem('cities-try-placements') || '{}');
                if (tokenIds.length === 0) {
                    delete saved[collectorName];
                } else {
                    saved[collectorName] = { tokens: tokenIds, timestamp: Date.now() };
                }
                localStorage.setItem('cities-try-placements', JSON.stringify(saved));
            } catch(e) {}
        }

        // Get saved try-grid cities for a collector (returns null if expired)
        function getSavedTryCities(collectorName) {
            try {
                const saved = JSON.parse(localStorage.getItem('cities-try-placements') || '{}');
                const entry = saved[collectorName];
                if (!entry) return null;
                const FORTY_EIGHT_HOURS = 48 * 60 * 60 * 1000;
                if (Date.now() - entry.timestamp > FORTY_EIGHT_HOURS) {
                    // Expired â€” clean up
                    delete saved[collectorName];
                    localStorage.setItem('cities-try-placements', JSON.stringify(saved));
                    return null;
                }
                return entry.tokens;
            } catch(e) { return null; }
        }

        // Get current collector name from wall view
        function getCurrentWallCollector() {
            const labelEl = document.getElementById('wallViewCollectorLabel');
            return labelEl?.dataset.rawName || null;
        }

        // Grid analysis - supports multiple grids, super grids, etc.
        function analyzeGridStatus(count) {
            // Check for perfect grids first
            const perfectGrids = {
                4: { dims: '2Ã—2', isFirst: true },
                6: { dims: '3Ã—2', isFirst: false },
                8: { dims: '2Ã—4', superGrid: '2 Ã— 2Ã—2', isFirst: false },
                9: { dims: '3Ã—3', isFirst: false },
                12: { dims: '3Ã—4', superGrid: '3 Ã— 2Ã—2', isFirst: false },
                16: { dims: '4Ã—4', superGrid: '4 Ã— 2Ã—2', isFirst: false },
                20: { dims: '5Ã—4', superGrid: '5 Ã— 2Ã—2', isFirst: false },
                25: { dims: '5Ã—5', isFirst: false }
            };

            // Is it a perfect grid?
            if (perfectGrids[count]) {
                return { isPerfect: true, ...perfectGrids[count], count };
            }

            // Find next grid target
            const targets = [4, 6, 8, 9, 12, 16, 20, 25];
            for (const target of targets) {
                if (count < target) {
                    const info = perfectGrids[target];
                    const needed = target - count;
                    return { isPerfect: false, needed, nextTarget: target, dims: info.dims, isFirst: target === 4, count };
                }
            }

            // Beyond 25 - massive collection!
            return { isPerfect: true, dims: null, isMassive: true, count };
        }

        function getOptimalGridLayout(count) {
            // Returns optimal columns for display
            // Prioritizes fewer rows: max 2 rows on desktop, 3 rows for large collections
            if (count === 1) return { cols: 1, rows: 1 };
            if (count === 2) return { cols: 2, rows: 1 };
            if (count === 3) return { cols: 3, rows: 1 };
            if (count === 4) return { cols: 2, rows: 2 };
            if (count === 5) return { cols: 3, rows: 2 }; // 3+2
            if (count === 6) return { cols: 3, rows: 2 };
            if (count === 7) return { cols: 4, rows: 2 }; // 4+3
            if (count === 8) return { cols: 4, rows: 2 };
            if (count === 9) return { cols: 5, rows: 2 }; // 5+4
            if (count === 10) return { cols: 5, rows: 2 }; // 5x2 perfect
            if (count <= 12) return { cols: 4, rows: 3 }; // 4x3 for 11-12
            if (count <= 15) return { cols: 5, rows: 3 };
            if (count <= 18) return { cols: 6, rows: 3 };
            if (count <= 21) return { cols: 7, rows: 3 };
            return { cols: 8, rows: 3 };
        }

        // Generate a dynamic grid icon that matches the actual grid layout
        function generateGridIcon(dimensions) {
            if (!dimensions) return '';
            const [cols, rows] = dimensions.split('Ã—').map(Number);
            const totalCells = cols * rows;
            const cssClass = `grid-${cols}x${rows}`;
            const rects = Array(totalCells).fill('<span class="grid-icon-rect"></span>').join('');
            return `<span class="grid-icon ${cssClass}" title="${dimensions} grid">${rects}</span>`;
        }

        function updateGridNudge() {
            const nudge = document.getElementById('wallViewGridNudge');
            const nudgeText = document.getElementById('wallViewGridNudgeText');
            if (!nudge || !nudgeText) return;

            const wall = document.getElementById('wallViewWall');
            const realCities = wall?.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length || 0;
            const tempCities = wall?.querySelectorAll('.wall-view-frame.temp-city').length || 0;
            const totalCities = realCities + tempCities;
            const labelEl = document.getElementById('wallViewCollectorLabel');
            const collectorName = labelEl?.querySelector('.collector-name-value')?.textContent || labelEl?.dataset.rawName || 'Collector';

            if (totalCities > 0) {
                // Check if this collector has a complete set
                const allTokenIds = wallViewTokenIds || [];
                const energyCounts = { Rising: 0, Living: 0, Fading: 0, Resting: 0 };
                allTokenIds.forEach(id => {
                    const traits = tokenTraits[id];
                    if (traits?.Energy) energyCounts[traits.Energy]++;
                });
                const hasEnergySet = energyCounts.Rising >= 1 && energyCounts.Living >= 1 && energyCounts.Fading >= 1 && energyCounts.Resting >= 1;
                const gridCount = Math.floor(totalCities / 4);

                if (hasEnergySet) {
                    nudgeText.innerHTML = `<span>${collectorName}</span> completed the Energy Set âš¡ï¸ <span class="grid-count">${totalCities}</span> cities`;
                } else if (gridCount >= 1) {
                    nudgeText.innerHTML = `<span>${collectorName}</span> collected a full set ðŸ™ï¸ <span class="grid-count">${totalCities}</span> cities`;
                } else {
                    nudgeText.innerHTML = `<span>${collectorName}</span> is building a set ðŸ™ï¸ <span class="grid-count">${totalCities}</span> cities and counting`;
                }
                nudge.classList.add('ready');
            } else {
                nudge.classList.remove('ready');
            }
        }

        function applyWallZoom() {
            const wrapper = document.getElementById('wallViewWrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${wallPanX}px, ${wallPanY}px) scale(${wallViewZoom})`;
            }
        }


        // Daily Collector Feature - picks a collector with best palette pairing
        function initSpotlight() {
            if (COLLECTORS_DATA.length === 0) return;

            // Filter to collectors with 2+ cities AND have a proper name (not just wallet address)
            // A proper name is either an ENS (.eth) or a display name (not starting with 0x)
            const multiCollectors = COLLECTORS_DATA.filter(c => {
                if (c.count < 2 || !c.tokens || c.tokens.length < 2) return false;
                const name = c.name || '';
                // Exclude if name looks like a wallet address (starts with 0x and is 42+ chars)
                if (name.startsWith('0x') && name.length >= 40) return false;
                // Must have a name
                if (!name || name.trim() === '') return false;
                return true;
            });
            if (multiCollectors.length === 0) return;

            // Use date to deterministically pick today's collector
            const today = new Date();
            const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
            const collector = multiCollectors[dayOfYear % multiCollectors.length];

            if (!collector) return;

            // Find the best palette pairing from their collection
            const tokenPalettes = collector.tokens.map(id => ({
                id,
                palette: tokenTraits[id]?.['Palette']
            })).filter(t => t.palette);

            // Find two cities with different palettes for contrast
            let bestPair = null;
            for (let i = 0; i < tokenPalettes.length; i++) {
                for (let j = i + 1; j < tokenPalettes.length; j++) {
                    if (tokenPalettes[i].palette !== tokenPalettes[j].palette) {
                        bestPair = [tokenPalettes[i], tokenPalettes[j]];
                        break;
                    }
                }
                if (bestPair) break;
            }

            // Fall back to first two if no different palettes
            if (!bestPair && tokenPalettes.length >= 2) {
                bestPair = [tokenPalettes[0], tokenPalettes[1]];
            }

            if (!bestPair) return;

            const featureEl = document.getElementById('collectorFeature');
            const palette1 = PALETTE_DATA[bestPair[0].palette];
            const palette2 = PALETTE_DATA[bestPair[1].palette];

            if (!palette1 || !palette2) return;

            // Get colors for subtle background
            const colors1 = palette1.colors.slice(0, 4);
            const colors2 = palette2.colors.slice(0, 4);

            // Clear any background shapes (keeping background simple black)
            const blendEl = document.getElementById('featurePaletteBlend');
            blendEl.innerHTML = '';

            // Show collector name (prominent)
            const collectorName = collector.name || collector.address.slice(0, 8) + '...';
            document.getElementById('featureCollector').textContent = collectorName;

            // Show cities as horizontal crops with token numbers and palette names underneath each
            document.getElementById('featureCities').innerHTML = bestPair.map((t, idx) => {
                const colors = idx === 0 ? colors1 : colors2;
                return `
                <div class="feature-city-wrapper">
                    <div class="feature-city">
                        <img src="${MEDIA_BASE}/${CONTRACT}/${t.id}.png?width=400" alt="Cities #${t.id}">
                        <span class="feature-city-number">#${t.id}</span>
                    </div>
                    <div class="feature-city-palette">
                        <div class="feature-palette-swatches">
                            ${colors.slice(0, 4).map(c => `<div class="feature-swatch" style="background:${c}"></div>`).join('')}
                        </div>
                        <div class="feature-palette-name">${t.palette}</div>
                    </div>
                </div>
            `}).join('');

            // Clear legacy palette row (now integrated above)
            document.getElementById('featurePalettes').innerHTML = '';

            // Click on expanded content to view collector's wall
            const expandedContent = featureEl.querySelector('.feature-expanded-content');
            if (expandedContent) {
                expandedContent.addEventListener('click', () => {
                    fetchCollectorTokens(collector.name || collector.address);
                    closeCollectorsPanel();
                });
            }

            featureEl.style.display = 'block';
        }

        function createSubtleBlobs(colors1, colors2) {
            // Create very subtle, blurry circular shapes on black background
            const allColors = [colors1[0], colors2[0], colors1[1], colors2[1]].filter(Boolean);
            let blobs = '';

            allColors.forEach((color, i) => {
                const x = 20 + (i * 25) + Math.random() * 10;
                const y = 30 + Math.random() * 40;
                const size = 60 + Math.random() * 40;
                blobs += `<div style="position:absolute;left:${x}%;top:${y}%;width:${size}px;height:${size}px;background:${color};border-radius:50%;"></div>`;
            });

            return blobs;
        }

        function navigateToPrevCollector() {
            if (COLLECTORS_DATA.length === 0) return;
            // Check if we're in wall view or grid collector view
            const wallModal = document.getElementById('wallViewModal');
            const isWallView = wallModal && wallModal.classList.contains('open');

            let currentName = '';
            if (isWallView) {
                const labelEl = document.getElementById('wallViewCollectorLabel');
                currentName = labelEl ? labelEl.dataset.rawName : '';
            } else if (currentCollectorFilter) {
                currentName = currentCollectorFilter.name;
            }

            let currentIdx = COLLECTORS_DATA.findIndex(c => c.name === currentName);
            if (currentIdx === -1) currentIdx = 0;
            const prevIdx = (currentIdx - 1 + COLLECTORS_DATA.length) % COLLECTORS_DATA.length;
            const prevCollector = COLLECTORS_DATA[prevIdx];
            if (prevCollector && prevCollector.tokens && prevCollector.tokens.length > 0) {
                if (isWallView) {
                    openWallView(prevCollector.name, prevCollector.tokens);
                } else {
                    fetchCollectorTokens(prevCollector.name);
                }
            }
        }
        window.navigateToPrevCollector = navigateToPrevCollector;

        function navigateToNextCollector() {
            if (COLLECTORS_DATA.length === 0) return;
            // Check if we're in wall view or grid collector view
            const wallModal = document.getElementById('wallViewModal');
            const isWallView = wallModal && wallModal.classList.contains('open');

            let currentName = '';
            if (isWallView) {
                const labelEl = document.getElementById('wallViewCollectorLabel');
                currentName = labelEl ? labelEl.dataset.rawName : '';
            } else if (currentCollectorFilter) {
                currentName = currentCollectorFilter.name;
            }

            let currentIdx = COLLECTORS_DATA.findIndex(c => c.name === currentName);
            if (currentIdx === -1) currentIdx = 0;
            const nextIdx = (currentIdx + 1) % COLLECTORS_DATA.length;
            const nextCollector = COLLECTORS_DATA[nextIdx];
            if (nextCollector && nextCollector.tokens && nextCollector.tokens.length > 0) {
                if (isWallView) {
                    openWallView(nextCollector.name, nextCollector.tokens);
                } else {
                    fetchCollectorTokens(nextCollector.name);
                }
            }
        }
        window.navigateToNextCollector = navigateToNextCollector;

        // Show options when clicking empty slot in collector wall
        function showEmptySlotOptions(event, slotElement) {
            // Remove any existing dropdown
            const existing = document.querySelector('.empty-slot-dropdown');
            if (existing) existing.remove();

            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'empty-slot-dropdown';
            dropdown.innerHTML = `
                <div class="empty-slot-dropdown-item" data-action="try">
                    <span class="empty-slot-dropdown-icon">ðŸ‘ï¸</span>
                    <div class="empty-slot-dropdown-text">
                        <div class="empty-slot-dropdown-title">Try a City</div>
                        <div class="empty-slot-dropdown-desc">Preview how a City would look here</div>
                    </div>
                </div>
                <div class="empty-slot-dropdown-divider"></div>
                <div class="empty-slot-dropdown-item" data-action="mint">
                    <span class="empty-slot-dropdown-icon">âœ¨</span>
                    <div class="empty-slot-dropdown-text">
                        <div class="empty-slot-dropdown-title">Get a New City</div>
                        <div class="empty-slot-dropdown-desc">On Art Blocks</div>
                    </div>
                </div>
                <div class="empty-slot-dropdown-item" data-action="offer">
                    <span class="empty-slot-dropdown-icon">ðŸ·ï¸</span>
                    <div class="empty-slot-dropdown-text">
                        <div class="empty-slot-dropdown-title">Buy on Marketplace</div>
                        <div class="empty-slot-dropdown-desc">Browse and make an offer on a specific City</div>
                    </div>
                </div>
                <div class="empty-slot-dropdown-item" data-action="bid">
                    <span class="empty-slot-dropdown-icon">ðŸ“‹</span>
                    <div class="empty-slot-dropdown-text">
                        <div class="empty-slot-dropdown-title">Collection Offer</div>
                        <div class="empty-slot-dropdown-desc">Offer on any available City</div>
                    </div>
                </div>
            `;

            // Position dropdown at click location
            const x = event?.clientX || window.innerWidth / 2;
            const y = event?.clientY || window.innerHeight / 2;

            // Adjust position to keep dropdown in viewport
            dropdown.style.left = `${Math.min(x, window.innerWidth - 240)}px`;
            dropdown.style.top = `${Math.min(y, window.innerHeight - 200)}px`;

            document.body.appendChild(dropdown);

            // Handle clicks
            dropdown.querySelectorAll('.empty-slot-dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    dropdown.remove();

                    if (action === 'try') {
                        openTryCityPicker(slotElement);
                    } else if (action === 'mint') {
                        window.open('https://www.artblocks.io/collection/cities-by-efdot-x-diid', '_blank');
                    } else if (action === 'offer') {
                        // Go to collection to browse and make offers on specific cities
                        window.open('https://opensea.io/collection/cities-by-efdot-x-diid', '_blank');
                    } else if (action === 'bid') {
                        // Collection offer page
                        window.open('https://opensea.io/collection/cities-by-efdot-x-diid/offers', '_blank');
                    }
                });
            });

            // Close on click outside
            setTimeout(() => {
                const closeDropdown = (e) => {
                    if (!dropdown.contains(e.target)) {
                        dropdown.remove();
                        document.removeEventListener('click', closeDropdown);
                    }
                };
                document.addEventListener('click', closeDropdown);
            }, 10);
        }

        // Open a picker to try/preview a city in an empty slot
        function openTryCityPicker(slotElement) {
            // Remove any existing picker
            const existingPicker = document.querySelector('.try-city-picker');
            if (existingPicker) existingPicker.remove();

            // Get collector's current traits to determine recommendations
            const collectorTokenIds = wallViewTokenIds || [];
            const collectorTraits = {
                energies: {},
                palettes: {},
                times: {},
                zooms: {},
                traffic: {}
            };
            const allEnergies = ['Rising', 'Living', 'Fading', 'Resting'];

            collectorTokenIds.forEach(id => {
                const traits = tokenTraits[id];
                if (!traits) return;
                if (traits['Energy']) collectorTraits.energies[traits['Energy']] = (collectorTraits.energies[traits['Energy']] || 0) + 1;
                if (traits['Palette']) collectorTraits.palettes[traits['Palette']] = (collectorTraits.palettes[traits['Palette']] || 0) + 1;
                if (traits['Time']) collectorTraits.times[traits['Time']] = (collectorTraits.times[traits['Time']] || 0) + 1;
                if (traits['Zoom']) collectorTraits.zooms[traits['Zoom']] = (collectorTraits.zooms[traits['Zoom']] || 0) + 1;
                if (traits['Traffic']) collectorTraits.traffic[traits['Traffic']] = (collectorTraits.traffic[traits['Traffic']] || 0) + 1;
            });

            // Determine recommended energies
            const recommendedEnergies = [];
            const missingEnergies = allEnergies.filter(e => !collectorTraits.energies[e]);
            const duplicateEnergy = Object.entries(collectorTraits.energies).find(([e, count]) => count >= 2);
            if (duplicateEnergy) recommendedEnergies.push(duplicateEnergy[0]);
            missingEnergies.forEach(e => { if (!recommendedEnergies.includes(e)) recommendedEnergies.push(e); });

            // Get dominant traits for smart suggestions
            const dominantPalette = Object.entries(collectorTraits.palettes).sort((a, b) => b[1] - a[1])[0]?.[0];
            const dominantTime = Object.entries(collectorTraits.times).sort((a, b) => b[1] - a[1])[0]?.[0];
            const dominantZoom = Object.entries(collectorTraits.zooms).sort((a, b) => b[1] - a[1])[0]?.[0];

            // Create picker modal
            const picker = document.createElement('div');
            picker.className = 'try-city-picker';
            picker.innerHTML = `
                <div class="try-city-picker-content">
                    <div class="try-city-picker-header">
                        <span class="try-city-picker-title">Preview a City</span>
                        <button class="try-city-picker-close">&times;</button>
                    </div>
                    <div class="try-city-picker-input-row">
                        <input type="number" class="try-city-picker-input" placeholder="Enter City #" min="0" max="499">
                        <button class="try-city-picker-add">Add</button>
                    </div>
                    <div class="try-city-picker-preview"></div>
                    <div class="try-city-picker-tabs">
                        <button class="try-city-picker-tab active" data-tab="smart">Smart</button>
                        <button class="try-city-picker-tab" data-tab="energy">Energy</button>
                        <button class="try-city-picker-tab" data-tab="palette">Palette</button>
                        <button class="try-city-picker-tab" data-tab="rarity">Rarity</button>
                    </div>
                    <div class="try-city-picker-tab-content active" data-tab="smart">
                        <div class="try-city-picker-smart-suggestions"></div>
                    </div>
                    <div class="try-city-picker-tab-content" data-tab="energy">
                        <div class="try-city-picker-energy-filters">
                            <button class="try-city-picker-energy-btn active" data-energy="all">All</button>
                            ${allEnergies.map(e => `<button class="try-city-picker-energy-btn${recommendedEnergies.includes(e) ? ' recommended' : ''}" data-energy="${e}">${e}</button>`).join('')}
                        </div>
                        <div class="try-city-picker-suggestions">
                            <div class="try-city-picker-quick"></div>
                        </div>
                    </div>
                    <div class="try-city-picker-tab-content" data-tab="palette">
                        <div class="try-city-picker-suggestions">
                            <div class="try-city-picker-palette-picks"></div>
                        </div>
                    </div>
                    <div class="try-city-picker-tab-content" data-tab="rarity">
                        <div class="try-city-picker-suggestions">
                            <div class="try-city-picker-rarity-picks"></div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(picker);

            const input = picker.querySelector('.try-city-picker-input');
            const preview = picker.querySelector('.try-city-picker-preview');
            const addBtn = picker.querySelector('.try-city-picker-add');
            const closeBtn = picker.querySelector('.try-city-picker-close');
            const quickPicks = picker.querySelector('.try-city-picker-quick');
            const energyBtns = picker.querySelectorAll('.try-city-picker-energy-btn');

            // Get minted cities list from tokenTraits (the source of truth)
            const mintedList = Object.keys(tokenTraits).map(Number).filter(id => !PROJECT_WALLET_TOKENS.has(id));

            // Function to populate suggestions based on energy filter
            function populateSuggestions(energyFilter = 'all') {
                quickPicks.innerHTML = '';

                // Get favorites first
                const favs = JSON.parse(localStorage.getItem('cities-favorites') || '[]');
                let favIds = favs.map(f => f.tokenId);

                // Filter by energy if needed
                if (energyFilter !== 'all') {
                    favIds = favIds.filter(id => {
                        const traits = tokenTraits[id];
                        return traits && traits['Energy'] === energyFilter;
                    });
                }
                favIds = favIds.slice(0, 4);

                // Get random minted cities matching the energy filter
                const randomMinted = [];
                const usedIds = new Set(favIds);
                const shuffled = [...mintedList].sort(() => Math.random() - 0.5);

                for (const id of shuffled) {
                    if (usedIds.has(id)) continue;
                    if (energyFilter !== 'all') {
                        const traits = tokenTraits[id];
                        if (!traits || traits['Energy'] !== energyFilter) continue;
                    }
                    randomMinted.push(id);
                    usedIds.add(id);
                    if (randomMinted.length >= (8 - favIds.length)) break;
                }

                // Combine and display
                const suggestions = [...favIds, ...randomMinted].slice(0, 8);

                if (suggestions.length === 0) {
                    quickPicks.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">No cities found with this energy</div>';
                    return;
                }

                suggestions.forEach(id => {
                    const thumb = document.createElement('div');
                    thumb.className = 'try-city-picker-thumb';
                    thumb.innerHTML = `<img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}">`;
                    thumb.addEventListener('click', () => {
                        addTempCity(id, slotElement);
                        picker.remove();
                    });
                    quickPicks.appendChild(thumb);
                });
            }

            // Tab switching
            const tabs = picker.querySelectorAll('.try-city-picker-tab');
            const tabContents = picker.querySelectorAll('.try-city-picker-tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    tab.classList.add('active');
                    picker.querySelector(`.try-city-picker-tab-content[data-tab="${tab.dataset.tab}"]`)?.classList.add('active');
                });
            });

            // Populate Smart suggestions
            function populateSmartSuggestions() {
                const smartContainer = picker.querySelector('.try-city-picker-smart-suggestions');
                if (!smartContainer) return;

                const ownedIds = new Set(collectorTokenIds.map(Number));
                let html = '';

                // 1. Same palette suggestions
                if (dominantPalette) {
                    const samePalette = mintedList.filter(id => {
                        if (ownedIds.has(id)) return false;
                        const traits = tokenTraits[id];
                        return traits && traits['Palette'] === dominantPalette;
                    }).slice(0, 4);

                    if (samePalette.length > 0) {
                        html += `<div class="try-city-picker-smart-row">
                            <div class="try-city-picker-smart-label"><span class="label-icon">â—†</span> Same palette (${dominantPalette})</div>
                            <div class="try-city-picker-smart-cities">${samePalette.map(id =>
                                `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                            ).join('')}</div>
                        </div>`;
                    }
                }

                // 2. Complete Energy Set
                if (missingEnergies.length > 0 && missingEnergies.length < 4) {
                    const energySuggestions = [];
                    for (const energy of missingEnergies) {
                        const match = mintedList.find(id => {
                            if (ownedIds.has(id)) return false;
                            const traits = tokenTraits[id];
                            return traits && traits['Energy'] === energy;
                        });
                        if (match) energySuggestions.push({ id: match, energy });
                    }

                    if (energySuggestions.length > 0) {
                        html += `<div class="try-city-picker-smart-row">
                            <div class="try-city-picker-smart-label"><span class="label-icon">âœ¦</span> Complete Energy Set (need ${missingEnergies.join(', ')})</div>
                            <div class="try-city-picker-smart-cities">${energySuggestions.map(s =>
                                `<div class="try-city-picker-thumb" data-id="${s.id}" title="${s.energy}"><img src="${MEDIA_BASE}/${CONTRACT}/${s.id}.png?width=120" alt="#${s.id}"></div>`
                            ).join('')}</div>
                        </div>`;
                    }
                }

                // 3. Same time of day
                if (dominantTime) {
                    const sameTime = mintedList.filter(id => {
                        if (ownedIds.has(id)) return false;
                        const traits = tokenTraits[id];
                        return traits && traits['Time'] === dominantTime;
                    }).sort(() => Math.random() - 0.5).slice(0, 4);

                    if (sameTime.length > 0) {
                        html += `<div class="try-city-picker-smart-row">
                            <div class="try-city-picker-smart-label"><span class="label-icon">â˜€</span> Same time (${dominantTime})</div>
                            <div class="try-city-picker-smart-cities">${sameTime.map(id =>
                                `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                            ).join('')}</div>
                        </div>`;
                    }
                }

                // 4. Same zoom level
                if (dominantZoom) {
                    const sameZoom = mintedList.filter(id => {
                        if (ownedIds.has(id)) return false;
                        const traits = tokenTraits[id];
                        return traits && traits['Zoom'] === dominantZoom;
                    }).sort(() => Math.random() - 0.5).slice(0, 4);

                    if (sameZoom.length > 0) {
                        html += `<div class="try-city-picker-smart-row">
                            <div class="try-city-picker-smart-label"><span class="label-icon">â—Ž</span> Same zoom (${dominantZoom})</div>
                            <div class="try-city-picker-smart-cities">${sameZoom.map(id =>
                                `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                            ).join('')}</div>
                        </div>`;
                    }
                }

                // Fallback: show random picks if no smart suggestions
                if (!html) {
                    const randomPicks = mintedList.filter(id => !ownedIds.has(id)).sort(() => Math.random() - 0.5).slice(0, 8);
                    if (randomPicks.length > 0) {
                        html = `<div class="try-city-picker-smart-row">
                            <div class="try-city-picker-smart-label"><span class="label-icon">âœ¦</span> Discover cities</div>
                            <div class="try-city-picker-smart-cities">${randomPicks.map(id =>
                                `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                            ).join('')}</div>
                        </div>`;
                    } else {
                        html = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">No suggestions available</div>';
                    }
                }

                smartContainer.innerHTML = html;

                // Add click handlers
                smartContainer.querySelectorAll('.try-city-picker-thumb').forEach(thumb => {
                    thumb.addEventListener('click', () => {
                        addTempCity(parseInt(thumb.dataset.id), slotElement);
                        picker.remove();
                    });
                });
            }

            // Populate Palette tab
            function populatePalettePicks() {
                const container = picker.querySelector('.try-city-picker-palette-picks');
                if (!container) return;

                const ownedIds = new Set(collectorTokenIds.map(Number));
                const ownedPalettes = Object.keys(collectorTraits.palettes);

                // Show cities from palettes the collector already has
                let suggestions = [];
                for (const palette of ownedPalettes) {
                    const matches = mintedList.filter(id => {
                        if (ownedIds.has(id)) return false;
                        const traits = tokenTraits[id];
                        return traits && traits['Palette'] === palette;
                    }).slice(0, 2);
                    suggestions.push(...matches);
                }
                suggestions = suggestions.slice(0, 8);

                // Fallback: show random cities if no palette matches
                if (suggestions.length === 0) {
                    suggestions = mintedList.filter(id => !ownedIds.has(id)).sort(() => Math.random() - 0.5).slice(0, 8);
                }

                if (suggestions.length === 0) {
                    container.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">No cities available</div>';
                    return;
                }

                container.innerHTML = `<div class="try-city-picker-quick">${suggestions.map(id =>
                    `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                ).join('')}</div>`;

                container.querySelectorAll('.try-city-picker-thumb').forEach(thumb => {
                    thumb.addEventListener('click', () => {
                        addTempCity(parseInt(thumb.dataset.id), slotElement);
                        picker.remove();
                    });
                });
            }

            // Populate Rarity tab (rare traits)
            function populateRarityPicks() {
                const container = picker.querySelector('.try-city-picker-rarity-picks');
                if (!container) return;

                const ownedIds = new Set(collectorTokenIds.map(Number));

                // Find cities with rare traits (Rush Hour traffic, Water feature, etc.)
                const rareCities = mintedList.filter(id => {
                    if (ownedIds.has(id)) return false;
                    const traits = tokenTraits[id];
                    if (!traits) return false;
                    return traits['Traffic'] === 'Rush Hour' || traits['Water'] === 'Yes';
                }).sort(() => Math.random() - 0.5).slice(0, 8);

                if (rareCities.length === 0) {
                    container.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">No rare cities available</div>';
                    return;
                }

                container.innerHTML = `<div class="try-city-picker-section-label">Rush Hour & Water Features</div>
                    <div class="try-city-picker-quick">${rareCities.map(id =>
                    `<div class="try-city-picker-thumb" data-id="${id}"><img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=120" alt="#${id}"></div>`
                ).join('')}</div>`;

                container.querySelectorAll('.try-city-picker-thumb').forEach(thumb => {
                    thumb.addEventListener('click', () => {
                        addTempCity(parseInt(thumb.dataset.id), slotElement);
                        picker.remove();
                    });
                });
            }

            // Initial population of all tabs
            try {
                populateSmartSuggestions();
            } catch (e) {
                console.error('Smart suggestions error:', e);
                picker.querySelector('.try-city-picker-smart-suggestions').innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">Loading suggestions...</div>';
            }
            try {
                populateSuggestions('all');
            } catch (e) { console.error('Energy suggestions error:', e); }
            try {
                populatePalettePicks();
            } catch (e) { console.error('Palette picks error:', e); }
            try {
                populateRarityPicks();
            } catch (e) { console.error('Rarity picks error:', e); }

            // Energy filter buttons
            energyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    energyBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    populateSuggestions(btn.dataset.energy);
                });
            });

            // Preview on input change - only show if minted
            input.addEventListener('input', () => {
                const id = parseInt(input.value);
                if (!isNaN(id) && mintedList.includes(id)) {
                    preview.innerHTML = `<img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=200" alt="#${id}">`;
                } else if (!isNaN(id) && id >= 0 && id <= 499) {
                    preview.innerHTML = `<div style="color: #666; font-size: 11px; text-align: center;">City #${id} not yet minted</div>`;
                } else {
                    preview.innerHTML = '';
                }
            });

            // Add button - only if minted
            addBtn.addEventListener('click', () => {
                const id = parseInt(input.value);
                if (!isNaN(id) && mintedList.includes(id)) {
                    addTempCity(id, slotElement);
                    picker.remove();
                } else if (!isNaN(id) && id >= 0 && id <= 499) {
                    preview.innerHTML = `<div style="color: #c9a227; font-size: 11px; text-align: center;">City #${id} not yet minted</div>`;
                }
            });

            // Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    addBtn.click();
                }
            });

            // Close button
            closeBtn.addEventListener('click', () => picker.remove());

            // Click outside to close
            picker.addEventListener('click', (e) => {
                if (e.target === picker) picker.remove();
            });

            // Focus input
            setTimeout(() => input.focus(), 100);
        }

        // Helper to add a TRY mode empty slot
        function addTryModeSlot(wall) {
            const artwork = document.createElement('div');
            artwork.className = 'wall-view-artwork try-mode-slot';

            const frame = document.createElement('div');
            frame.className = 'wall-view-frame empty-slot';

            const emptyFrame = document.createElement('div');
            emptyFrame.className = 'wall-view-empty-frame';
            emptyFrame.innerHTML = '<span class="slot-plus">+</span><span class="slot-label"><span class="slot-grid-icon">â–¦</span> try</span>';
            emptyFrame.addEventListener('click', (e) => {
                e.stopPropagation();
                showEmptySlotOptions(e, artwork);
            });

            frame.appendChild(emptyFrame);
            artwork.appendChild(frame);
            wall.appendChild(artwork);
        }

        // Add a temporary city to the wall for preview
        function addTempCity(tokenId, slotElement) {
            const wall = document.getElementById('wallViewWall');
            if (!wall) return;

            // If no slot element provided, find an available empty slot
            if (!slotElement) {
                const emptySlot = wall.querySelector('.wall-view-artwork.try-mode-slot .wall-view-frame.empty-slot');
                if (emptySlot) {
                    slotElement = emptySlot.closest('.wall-view-artwork');
                }
            }

            // For small collections without a slot, expand grid to accommodate the new piece
            if (!slotElement) {
                const realCities = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
                const tempCities = wall.querySelectorAll('.wall-view-frame.temp-city').length;
                const totalAfter = realCities + tempCities + 1;
                const newLayout = getOptimalGridLayout(totalAfter);
                wall.className = wall.className.replace(/cols-\d+/, '');
                wall.classList.add(`cols-${newLayout.cols}`);
            }

            // Get palette colors for this city
            const traits = tokenTraits[tokenId];
            let badgeBg = '#c9a227';
            let badgeText = '#000';

            if (traits && traits['Palette'] && PALETTE_DATA[traits['Palette']]) {
                const colors = PALETTE_DATA[traits['Palette']].colors;
                // Use a bold color from the palette
                badgeBg = colors[1] || colors[0];
                // Calculate contrast for text color
                const hex = badgeBg.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                badgeText = luminance > 0.5 ? '#000' : '#fff';
            }

            // Create the temp city frame
            const artwork = document.createElement('div');
            artwork.className = 'wall-view-artwork';

            const frame = document.createElement('div');
            frame.className = 'wall-view-frame temp-city';
            frame.dataset.tokenId = tokenId;
            frame.dataset.isTemp = 'true';
            frame.style.setProperty('--badge-bg', badgeBg);
            frame.style.setProperty('--badge-text', badgeText);

            const mat = document.createElement('div');
            mat.className = 'wall-view-frame-mat';

            const inner = document.createElement('div');
            inner.className = 'wall-view-frame-inner';

            const frameImg = document.createElement('img');
            frameImg.src = `${MEDIA_BASE}/${CONTRACT}/${tokenId}.png`;
            frameImg.alt = `City #${tokenId} (Preview)`;

            // TRY badge
            const badge = document.createElement('div');
            badge.className = 'temp-city-badge';
            badge.textContent = 'TRY';

            // Action buttons (show on hover)
            const actions = document.createElement('div');
            actions.className = 'temp-city-actions';

            const offerBtn = document.createElement('button');
            offerBtn.className = 'temp-city-action offer';
            offerBtn.textContent = 'Make Offer';
            offerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                window.open(`https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}`, '_blank');
            });

            const swapBtn = document.createElement('button');
            swapBtn.className = 'temp-city-action';
            swapBtn.textContent = 'Try Another';
            swapBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Replace: remove this city, add a try slot in its place, open picker
                const wall = document.getElementById('wallViewWall');
                const parentArtwork = artwork;
                removeTempCity(tokenId, parentArtwork);
                // Add a new try slot and open the picker
                if (wall) {
                    wallViewTryMode = true;
                    document.getElementById('wallViewTryMode')?.classList.add('active');
                    addTryModeSlot(wall);
                    const rc = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
                    const tc = wall.querySelectorAll('.wall-view-frame.temp-city').length;
                    const newL = getOptimalGridLayout(rc + tc + 1);
                    wall.className = wall.className.replace(/cols-\d+/, '');
                    wall.classList.add(`cols-${newL.cols}`);
                    document.getElementById('wallViewModal')?.classList.add('has-empty-slots');
                    const slot = wall.querySelector('.wall-view-artwork.try-mode-slot');
                    if (slot) setTimeout(() => openTryCityPicker(slot), 150);
                }
            });

            actions.appendChild(offerBtn);
            actions.appendChild(swapBtn);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'temp-city-remove';
            removeBtn.innerHTML = 'Ã—';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeTempCity(tokenId, artwork);
            });

            inner.appendChild(frameImg);
            mat.appendChild(inner);
            frame.appendChild(mat);
            frame.appendChild(badge);
            frame.appendChild(actions);
            frame.appendChild(removeBtn);

            const label = document.createElement('div');
            label.className = 'wall-view-artwork-label';
            label.textContent = `#${tokenId}`;

            artwork.appendChild(frame);
            artwork.appendChild(label);

            // Remove any existing try-add-more button from previous temp cities
            wall.querySelectorAll('.try-add-more').forEach(btn => btn.remove());

            // Add inline "+" button to this artwork for quick try-another
            const addMoreBtn = document.createElement('button');
            addMoreBtn.className = 'try-add-more';
            addMoreBtn.innerHTML = '+';
            addMoreBtn.title = 'Try another city';
            addMoreBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Activate try mode and add one empty slot
                wallViewTryMode = true;
                const tryBtn = document.getElementById('wallViewTryMode');
                tryBtn?.classList.add('active');
                addTryModeSlot(wall);
                const rc = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
                const tc = wall.querySelectorAll('.wall-view-frame.temp-city').length;
                const newL = getOptimalGridLayout(rc + tc + 1);
                wall.className = wall.className.replace(/cols-\d+/, '');
                wall.classList.add(`cols-${newL.cols}`);
                document.getElementById('wallViewModal')?.classList.add('has-empty-slots');
                addMoreBtn.remove();
                updateGridNudge();
            });
            artwork.appendChild(addMoreBtn);

            // Replace the empty slot or add to the wall
            if (slotElement && slotElement.parentNode) {
                slotElement.parentNode.replaceChild(artwork, slotElement);
            } else {
                wall.appendChild(artwork);
            }

            // Track temp city
            wallViewTempCities.push(tokenId);
            saveTryCities(getCurrentWallCollector(), wallViewTempCities);

            // Deactivate try mode after placing a city â€” clean grid, no lingering slots
            wallViewTryMode = false;
            document.getElementById('wallViewTryMode')?.classList.remove('active');
            document.getElementById('wallViewModal')?.classList.remove('has-empty-slots');

            // Recalculate grid to snap to the right layout
            const realCount = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
            const tempCount = wall.querySelectorAll('.wall-view-frame.temp-city').length;
            const newLayout = getOptimalGridLayout(realCount + tempCount);
            wall.className = wall.className.replace(/cols-\d+/, '');
            wall.classList.add(`cols-${newLayout.cols}`);

            // Update grid nudge
            updateGridNudge();
        }

        // Remove a temporary city from the wall
        function removeTempCity(tokenId, artworkElement) {
            const wall = document.getElementById('wallViewWall');
            if (!wall || !artworkElement) return;

            // Simply remove the temp city and recalculate grid
            artworkElement.remove();

            // Remove from tracking
            wallViewTempCities = wallViewTempCities.filter(id => id !== tokenId);
            saveTryCities(getCurrentWallCollector(), wallViewTempCities);

            // Recalculate grid to snap to clean layout
            const realCities = wall.querySelectorAll('.wall-view-frame:not(.empty-slot):not(.temp-city)').length;
            const tempCities = wall.querySelectorAll('.wall-view-frame.temp-city').length;
            const newLayout = getOptimalGridLayout(realCities + tempCities);
            wall.className = wall.className.replace(/cols-\d+/, '');
            wall.classList.add(`cols-${newLayout.cols}`);

            // Update grid nudge
            updateGridNudge();
        }

        function openWallView(collectorName, tokenIds) {
            const name = collectorName || document.getElementById('collectorBannerName').textContent;
            const displayName = formatCollectorName(name);

            const wall = document.getElementById('wallViewWall');
            wall.innerHTML = '';
            wallViewZoom = 1;
            wallPanX = 0;
            wallPanY = 0;

            // Recreate collector info (was destroyed by innerHTML clear)
            const collectorInfo = document.createElement('div');
            collectorInfo.className = 'wall-view-collector-info';
            collectorInfo.id = 'wallViewCollectorInfo';
            const collectorLabel = document.createElement('div');
            collectorLabel.className = 'wall-view-collector-name';
            collectorLabel.id = 'wallViewCollectorLabel';
            collectorLabel.innerHTML = `<span class="collector-label">CITIES COLLECTED BY</span> <span class="collector-name-value">${displayName}</span>`;
            collectorLabel.dataset.rawName = name;
            collectorLabel.onclick = () => {
                closeWallView();
            };
            collectorInfo.appendChild(collectorLabel);
            wall.appendChild(collectorInfo);

            // Get the cities
            const items = tokenIds
                ? tokenIds.map(id => ({ id, src: `${MEDIA_BASE}/${CONTRACT}/${id}.png` }))
                : Array.from(document.querySelectorAll('.grid-item')).map(item => ({
                    id: item.dataset.tokenId,
                    src: item.querySelector('img').src
                }));

            // Apply saved wall order if available
            const savedOrder = getSavedWallOrder(name);
            if (savedOrder && savedOrder.length > 0) {
                const itemMap = {};
                items.forEach(item => { itemMap[item.id] = item; });
                const reordered = [];
                savedOrder.forEach(id => {
                    if (itemMap[id]) {
                        reordered.push(itemMap[id]);
                        delete itemMap[id];
                    }
                });
                // Append any new items not in saved order
                Object.values(itemMap).forEach(item => reordered.push(item));
                items.length = 0;
                reordered.forEach(item => items.push(item));
            }

            wallViewTokenIds = items.map(item => item.id);
            const count = items.length;

            // Find collector data
            const collector = COLLECTORS_DATA.find(c => c.name === name || c.address === name);

            // Calculate optimal grid layout - show only owned pieces, no empty placeholders
            wall.className = 'wall-view-wall';
            const layout = getOptimalGridLayout(count);
            wall.classList.add(`cols-${layout.cols}`);

            // Get accent color from first city's palette
            const firstTokenTraits = tokenTraits[items[0]?.id];
            if (firstTokenTraits && firstTokenTraits['Palette'] && PALETTE_DATA[firstTokenTraits['Palette']]) {
                const paletteColors = PALETTE_DATA[firstTokenTraits['Palette']].colors;
                currentWallAccentColor = paletteColors[1] || paletteColors[0];
            }

            // Add the cities with thumbnail loading
            items.forEach((item, index) => {
                const artwork = document.createElement('div');
                artwork.className = 'wall-view-artwork';

                const frame = document.createElement('div');
                frame.className = 'wall-view-frame';
                frame.dataset.tokenId = item.id;
                frame.dataset.index = index;

                const mat = document.createElement('div');
                mat.className = 'wall-view-frame-mat';

                const inner = document.createElement('div');
                inner.className = 'wall-view-frame-inner';

                // Use thumbnail first, then load full size
                const frameImg = document.createElement('img');
                frameImg.src = `${MEDIA_BASE}/${CONTRACT}/${item.id}.png?width=200`;
                frameImg.alt = `City #${item.id}`;
                frameImg.style.transition = 'opacity 0.3s ease';

                // Load full resolution after thumbnail
                const fullImg = new Image();
                fullImg.onload = () => {
                    frameImg.src = fullImg.src;
                };
                fullImg.src = `${MEDIA_BASE}/${CONTRACT}/${item.id}.png`;

                // Click frame to open framed mockup view (skip if drag-swapping)
                frame.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isDragSwapping) return;
                    const tokenId = parseInt(frame.dataset.tokenId);
                    openFrameMockup(tokenId, name);
                });

                inner.appendChild(frameImg);
                mat.appendChild(inner);
                frame.appendChild(mat);

                // Add label under frame with token number
                const label = document.createElement('div');
                label.className = 'wall-view-artwork-label';
                label.textContent = `#${item.id}`;

                artwork.appendChild(frame);
                artwork.appendChild(label);
                wall.appendChild(artwork);
            });

            // No empty placeholder slots on initial load - only show owned pieces
            // Empty slots appear only when TRY mode is activated
            const modal = document.getElementById('wallViewModal');
            modal.classList.remove('has-empty-slots');

            // Set up lighting effect
            const lightingEl = document.getElementById('wallViewLightingEffect');
            lightingEl.style.background = `radial-gradient(ellipse at 50% 30%, ${currentWallAccentColor}15 0%, transparent 60%)`;

            // Start in dark mode as default
            modal.classList.remove('wall-black', 'wall-gray');
            modal.classList.add('wall-black');
            currentWallColor = 'black';

            // Check if this is "The Lost Cities" for haunted effect
            const isHaunted = name && name.toLowerCase().includes('lost cities');
            modal.classList.remove('haunted-active');
            if (window.hauntedTimer) clearTimeout(window.hauntedTimer);

            if (isHaunted) {
                window.hauntedTimer = setTimeout(() => {
                    if (modal.classList.contains('wall-black') && modal.classList.contains('open')) {
                        modal.classList.add('haunted-active');
                    }
                }, 15000);
            }

            // Reset zoom - auto-fit for larger collections
            wallViewZoom = 1;
            wallPanX = 0;
            wallPanY = 0;
            const wrapper = document.getElementById('wallViewWrapper');

            // Auto zoom out based on grid size to ensure collections fit without cropping
            // Wider grids (more cols) need more zoom-out; fewer rows = more visible
            if (layout.rows >= 3 && layout.cols >= 7) {
                wallViewZoom = 0.55;
            } else if (layout.rows >= 3) {
                wallViewZoom = 0.6;
            } else if (layout.rows >= 2 && layout.cols >= 5) {
                // 2-row wide grids (9-10 cities) - zoom out enough to see all
                wallViewZoom = 0.65;
            } else if (count === 4) {
                // 2x2 grid
                wallViewZoom = 0.72;
            } else if (layout.rows >= 2) {
                // Other 2-row grids (5-8 cities)
                wallViewZoom = 0.7;
            } else if (count === 2) {
                wallViewZoom = 0.75;
            } else if (count <= 3) {
                wallViewZoom = 0.8;
            }
            if (wrapper) wrapper.style.transform = `translate(${wallPanX}px, ${wallPanY}px) scale(${wallViewZoom})`;

            // Reset try mode
            wallViewTryMode = false;
            wallViewTempCities = [];
            document.getElementById('wallViewTryMode')?.classList.remove('active');

            // Reset layout toggle
            wideLayoutMode = false;
            document.getElementById('wallViewLayoutToggle')?.classList.remove('active');
            // Show layout toggle for collections with 3+ rows
            if (layout.rows >= 3) {
                modal.classList.add('show-layout-toggle');
            } else {
                modal.classList.remove('show-layout-toggle');
            }

            // Reset to grid view (not line view) - button shows current state "GRID"
            modal.classList.remove('line-view');
            const lineBtn = document.getElementById('wallViewHideEmpty');
            if (lineBtn) {
                lineBtn.classList.remove('active');
                lineBtn.innerHTML = '<span class="line-icon">âŠž</span> GRID';
            }

            modal.classList.add('open');
            document.body.style.overflow = 'hidden';

            // Restore saved try cities (48-hour persistence)
            const savedTryCities = getSavedTryCities(name);
            if (savedTryCities && savedTryCities.length > 0) {
                savedTryCities.forEach(tryTokenId => {
                    // Don't add if this city is already owned by this collector
                    if (items.some(item => String(item.id) === String(tryTokenId))) return;
                    addTempCity(tryTokenId, null);
                });
                // Recalculate zoom for the expanded grid
                const totalWithTry = count + wallViewTempCities.length;
                const tryLayout = getOptimalGridLayout(totalWithTry);
                if (tryLayout.rows >= 3 && tryLayout.cols >= 7) wallViewZoom = 0.55;
                else if (tryLayout.rows >= 3) wallViewZoom = 0.6;
                else if (tryLayout.rows >= 2 && tryLayout.cols >= 5) wallViewZoom = 0.65;
                else if (totalWithTry === 4) wallViewZoom = 0.72;
                else if (tryLayout.rows >= 2) wallViewZoom = 0.7;
                if (wrapper) wrapper.style.transform = `translate(${wallPanX}px, ${wallPanY}px) scale(${wallViewZoom})`;
            }

            // Update grid nudge after modal opens
            setTimeout(updateGridNudge, 100);

            // Show city detail hover tooltip for all collectors
            setTimeout(() => showWallViewCityDetail(items), 150);

            // Show suggestions for small collectors (1-3 cities)
            setTimeout(() => showCollectorSuggestions(items, collector), 200);
        }
        // Expose openWallView globally and set the forward reference
        window.openWallView = openWallView;
        openWallViewFn = openWallView;

        // Dream Grid â€” build a collection from scratch using try mode
        function openDreamGrid() {
            const DREAM_KEY = '__dream__';
            const wall = document.getElementById('wallViewWall');
            wall.innerHTML = '';
            wallViewZoom = 1;
            wallPanX = 0;
            wallPanY = 0;

            // Collector info
            const collectorInfo = document.createElement('div');
            collectorInfo.className = 'wall-view-collector-info';
            collectorInfo.id = 'wallViewCollectorInfo';
            const collectorLabel = document.createElement('div');
            collectorLabel.className = 'wall-view-collector-name';
            collectorLabel.id = 'wallViewCollectorLabel';
            collectorLabel.innerHTML = '<span class="collector-label">YOUR</span> <span class="collector-name-value">Dream Collection</span>';
            collectorLabel.dataset.rawName = DREAM_KEY;
            collectorInfo.appendChild(collectorLabel);
            wall.appendChild(collectorInfo);

            wallViewTokenIds = [];
            wall.className = 'wall-view-wall cols-2';

            const modal = document.getElementById('wallViewModal');
            modal.classList.remove('has-empty-slots', 'wall-gray', 'line-view', 'show-layout-toggle', 'haunted-active');
            modal.classList.add('wall-black');
            currentWallColor = 'black';

            // Lighting
            const lightingEl = document.getElementById('wallViewLightingEffect');
            if (lightingEl) lightingEl.style.background = 'radial-gradient(ellipse at 50% 30%, rgba(201,162,39,0.08) 0%, transparent 60%)';

            // Reset try mode / layout
            wallViewTryMode = false;
            wallViewTempCities = [];
            isDragSwapping = false;
            wideLayoutMode = false;
            document.getElementById('wallViewTryMode')?.classList.remove('active');
            document.getElementById('wallViewLayoutToggle')?.classList.remove('active');
            modal.classList.remove('line-view');
            const lineBtn = document.getElementById('wallViewHideEmpty');
            if (lineBtn) { lineBtn.classList.remove('active'); lineBtn.innerHTML = '<span class="line-icon">âŠž</span> GRID'; }

            // Zoom
            wallViewZoom = 0.8;
            const wrapper = document.getElementById('wallViewWrapper');
            if (wrapper) wrapper.style.transform = `translate(0px, 0px) scale(${wallViewZoom})`;

            modal.classList.add('open');
            document.body.style.overflow = 'hidden';

            // Restore saved dream cities (48-hour persistence)
            const savedDream = getSavedTryCities(DREAM_KEY);
            if (savedDream && savedDream.length > 0) {
                savedDream.forEach(tryTokenId => addTempCity(tryTokenId, null));
                // Recalculate zoom for restored dream grid
                const dreamLayout = getOptimalGridLayout(wallViewTempCities.length);
                if (dreamLayout.rows >= 3 && dreamLayout.cols >= 7) wallViewZoom = 0.55;
                else if (dreamLayout.rows >= 3) wallViewZoom = 0.6;
                else if (dreamLayout.rows >= 2 && dreamLayout.cols >= 5) wallViewZoom = 0.65;
                else if (wallViewTempCities.length === 4) wallViewZoom = 0.72;
                else if (dreamLayout.rows >= 2) wallViewZoom = 0.7;
                if (wrapper) wrapper.style.transform = `translate(0px, 0px) scale(${wallViewZoom})`;
            }

            // If grid is empty, immediately add a try slot and open picker
            if (wallViewTempCities.length === 0) {
                wallViewTryMode = true;
                document.getElementById('wallViewTryMode')?.classList.add('active');
                addTryModeSlot(wall);
                modal.classList.add('has-empty-slots');
                // Auto-open the picker after a beat
                setTimeout(() => {
                    const slot = wall.querySelector('.wall-view-artwork.try-mode-slot');
                    if (slot) openTryCityPicker(slot);
                }, 400);
            }

            setTimeout(updateGridNudge, 100);
        }
        window.openDreamGrid = openDreamGrid;

        // Wall button handler - opens wall view for current collector
        function handleWallButtonClick() {
            try {
                let tokens = null;
                let collectorName = null;

                // 1. Try wall button data attributes (most reliable, set by showCollectorInGrid)
                const wallBtn = document.getElementById('collectorWallView');
                if (wallBtn && wallBtn.dataset.tokens && wallBtn.dataset.collector) {
                    const parsed = wallBtn.dataset.tokens.split(',').map(id => parseInt(id)).filter(id => !isNaN(id));
                    if (parsed.length > 0) {
                        tokens = parsed;
                        collectorName = wallBtn.dataset.collector;
                    }
                }

                // 2. Try currentCollectorFilter
                if (!tokens && currentCollectorFilter && currentCollectorFilter.tokens && currentCollectorFilter.tokens.length > 0) {
                    tokens = currentCollectorFilter.tokens;
                    collectorName = currentCollectorFilter.name;
                }

                // 3. Try banner name â†’ COLLECTORS_DATA lookup
                if (!tokens) {
                    const rawName = document.getElementById('collectorBannerName')?.textContent?.replace(/\.{3}$/, '');
                    if (rawName) {
                        const collector = COLLECTORS_DATA.find(c => c.name === rawName || c.name.toLowerCase() === rawName.toLowerCase());
                        if (collector && collector.tokens && collector.tokens.length > 0) {
                            tokens = collector.tokens;
                            collectorName = collector.name;
                        }
                    }
                }

                // 4. Try sessionStorage
                if (!tokens) {
                    try {
                        const saved = sessionStorage.getItem('cities-gallery-context');
                        if (saved) {
                            const ctx = JSON.parse(saved);
                            if (ctx && ctx.tokens && ctx.tokens.length > 0) {
                                tokens = ctx.tokens;
                                collectorName = ctx.name;
                            }
                        }
                    } catch (e) {}
                }

                if (tokens && tokens.length > 0 && collectorName) {
                    currentCollectorFilter = { name: collectorName, tokens: tokens };
                    openWallView(collectorName, tokens);
                }
            } catch (err) {
                console.error('Wall button error:', err);
            }
        }

        // Attach to wall button, collector name, AND entire banner
        // The banner acts as a large click target â€” any tap opens the wall
        // Only close/nav buttons are excluded
        document.getElementById('collectorWallView')?.addEventListener('click', (e) => {
            e.stopPropagation();
            handleWallButtonClick();
        });
        document.getElementById('collectorBannerName')?.addEventListener('click', (e) => {
            e.stopPropagation();
            handleWallButtonClick();
        });

        // Generate a notable detail about the collector's cities for the hover tooltip
        function getCityDetail(ownedItems) {
            if (!ownedItems || ownedItems.length === 0) return '';
            const details = [];

            for (const item of ownedItems) {
                const traits = tokenTraits[item.id];
                if (!traits) continue;
                const palette = traits['Palette'];
                const energy = traits['Energy'];
                const traffic = traits['Traffic'];
                const id = item.id;

                // Rush Hour + Rising Energy = very rare combo
                if (traffic === 'Rush Hour' && energy === 'Rising') {
                    details.push({ priority: 1, text: `#${id} has Rush Hour + Rising Energy â€” an extremely rare combination.` });
                }
                // 1-of-1 palette
                else if (palette && traitCounts.palettes && traitCounts.palettes[palette] === 1) {
                    details.push({ priority: 2, text: `#${id} is the only city with the ${palette} palette.` });
                }
                // Rush Hour alone
                else if (traffic === 'Rush Hour' && energy !== 'Rising') {
                    details.push({ priority: 3, text: `#${id} has Rush Hour traffic â€” one of the rarest traits in the collection.` });
                }
                // Rising Energy alone
                else if (energy === 'Rising') {
                    details.push({ priority: 4, text: `#${id} has Rising Energy â€” a rare energy state.` });
                }
                // Very rare palette (2 or 3 outputs)
                else if (palette && traitCounts.palettes && traitCounts.palettes[palette] <= 3) {
                    const ct = traitCounts.palettes[palette];
                    details.push({ priority: 5, text: `#${id} is one of only ${ct} cities with the ${palette} palette.` });
                }
            }

            if (details.length === 0) return '';
            details.sort((a, b) => a.priority - b.priority);
            return details[0].text;
        }

        // Show the tips toggle with hover detail for any wall view
        function showWallViewCityDetail(items) {
            const tipsToggle = document.getElementById('wallViewTipsToggle');
            const hoverEl = document.getElementById('wallViewTipsHover');
            if (!tipsToggle || !hoverEl) return;

            const detail = getCityDetail(items);
            if (detail) {
                hoverEl.textContent = detail;
                tipsToggle.classList.add('has-tips');
            } else {
                hoverEl.textContent = '';
            }
        }

        // Suggestion engine - suggests cities based on what collector has
        const ALL_ENERGIES = ['Rising', 'Living', 'Fading', 'Resting'];

        function showCollectorSuggestions(ownedItems, collector) {
            const suggestionEl = document.getElementById('wallViewSuggestion');
            const citiesEl = document.getElementById('suggestionCities');
            const textEl = document.getElementById('suggestionText');
            const labelEl = document.getElementById('suggestionLabel');

            // Only show for collectors with 1-3 cities
            if (!ownedItems || ownedItems.length === 0 || ownedItems.length > 3) {
                suggestionEl.classList.remove('visible');
                return;
            }

            // Count energies owned (with duplicates)
            const energyCounts = {};
            ownedItems.forEach(item => {
                const traits = tokenTraits[item.id];
                if (traits && traits['Energy']) {
                    energyCounts[traits['Energy']] = (energyCounts[traits['Energy']] || 0) + 1;
                }
            });

            const ownedEnergies = Object.keys(energyCounts);
            const missingEnergies = ALL_ENERGIES.filter(e => !energyCounts[e]);
            const collectorLabelEl = document.getElementById('wallViewCollectorLabel');
            const collectorName = collectorLabelEl?.dataset.rawName || collectorLabelEl?.textContent || 'This collector';

            // Determine suggestion strategy
            let suggestions = [];
            let messageHtml = '';
            let label = '';
            const ownedIds = new Set(ownedItems.map(i => parseInt(i.id)));

            // Check if they have duplicates of same energy
            const hasDuplicates = Object.values(energyCounts).some(c => c > 1);
            const dominantEnergy = Object.entries(energyCounts).sort((a, b) => b[1] - a[1])[0];

            if (hasDuplicates && ownedEnergies.length === 1) {
                // They have multiple of the same energy (e.g., 2 Fading)
                // Suggest: either complete a same-energy grid OR diversify
                label = 'Expand the collection';

                const energy = dominantEnergy[0];
                const count = dominantEnergy[1];

                // Find more of same energy for a grid
                const sameEnergySuggestions = [];
                // Find different energies for diversity
                const diverseSuggestions = [];

                for (let i = 0; i <= MAX_TOKEN; i++) {
                    if (ownedIds.has(i) || PROJECT_WALLET_TOKENS.has(i)) continue;
                    const traits = tokenTraits[i];
                    if (!traits) continue;

                    const e = traits['Energy'];
                    const traffic = traits['Traffic'];
                    const weight = traffic === 'Rush Hour' ? 4 : (traffic === 'Heavy' ? 2 : 1);

                    if (e === energy) {
                        sameEnergySuggestions.push({ id: i, energy: e, palette: traits['Palette'], weight });
                    } else {
                        diverseSuggestions.push({ id: i, energy: e, palette: traits['Palette'], weight });
                    }
                }

                // Pick 2 of same energy + 2 diverse
                sameEnergySuggestions.sort((a, b) => b.weight - a.weight);
                diverseSuggestions.sort((a, b) => b.weight - a.weight);

                // Get one of each missing energy for diversity
                const usedEnergies = new Set();
                const diversePicks = [];
                for (const s of diverseSuggestions) {
                    if (!usedEnergies.has(s.energy) && diversePicks.length < 2) {
                        diversePicks.push(s);
                        usedEnergies.add(s.energy);
                    }
                }

                suggestions = [
                    ...sameEnergySuggestions.slice(0, 2),
                    ...diversePicks
                ].slice(0, 4);

                const neededForGrid = 4 - count; // Need 4 for a 2x2 grid
                messageHtml = `${collectorName} has <strong>${count} ${energy}</strong> cities. Add ${neededForGrid} more for a <strong>${energy} grid</strong>, or diversify with other energies.`;

            } else if (missingEnergies.length > 0 && missingEnergies.length < 4) {
                // They have some variety but not complete set
                label = 'Complete the Energy Set';

                for (let i = 0; i <= MAX_TOKEN; i++) {
                    if (ownedIds.has(i) || PROJECT_WALLET_TOKENS.has(i)) continue;
                    const traits = tokenTraits[i];
                    if (!traits) continue;

                    const energy = traits['Energy'];
                    if (missingEnergies.includes(energy)) {
                        const traffic = traits['Traffic'];
                        const weight = traffic === 'Rush Hour' ? 4 : (traffic === 'Heavy' ? 2 : 1);
                        suggestions.push({ id: i, energy, palette: traits['Palette'], weight });
                    }
                }

                suggestions.sort((a, b) => b.weight - a.weight);

                // Pick one of each missing energy
                const topSuggestions = [];
                const usedEnergies = new Set();
                for (const s of suggestions) {
                    if (!usedEnergies.has(s.energy) && topSuggestions.length < 4) {
                        topSuggestions.push(s);
                        usedEnergies.add(s.energy);
                    }
                }
                suggestions = topSuggestions;

                const ownedList = ownedEnergies.map(e => {
                    const count = energyCounts[e];
                    return `${count} ${e}`;
                }).join(' & ');
                const missingList = missingEnergies.join(' & ');
                const missingCount = missingEnergies.length;

                messageHtml = `${collectorName} has <strong>${ownedList}</strong> ${ownedEnergies.length === 1 && energyCounts[ownedEnergies[0]] === 1 ? 'city' : 'cities'}. Add <strong>${missingList}</strong> (${missingCount} ${missingCount === 1 ? 'city' : 'cities'}) for a complete Energy Set.`;

            } else {
                suggestionEl.classList.remove('visible');
                return;
            }

            if (suggestions.length === 0) {
                suggestionEl.classList.remove('visible');
                return;
            }

            if (labelEl) labelEl.textContent = label;
            textEl.innerHTML = messageHtml;

            // Render suggestion thumbnails
            citiesEl.innerHTML = suggestions.map(s => `
                <div class="wall-view-suggestion-city" data-token="${s.id}" title="#${s.id} Â· ${s.energy} Â· ${s.palette}">
                    <img src="${MEDIA_BASE}/${CONTRACT}/${s.id}.png?width=100" alt="#${s.id}">
                </div>
            `).join('');

            // Click to show options dropdown
            citiesEl.querySelectorAll('.wall-view-suggestion-city').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const tokenId = parseInt(el.dataset.token);
                    showSuggestionOptions(e, tokenId, el);
                });
            });

            // Show the tips toggle button instead of auto-showing suggestions
            const tipsToggle = document.getElementById('wallViewTipsToggle');
            if (tipsToggle) {
                tipsToggle.classList.add('has-tips');
                // Store that we have tips ready
                tipsToggle.dataset.ready = 'true';
            }
        }

        // Tips toggle button click handler
        document.getElementById('wallViewTipsToggle')?.addEventListener('click', () => {
            const suggestionEl = document.getElementById('wallViewSuggestion');
            const tipsToggle = document.getElementById('wallViewTipsToggle');

            if (suggestionEl.classList.contains('visible')) {
                suggestionEl.classList.remove('visible');
            } else if (tipsToggle.dataset.ready === 'true') {
                suggestionEl.classList.add('visible');
            }
        });

        // Show options when clicking a suggested city
        function showSuggestionOptions(e, tokenId, element) {
            // Remove any existing dropdown
            document.querySelectorAll('.suggestion-options-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'suggestion-options-dropdown';
            dropdown.innerHTML = `
                <div class="suggestion-option" data-action="try">
                    <span class="suggestion-option-icon">+</span>
                    <div class="suggestion-option-text">
                        <div class="suggestion-option-title">Add to TRY grid</div>
                        <div class="suggestion-option-desc">See how it looks in the collection</div>
                    </div>
                </div>
                <div class="suggestion-option" data-action="offer">
                    <span class="suggestion-option-icon">â›µ</span>
                    <div class="suggestion-option-text">
                        <div class="suggestion-option-title">Make offer on OpenSea</div>
                        <div class="suggestion-option-desc">Place a bid on City #${tokenId}</div>
                    </div>
                </div>
                <div class="suggestion-option" data-action="mint">
                    <span class="suggestion-option-icon">âœ¦</span>
                    <div class="suggestion-option-text">
                        <div class="suggestion-option-title">Get a new city</div>
                        <div class="suggestion-option-desc">Get a new one on Art Blocks</div>
                    </div>
                </div>
            `;

            // Position dropdown near the clicked element
            const rect = element.getBoundingClientRect();
            dropdown.style.position = 'fixed';
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.top = `${rect.bottom + 8}px`;
            dropdown.style.zIndex = '3000';

            document.body.appendChild(dropdown);

            // Handle option clicks
            dropdown.querySelectorAll('.suggestion-option').forEach(opt => {
                opt.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const action = opt.dataset.action;
                    dropdown.remove();

                    if (action === 'try') {
                        // Add to TRY grid
                        addTempCity(tokenId);
                    } else if (action === 'offer') {
                        // Open OpenSea offer page
                        window.open(`https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}`, '_blank');
                    } else if (action === 'mint') {
                        // Open Art Blocks mint page
                        window.open('https://www.artblocks.io/collection/cities-by-efdot-x-diid', '_blank');
                    }
                });
            });

            // Close on click outside
            setTimeout(() => {
                const closeDropdown = (ev) => {
                    if (!dropdown.contains(ev.target)) {
                        dropdown.remove();
                        document.removeEventListener('click', closeDropdown);
                    }
                };
                document.addEventListener('click', closeDropdown);
            }, 10);
        }

        // Close suggestion
        document.getElementById('suggestionClose')?.addEventListener('click', () => {
            document.getElementById('wallViewSuggestion').classList.remove('visible');
        });

        function generateCollectorTagline(tokenIds) {
            if (!tokenIds || tokenIds.length === 0) return '';

            // Analyze the collection
            const times = [], palettes = [], zooms = [], bounds = [];
            tokenIds.forEach(id => {
                const traits = tokenTraits[id];
                if (traits) {
                    if (traits['Time of Day']) times.push(traits['Time of Day']);
                    if (traits['Palette']) palettes.push(traits['Palette']);
                    if (traits['Zoom']) zooms.push(traits['Zoom']);
                    if (traits['Bounds']) bounds.push(traits['Bounds']);
                }
            });

            const count = tokenIds.length;
            const dominantTime = getMostCommon(times);
            const dominantPalette = getMostCommon(palettes);
            const dominantZoom = getMostCommon(zooms);

            // Count specific traits
            const nightCount = times.filter(t => t === 'Night').length;
            const dawnCount = times.filter(t => t === 'Dawn').length;
            const dayCount = times.filter(t => t === 'Day').length;
            const duskCount = times.filter(t => t === 'Dusk').length;

            // Calculate percentages
            const nightPct = nightCount / count;
            const dawnPct = dawnCount / count;
            const duskPct = duskCount / count;

            // Clever taglines based on collection characteristics
            const taglines = [];

            // Night owl collectors
            if (nightPct > 0.6) {
                taglines.push(
                    "The city never sleeps, and neither do they.",
                    "Some find clarity when the world goes quiet.",
                    "A collection that glows after midnight."
                );
            } else if (nightPct > 0.4) {
                taglines.push(
                    "Drawn to the hours when streets empty and lights multiply.",
                    "The night shift, curated."
                );
            }

            // Dawn collectors
            if (dawnPct > 0.5) {
                taglines.push(
                    "First light hits different when you're watching.",
                    "Catching cities before they fully wake.",
                    "The early collector gets the gradient."
                );
            }

            // Dusk collectors
            if (duskPct > 0.5) {
                taglines.push(
                    "Golden hour, every hour.",
                    "When day exhales into evening.",
                    "The magic between work and wonder."
                );
            }

            // Big collectors
            if (count >= 10) {
                taglines.push(
                    "Building a metropolis, one block at a time.",
                    "A serious commitment to urban density.",
                    "Some people collect stamps. This is better."
                );
            } else if (count >= 5) {
                taglines.push(
                    "Five corners of the same infinite city.",
                    "A neighborhood takes shape.",
                    "Curating corners of the algorithmic sprawl."
                );
            } else if (count === 4) {
                taglines.push(
                    "Four views. One vision.",
                    "A crossroads of color and code.",
                    "The beginning of something bigger."
                );
            } else if (count === 3) {
                taglines.push(
                    "A trilogy of towering ambition.",
                    "Three windows into the infinite grid."
                );
            } else if (count === 2) {
                taglines.push(
                    "A pair that speaks volumes.",
                    "Two cities, one collector.",
                    "Sometimes all you need is a conversation."
                );
            } else if (count === 1) {
                taglines.push(
                    "One city. Infinite meaning.",
                    "Every collection starts somewhere.",
                    "The first step into the skyline."
                );
            }

            // Zoom-based
            if (dominantZoom === 'Macro') {
                taglines.push(
                    "Preferring the details over the distance.",
                    "Getting close to what matters."
                );
            } else if (dominantZoom === 'Wide') {
                taglines.push(
                    "Taking in the full picture.",
                    "A preference for the panoramic."
                );
            }

            // All same palette
            const uniquePalettes = [...new Set(palettes)];
            if (uniquePalettes.length === 1 && count > 1) {
                taglines.push(
                    `A commitment to ${uniquePalettes[0].toLowerCase()}.`,
                    "Color consistency is a kind of curation."
                );
            }

            // Mixed times = variety collector
            const uniqueTimes = [...new Set(times)];
            if (uniqueTimes.length >= 3 && count >= 4) {
                taglines.push(
                    "Around the clock, around the collection.",
                    "24 hours of Cities, condensed.",
                    "Time zones are just suggestions."
                );
            }

            // Random selection from applicable taglines
            if (taglines.length === 0) {
                taglines.push(
                    "A perspective worth preserving.",
                    "Collecting the uncollectable.",
                    "Where algorithm meets intention."
                );
            }

            return taglines[Math.floor(Math.random() * taglines.length)];
        }

        function closeWallView() {
            const modal = document.getElementById('wallViewModal');
            modal.classList.remove('open', 'haunted-active');
            if (window.hauntedTimer) clearTimeout(window.hauntedTimer);
            document.body.style.overflow = '';

            // Reset tips toggle and hover tooltip
            const tipsToggle = document.getElementById('wallViewTipsToggle');
            if (tipsToggle) {
                tipsToggle.classList.remove('has-tips');
                tipsToggle.dataset.ready = 'false';
            }
            const hoverEl = document.getElementById('wallViewTipsHover');
            if (hoverEl) hoverEl.textContent = '';
            document.getElementById('wallViewSuggestion')?.classList.remove('visible');

            // Reset try mode and drag state
            wallViewTryMode = false;
            isDragSwapping = false;
            document.getElementById('wallViewTryMode')?.classList.remove('active');

            // Reset line view
            modal.classList.remove('line-view');
            const lineBtn = document.getElementById('wallViewHideEmpty');
            if (lineBtn) {
                lineBtn.classList.remove('active');
                lineBtn.innerHTML = '<span class="line-icon">âŠž</span> GRID';
            }

            // Reset nudge bar
            const nudge = document.getElementById('wallViewGridNudge');
            if (nudge) nudge.classList.remove('ready', 'show');

            // Clean up any lingering overlays
            document.querySelector('.try-city-picker')?.remove();
            document.querySelector('.empty-slot-dropdown')?.remove();
        }

        function getTraitRarity(traitKey, traitValue) {
            if (totalMinted === 0) return null;
            let count = 0;
            if (traitKey === 'Palette') count = traitCounts.palettes[traitValue] || 0;
            else if (traitKey === 'Time of Day') count = traitCounts.times[traitValue] || 0;
            else if (traitKey === 'Zoom') count = traitCounts.zooms[traitValue] || 0;
            else if (traitKey === 'Bounds') count = traitCounts.bounds[traitValue] || 0;
            else if (traitKey === 'Traffic') count = traitCounts.traffic[traitValue] || 0;
            else if (traitKey === 'Line') count = traitCounts.lines[traitValue] || 0;
            else if (traitKey === 'Energy') count = traitCounts.energy[traitValue] || 0;
            else if (traitKey === 'Commute') count = traitCounts.commute[traitValue] || 0;
            else if (traitKey === 'Transit') count = traitCounts.transit[traitValue] || 0;
            else if (traitKey === 'Water Feature') count = traitCounts.water[traitValue] || 0;
            else return null;
            const rawPct = (count / totalMinted) * 100;
            // Show 1 decimal place for rare traits (<1%), otherwise round to integer
            const pct = rawPct < 1 && rawPct > 0 ? rawPct.toFixed(1) : Math.round(rawPct);
            return { count, pct };
        }

        function generateGridTooltip(tokenId) {
            const traits = tokenTraits[tokenId];
            if (!traits) return '';
            const keyTraits = ['Time of Day', 'Zoom', 'Bounds', 'Traffic'];
            const rows = keyTraits.map(key => {
                const value = traits[key];
                if (!value) return '';
                const rarity = getTraitRarity(key, value);
                const pctClass = rarity && rarity.pct <= 10 ? 'rare' : '';
                const pctHtml = rarity ? `<span class="grid-item-tooltip-pct ${pctClass}">${rarity.pct}%</span>` : '';
                return `<div class="grid-item-tooltip-row">
                    <span class="grid-item-tooltip-label">${key.replace('Time of Day', 'Time').toUpperCase()}</span>
                    <span><span class="grid-item-tooltip-value">${value}</span>${pctHtml}</span>
                </div>`;
            }).filter(Boolean).join('');
            return `<div class="grid-item-tooltip">${rows}</div>`;
        }

        function displayCurrentTraits(traits) {
            if (!traits) { traitsDisplay.innerHTML = '<div class="trait-row"><span class="trait-name">LOADING...</span></div>'; return; }
            // Rename "Lighter" to "Chisel" for Line trait display
            const displayValue = (key, value) => key === 'Line' && value === 'Lighter' ? 'Chisel' : value;

            const timeOfDay = traits['Time of Day'];
            const energy = traits['Energy'];
            const palette = traits['Palette'];

            // Get hour from palette metadata for digital clock display
            const paletteMeta = PALETTE_META[palette];
            const hourDisplay = paletteMeta?.hour || '--:--';

            // Energy icons (B/W grayscale style)
            const energyIcons = {
                'Rising': '\u2600',      // Sun for rising
                'Living': '\u{1F6B6}',   // Walking person for living
                'Fading': '\u26C5',      // Sun behind cloud for fading
                'Resting': '\u{1F319}'   // Moon for resting
            };
            const energyIcon = energyIcons[energy] || 'â—';

            // Only these traits have filters in grid view
            const filterableTraits = ['Palette', 'Time of Day', 'Energy', 'Zoom', 'Bounds', 'Traffic', 'Water Feature'];
            const isFilterable = (traitName) => filterableTraits.includes(traitName);

            // Build palette row first (highlighted)
            let html = '';
            if (palette && PALETTE_DATA[palette]) {
                const paletteInfo = PALETTE_DATA[palette];
                const rarity = getTraitRarity('Palette', palette);
                const rarityHtml = rarity ? `<span class="trait-rarity ${rarity.pct <= 10 ? 'rare' : ''}">${rarity.pct}%</span>` : '';
                const swatches = paletteInfo.colors.slice(0, 6).map(c => `<span style="background:${c};"></span>`).join('');
                html += `<div class="trait-row palette-row clickable" data-trait="Palette" data-value="${palette}">
                    <span class="trait-name">PALETTE</span>
                    <div class="palette-swatches">${swatches}</div>
                    <span class="trait-value">${palette.toUpperCase()}</span>
                    ${rarityHtml}
                </div>`;
            }

            // Hour with digital clock display
            if (hourDisplay && hourDisplay !== '--:--') {
                html += `<div class="trait-row" title="Palette hour">
                    <span class="trait-name">HOUR</span>
                    <span class="trait-value"><span class="digital-clock">${hourDisplay}</span></span>
                </div>`;
            }

            // Time of Day with energy icon
            if (timeOfDay) {
                const rarity = getTraitRarity('Time of Day', timeOfDay);
                const rarityHtml = rarity ? `<span class="trait-rarity ${rarity.pct <= 10 ? 'rare' : ''}">${rarity.pct}%</span>` : '';
                html += `<div class="trait-row clickable" data-trait="Time of Day" data-value="${timeOfDay}">
                    <span class="trait-name">TIME</span>
                    <span class="trait-value">${timeOfDay.toUpperCase()}</span>
                    ${rarityHtml}
                </div>`;
            }

            // Energy with icon (B/W grayscale)
            if (energy) {
                const rarity = getTraitRarity('Energy', energy);
                const rarityHtml = rarity ? `<span class="trait-rarity ${rarity.pct <= 10 ? 'rare' : ''}">${rarity.pct}%</span>` : '';
                html += `<div class="trait-row clickable" data-trait="Energy" data-value="${energy}">
                    <span class="trait-name">ENERGY</span>
                    <span class="trait-value">${energy.toUpperCase()}</span>
                    <span class="energy-icon">${energyIcon}</span>
                    ${rarityHtml}
                </div>`;
            }

            // Other traits (excluding Palette, Time of Day, and Energy which are already shown)
            const excludeTraits = ['Palette', 'Time of Day', 'Energy'];
            const otherEntries = Object.entries(traits).filter(([key]) => !excludeTraits.includes(key));
            html += otherEntries.map(([key, value]) => {
                const rarity = getTraitRarity(key, value);
                const rarityHtml = rarity ? `<span class="trait-rarity ${rarity.pct <= 10 ? 'rare' : ''}">${rarity.pct}%</span>` : '';
                const clickableClass = isFilterable(key) ? ' clickable' : '';
                const dataAttrs = isFilterable(key) ? ` data-trait="${key}" data-value="${value}"` : '';
                return `<div class="trait-row${clickableClass}"${dataAttrs}><span class="trait-name">${key.toUpperCase()}</span><span class="trait-value">${displayValue(key, value).toUpperCase()}</span>${rarityHtml}</div>`;
            }).join('');

            traitsDisplay.innerHTML = html;

            // Style the inspect palette button with colored dots flanking a magnifying glass
            const inspectBtn = document.getElementById('inspectPalette');
            if (inspectBtn && palette && PALETTE_DATA[palette]) {
                const pInfo = PALETTE_DATA[palette];
                const pColors = pInfo.colors || [];
                const dotColors = [pInfo.bg, ...pColors.slice(0, 9)];
                const leftDots = dotColors.slice(0, 5).map(c => `<span class="inspect-dot" style="background:${c}"></span>`).join('');
                const rightDots = dotColors.slice(5, 10).map(c => `<span class="inspect-dot" style="background:${c}"></span>`).join('');
                const magSvg = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="10.5" cy="10.5" r="6.5" stroke="rgba(255,255,255,0.7)" stroke-width="2" fill="rgba(255,255,255,0.08)"/><line x1="15.5" y1="15.5" x2="21" y2="21" stroke="rgba(255,255,255,0.7)" stroke-width="2" stroke-linecap="round"/><ellipse cx="8.5" cy="8.5" rx="2.5" ry="1.5" transform="rotate(-30 8.5 8.5)" fill="rgba(255,255,255,0.15)"/></svg>`;
                inspectBtn.innerHTML = `<span class="inspect-dots">${leftDots}</span><span class="inspect-icon">${magSvg}</span><span class="inspect-dots">${rightDots}</span><span class="inspect-hover-label">INSPECT PALETTE</span>`;
                inspectBtn.style.background = '';
                inspectBtn.style.border = '';
                inspectBtn.style.color = '';
                inspectBtn.style.textShadow = '';
            }

            // Add click handlers for filterable trait rows
            traitsDisplay.querySelectorAll('.trait-row.clickable').forEach(row => {
                row.addEventListener('click', () => {
                    const trait = row.dataset.trait;
                    const value = row.dataset.value;
                    if (trait && value) filterByTrait(trait, value);
                });
            });
        }

        // Filter by clicking on a trait in metadata
        function filterByTrait(traitName, traitValue) {
            // Map trait names to filter select IDs
            const filterMap = {
                'Palette': 'filterPalette',
                'Time of Day': 'filterTime',
                'Energy': 'filterEnergy',
                'Traffic': 'filterTraffic',
                'Zoom': 'filterZoom',
                'Bounds': 'filterBounds',
                'Water Feature': 'filterWater'
            };

            const filterId = filterMap[traitName];
            if (filterId) {
                const select = document.getElementById(filterId);
                if (select) {
                    select.value = traitValue;
                    // Trigger change event to apply filter
                    select.dispatchEvent(new Event('change'));
                    // Open grid view to show filtered results
                    if (typeof openGridView === 'function') openGridView();
                }
            }
        }
        window.filterByTrait = filterByTrait;

        function displayOwnerInfo(owner, loading = false) {
            if (loading) {
                ownerDisplay.innerHTML = '<span style="opacity:0.5">LOADING...</span>';
                return;
            }
            if (!owner || !owner.address) {
                ownerDisplay.innerHTML = '<span style="opacity:0.5">COLLECTOR UNKNOWN</span>';
                return;
            }
            // Priority: Art Blocks username > ENS > shortened address
            // Apply name alias to get preferred display name
            const rawName = owner.artblocksName || owner.ens || shortenAddress(owner.address);
            const displayName = applyNameAlias(rawName);
            // Make collector name clickable to open their gallery
            ownerDisplay.innerHTML = `IN THE COLLECTION OF <a href="#" class="collector-link-inline" data-address="${owner.address}" data-name="${displayName}">${displayName.toUpperCase()}</a>`;

            // Add click handler to open collector's gallery
            const link = ownerDisplay.querySelector('.collector-link-inline');
            if (link) {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const address = link.dataset.address;
                    const name = link.dataset.name;
                    // Fetch collector's tokens and open wall view in dark mode
                    openCollectorGallery(address, name);
                });
            }
        }

        // Open collector's gallery in dark mode wall view
        async function openCollectorGallery(address, displayName) {
            try {
                // Find collector in COLLECTORS_DATA or fetch their tokens
                const collector = COLLECTORS_DATA.find(c => c.address === address || c.name === displayName);
                let tokens = [];

                if (collector && collector.tokens) {
                    tokens = collector.tokens;
                } else {
                    // Fetch tokens for this address
                    const response = await fetch(`https://token-api.artblocks.io/0x99a9b7c1116f9ceeb1652de04d5969cce509b069-0/tokens?owner=${address}`);
                    const data = await response.json();
                    tokens = data.tokens ? data.tokens.map(t => parseInt(t.tokenId.split('-').pop())) : [];
                }

                if (tokens.length > 0) {
                    console.log('Opening collector gallery for', displayName, 'with', tokens.length, 'tokens');
                    // Open wall view in dark/black mode
                    const wallFn = window.openWallView || openWallViewFn;
                    if (typeof wallFn === 'function') {
                        wallFn(displayName, tokens);
                        // Ensure it's in black mode
                        setTimeout(() => {
                            const modal = document.getElementById('wallViewModal');
                            if (modal) {
                                modal.classList.remove('wall-gray');
                                modal.classList.add('wall-black');
                                currentWallColor = 'black';
                            }
                        }, 50);
                    } else {
                        console.error('openWallView function not available - window:', typeof window.openWallView, 'fn:', typeof openWallViewFn);
                    }
                } else {
                    console.warn('No tokens found for collector:', displayName);
                }
            } catch (error) {
                console.error('Error opening collector gallery:', error);
            }
        }
        window.openCollectorGallery = openCollectorGallery;

        // Navigation history for "back to previous" feature
        let outputHistory = [];
        const MAX_HISTORY = 20;

        // Grid navigation: ordered list of tokens from the grid the user clicked from
        // When set, prev/next follows this order instead of default minted order
        // Uses window property since handleGridItemClick is defined before this line
        window.gridNavigationList = null;

        function updateBackButton() {
            const backBtn = document.getElementById('backToPrevious');
            if (backBtn) {
                backBtn.style.display = outputHistory.length > 1 ? 'block' : 'none';
            }
        }

        async function loadOutput(tokenId = null, updateUrl = true, addToHistory = true) {
            // Track history (only if navigating via neighbors/pairs, not prev/next arrows)
            if (addToHistory && typeof currentTokenId !== 'undefined' && currentTokenId !== null) {
                // Don't add duplicates
                if (outputHistory.length === 0 || outputHistory[outputHistory.length - 1] !== currentTokenId) {
                    outputHistory.push(currentTokenId);
                    if (outputHistory.length > MAX_HISTORY) outputHistory.shift();
                }
            }

            currentTokenId = tokenId !== null ? tokenId : parseInt(tokenIdInput.value) || 0;
            // Get actual minted tokens to properly bound navigation
            const mintedTokens = Object.keys(tokenTraits).map(Number).sort((a, b) => a - b);
            const actualMax = mintedTokens.length > 0 ? mintedTokens[mintedTokens.length - 1] : 0;
            // If requested token doesn't exist, find nearest valid token
            if (mintedTokens.length > 0 && !mintedTokens.includes(currentTokenId)) {
                // Find the nearest valid token or loop
                if (currentTokenId > actualMax) {
                    currentTokenId = mintedTokens[0]; // Loop to start
                } else if (currentTokenId < 0) {
                    currentTokenId = actualMax; // Loop to end
                } else {
                    // Find nearest lower valid token
                    const lower = mintedTokens.filter(t => t <= currentTokenId);
                    currentTokenId = lower.length > 0 ? lower[lower.length - 1] : mintedTokens[0];
                }
            }
            currentTokenId = Math.max(0, Math.min(currentTokenId, actualMax));
            displayToken.textContent = currentTokenId;
            tokenIdInput.value = currentTokenId;
            // Sync mobile bottom bar token
            const mobTok = document.getElementById('mobToken');
            if (mobTok) mobTok.textContent = '#' + currentTokenId;
            if (updateUrl) updateUrlWithToken(currentTokenId);
            saveLastViewed();

            // Hide OpenSea overlay on navigation
            const ctv = document.getElementById('clickToView');
            if (ctv) ctv.classList.remove('visible');

            // Fade out current image
            previewImage.classList.add('fade-out');
            previewImage.classList.remove('loaded'); // Remove loaded state for fullscreen transition
            loadingOverlay.classList.remove('hidden');

            setTimeout(() => {
                previewImage.style.display = 'block';
                previewImage.src = getPreviewUrl(currentTokenId);
            }, 150);

            closeMobileMenu();
            displayOwnerInfo(null, true); // Show loading state
            const data = await fetchTokenData(currentTokenId);
            displayCurrentTraits(data.traits);
            displayOwnerInfo(data.owner, false);
            updateCityNote();
            updateBackgroundColors(data.traits);
            updateMarketplaceLinks(currentTokenId);
            updateSimilarOutputs();
            updateFavoriteButton();
            preloadAdjacentImages();
            updateBackButton();
            if (typeof updateNavButtonStates === 'function') updateNavButtonStates();
        }
        // Expose loadOutput globally for inline onclick handlers
        window.loadOutput = loadOutput;

        previewImage.addEventListener('load', () => {
            loadingOverlay.classList.add('hidden');
            previewImage.classList.remove('fade-out');
            previewImage.classList.add('just-loaded');
            // Add loaded class for fullscreen smooth appearance
            if (isFullscreen) {
                previewImage.classList.add('loaded');
            }
            setTimeout(() => previewImage.classList.remove('just-loaded'), 250);
        });
        previewImage.addEventListener('error', () => {
            loadingOverlay.classList.add('hidden');
            previewImage.style.display = 'none';
            previewImage.classList.remove('fade-out');
        });

        function getTokenPageUrl(tokenId) { return `https://www.artblocks.io/token/${CONTRACT}/${tokenId}`; }
        function getOpenSeaUrl(tokenId) { return `https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}`; }
        function openFullView() {
            const url = getOpenSeaUrl(currentTokenId);
            if (confirm('Taking a detour to opensea.io')) {
                window.open(url, '_blank');
            }
        }
        // Click/tap on frame toggles the OpenSea overlay; clicking the overlay itself navigates
        const clickToViewEl = document.getElementById('clickToView');
        let clickToViewTimer = null;
        frameContainer.addEventListener('click', (e) => {
            if (document.body.classList.contains('fullscreen-mode')) return;
            // If clicking the overlay text itself, navigate to OpenSea
            if (e.target === clickToViewEl || e.target.closest('.click-to-view')) {
                openFullView();
                return;
            }
            // Otherwise toggle the overlay visibility
            if (clickToViewEl.classList.contains('visible')) {
                clickToViewEl.classList.remove('visible');
                clearTimeout(clickToViewTimer);
            } else {
                clickToViewEl.classList.add('visible');
                // Auto-hide after 3 seconds
                clearTimeout(clickToViewTimer);
                clickToViewTimer = setTimeout(() => {
                    clickToViewEl.classList.remove('visible');
                }, 3000);
            }
        });

        function updateMarketplaceLinks(tokenId) {
            const linkOpenSea = document.getElementById('linkOpenSea');
            const linkArtBlocks = document.getElementById('linkArtBlocks');
            const linkRaster = document.getElementById('linkRaster');
            const iconOpenSea = document.getElementById('iconOpenSea');
            const iconArtBlocks = document.getElementById('iconArtBlocks');
            const makeOfferBtn = document.getElementById('makeOfferBtn');
            if (linkOpenSea) linkOpenSea.href = getOpenSeaUrl(tokenId);
            if (linkArtBlocks) linkArtBlocks.href = getTokenPageUrl(tokenId);
            if (linkRaster) linkRaster.href = `https://rfrsh.io/${CONTRACT}/${tokenId}`;
            if (iconOpenSea) iconOpenSea.href = getOpenSeaUrl(tokenId);
            if (iconArtBlocks) iconArtBlocks.href = getTokenPageUrl(tokenId);
            if (makeOfferBtn) {
                makeOfferBtn.href = '#';
                makeOfferBtn.dataset.openseaUrl = `https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}`;
            }

            // Fetch listing info from Reservoir
            fetchListingInfo(tokenId);
        }

        async function fetchListingInfo(tokenId) {
            const listingInfo = document.getElementById('listingInfo');
            listingInfo.classList.remove('visible');

            try {
                const response = await fetch(`https://api.reservoir.tools/tokens/v7?tokens=${CONTRACT}:${tokenId}&includeAttributes=false`);
                const data = await response.json();

                if (data.tokens && data.tokens[0]) {
                    const token = data.tokens[0];
                    const market = token.market;

                    if (market && market.floorAsk && market.floorAsk.price) {
                        const price = market.floorAsk.price.amount.native;
                        const source = market.floorAsk.source?.name || 'OpenSea';
                        listingInfo.innerHTML = `
                            <div class="listing-label">LISTED FOR SALE</div>
                            <div class="listing-price">${price.toFixed(3)} ETH</div>
                            <div class="listing-source">on ${source}</div>
                        `;
                        listingInfo.classList.add('visible');
                    }
                }
            } catch (e) {
                // Listing fetch failed silently
            }
        }

        function setSize(size) {
            currentSize = size;
            const { width, height } = SIZES[size];
            frameContainer.style.width = width + 'px';
            frameContainer.style.height = height + 'px';
        }

        function showStatus(message, type = 'success') {
            // Disabled - no popup notifications
            return;
        }

        function saveFavorite() {
            const favBtn = document.getElementById('saveFavorite');
            const savedNote = document.getElementById('savedNote');
            const exists = favorites.some(f => f.tokenId === currentTokenId);
            if (exists) {
                // Unfavorite
                const idx = favorites.findIndex(f => f.tokenId === currentTokenId);
                favorites.splice(idx, 1);
                localStorage.setItem('cities-favorites', JSON.stringify(favorites));
                updateGallery();
                favBtn.classList.remove('favorited');
                savedNote.classList.remove('visible');
            } else {
                // Add favorite
                favorites.unshift({ id: Date.now(), tokenId: currentTokenId, timestamp: new Date().toISOString() });
                localStorage.setItem('cities-favorites', JSON.stringify(favorites));
                updateGallery();
                favBtn.classList.add('favorited');
                // Show saved note with animated dots
                savedNote.classList.add('visible');
                setTimeout(() => savedNote.classList.remove('visible'), 3000);
                // Create water droplet burst
                for (let i = 0; i < 4; i++) {
                    const droplet = document.createElement('span');
                    droplet.className = 'heart-droplet';
                    favBtn.appendChild(droplet);
                }
                setTimeout(() => {
                    favBtn.querySelectorAll('.heart-droplet').forEach(d => d.remove());
                }, 1000);
            }
            // Update note visibility (only shows for favorited cities)
            updateCityNote();
        }

        function updateFavoriteButton() {
            const favBtn = document.getElementById('saveFavorite');
            const traits = tokenTraits[currentTokenId];

            // Set spot color from palette
            if (traits && traits['Palette']) {
                const paletteInfo = PALETTE_DATA[traits['Palette']];
                if (paletteInfo && paletteInfo.colors && paletteInfo.colors.length > 10) {
                    // Use Spot 1 color (index 10 in the colors array)
                    favBtn.style.setProperty('--spot-color', paletteInfo.colors[10]);
                }
            }

            if (favorites.some(f => f.tokenId === currentTokenId)) {
                favBtn.classList.add('favorited');
            } else {
                favBtn.classList.remove('favorited');
            }
        }

        async function downloadPng() {
            showStatus('CREATING PRINT MOCKUP...');
            try {
                // Load artwork image
                const response = await fetch(getPreviewUrl(currentTokenId));
                const blob = await response.blob();
                const img = new Image();
                img.crossOrigin = 'anonymous';
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });

                // Load logos
                const loadLogo = (src) => new Promise((resolve) => {
                    const logo = new Image();
                    logo.crossOrigin = 'anonymous';
                    logo.onload = () => resolve(logo);
                    logo.onerror = () => resolve(null);
                    logo.src = src;
                });
                const [efLogo, diidLogo] = await Promise.all([
                    loadLogo('ef-logo.png'),
                    loadLogo('diid-logo.png')
                ]);

                // Target size: 1080x1920 (9:16 museum print)
                const W = 1080;
                const H = 1920;
                const canvas = document.createElement('canvas');
                canvas.width = W;
                canvas.height = H;
                const ctx = canvas.getContext('2d');

                // Warm white museum paper background
                ctx.fillStyle = '#f8f6f2';
                ctx.fillRect(0, 0, W, H);

                // Art placement - generous top/side margins, more space below for title area
                const sideMargin = 100;
                const topMargin = 160;
                const bottomReserve = 420; // space for title + logos + signature
                const availW = W - sideMargin * 2;
                const availH = H - topMargin - bottomReserve;

                const imgRatio = img.width / img.height;
                let drawW, drawH;
                if (imgRatio > availW / availH) {
                    drawW = availW;
                    drawH = availW / imgRatio;
                } else {
                    drawH = availH;
                    drawW = availH * imgRatio;
                }

                const artX = (W - drawW) / 2;
                const artY = topMargin + (availH - drawH) / 2;

                // Subtle shadow behind artwork
                ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                ctx.drawImage(img, artX, artY, drawW, drawH);
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;

                // Title: "Cities #XXX" - centered below artwork
                const titleY = artY + drawH + 60;
                ctx.fillStyle = '#333';
                ctx.font = '300 28px "Nunito", Helvetica, Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.letterSpacing = '4px';
                ctx.fillText(`Cities #${currentTokenId}`, W / 2, titleY);
                ctx.letterSpacing = '0px';

                // Thin separator line
                const lineY = titleY + 24;
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(W / 2 - 60, lineY);
                ctx.lineTo(W / 2 + 60, lineY);
                ctx.stroke();

                // Logos at the bottom - Efdot bottom-left, Diid bottom-right
                const logoY = H - 120;
                const logoMaxH = 32;
                const logoMargin = sideMargin + 10;

                if (efLogo) {
                    const efRatio = efLogo.width / efLogo.height;
                    const efH = logoMaxH;
                    const efW = efH * efRatio;
                    // Draw logo in grayscale/muted
                    ctx.globalAlpha = 0.4;
                    ctx.drawImage(efLogo, logoMargin, logoY - efH / 2, efW, efH);
                    ctx.globalAlpha = 1.0;
                }

                if (diidLogo) {
                    const diidRatio = diidLogo.width / diidLogo.height;
                    const diidH = logoMaxH;
                    const diidW = diidH * diidRatio;
                    ctx.globalAlpha = 0.4;
                    ctx.drawImage(diidLogo, W - logoMargin - diidW, logoY - diidH / 2, diidW, diidH);
                    ctx.globalAlpha = 1.0;
                }

                // Signature - very small, bottom right corner above the logo
                ctx.fillStyle = '#999';
                ctx.font = 'italic 14px "Nunito", Georgia, serif';
                ctx.textAlign = 'right';
                ctx.fillText('Efdot', W - logoMargin, logoY + logoMaxH + 16);
                ctx.textAlign = 'center';

                // Download
                canvas.toBlob((jpgBlob) => {
                    const url = URL.createObjectURL(jpgBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Cities-${currentTokenId}-print.jpg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    URL.revokeObjectURL(img.src);
                    showStatus('PRINT MOCKUP SAVED');
                }, 'image/jpeg', 0.95);

            } catch (e) {
                console.error('Download error:', e);
                window.open(getPreviewUrl(currentTokenId), '_blank');
                showStatus('RIGHT-CLICK TO SAVE');
            }
        }

        function shareInstagram() {
            const caption = `Cities #${currentTokenId}\nby @efdotstudio x @0xdiid\n\nMint: artblocks.io/cities`;
            navigator.clipboard.writeText(caption).then(() => {
                showStatus('CAPTION COPIED');
                setTimeout(() => alert('Caption copied!\n\n1. Download the image first\n2. Open Instagram and create a Story\n3. Add the downloaded image\n4. Paste the caption'), 500);
            }).catch(() => prompt('Copy this caption:', caption));
        }

        // Frame mockup token list for navigation (all minted or collector-specific)
        let frameMockupTokens = [];
        let frameMockupCurrentIndex = 0;
        let frameMockupCollectorName = '';

        function openFrameMockup(tokenId, collectorName) {
            const frameMockup = document.getElementById('frameMockup');
            const frameImage = document.getElementById('frameMockupImage');
            const wallModal = document.getElementById('wallViewModal');

            // Determine which token to show (guard against event objects being passed as tokenId)
            const showToken = (typeof tokenId === 'number' ? tokenId : null) || currentTokenId;

            // Build token list for navigation
            const allMintedTokens = Object.keys(tokenTraits).map(Number).sort((a, b) => a - b);
            frameMockupTokens = allMintedTokens.length > 0 ? allMintedTokens : [showToken];
            frameMockupCurrentIndex = frameMockupTokens.indexOf(showToken);
            if (frameMockupCurrentIndex === -1) frameMockupCurrentIndex = 0;
            frameMockupCollectorName = collectorName || '';

            // Default to dark/night mode
            frameMockup.classList.add('dark-mode');
            const modeBtn = document.getElementById('frameMockupMode');
            if (modeBtn) modeBtn.textContent = '\u2600';

            // Reset frame color to light-wood
            currentFrameColor = 'light-wood';
            document.querySelectorAll('.frame-color-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.frame-color-btn[data-color="light-wood"]')?.classList.add('active');
            const wrapper = document.getElementById('frameWrapper');
            if (wrapper) {
                wrapper.classList.remove('frame-white', 'frame-black', 'frame-dark-wood');
                wrapper.style.background = '';
                const inner = wrapper.querySelector('.frame-inner');
                if (inner) inner.style.background = '';
            }

            frameImage.src = `${MEDIA_BASE}/${CONTRACT}/${showToken}.png`;
            updateFrameMockupInfo(showToken);
            frameMockup.classList.add('open');
            updateFrameMockupNav();
        }

        function closeFrameMockup() {
            document.getElementById('frameMockup').classList.remove('open');
        }

        function updateFrameMockupInfo(tokenId) {
            const label = document.getElementById('frameMockupLabel');
            const collectorEl = document.getElementById('frameMockupCollector');
            if (label) label.textContent = `#${tokenId}`;

            // Look up current owner
            const collector = COLLECTORS_DATA?.find(c => c.tokens && c.tokens.includes(tokenId));
            const ownerName = collector ? collector.name : null;
            if (ownerName && collectorEl) {
                collectorEl.textContent = `owned by ${ownerName}`;
                collectorEl.style.display = 'block';
            } else if (collectorEl) {
                collectorEl.style.display = 'none';
            }
        }

        function updateFrameMockupNav() {
            const prevBtn = document.getElementById('frameMockupPrev');
            const nextBtn = document.getElementById('frameMockupNext');
            if (prevBtn) prevBtn.disabled = frameMockupTokens.length <= 1;
            if (nextBtn) nextBtn.disabled = frameMockupTokens.length <= 1;
        }

        function frameMockupPrev() {
            if (frameMockupTokens.length === 0) return;
            frameMockupCurrentIndex = (frameMockupCurrentIndex - 1 + frameMockupTokens.length) % frameMockupTokens.length;
            const newToken = frameMockupTokens[frameMockupCurrentIndex];
            document.getElementById('frameMockupImage').src = `${MEDIA_BASE}/${CONTRACT}/${newToken}.png`;
            updateFrameMockupInfo(newToken);
            // Also update the main view behind
            loadOutput(newToken, true, false);
        }

        function frameMockupNext() {
            if (frameMockupTokens.length === 0) return;
            frameMockupCurrentIndex = (frameMockupCurrentIndex + 1) % frameMockupTokens.length;
            const newToken = frameMockupTokens[frameMockupCurrentIndex];
            document.getElementById('frameMockupImage').src = `${MEDIA_BASE}/${CONTRACT}/${newToken}.png`;
            updateFrameMockupInfo(newToken);
            // Also update the main view behind
            loadOutput(newToken, true, false);
        }

        function toggleFrameMockupDarkMode() {
            const frameMockup = document.getElementById('frameMockup');
            const modeBtn = document.getElementById('frameMockupMode');
            frameMockup.classList.toggle('dark-mode');
            if (modeBtn) {
                modeBtn.textContent = frameMockup.classList.contains('dark-mode') ? '\u2600' : '\u263E';
            }
        }

        async function downloadFramedImage() {
            const frameImage = document.getElementById('frameMockupImage');

            // Wait for image to be loaded
            if (!frameImage.complete) {
                showStatus('LOADING...');
                await new Promise(resolve => frameImage.onload = resolve);
            }

            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // 4:5 aspect ratio canvas (like Instagram portrait)
                const canvasWidth = 1600;
                const canvasHeight = 2000;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Light gray/white background
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Load image via fetch+blob to avoid CORS canvas tainting
                const response = await fetch(frameImage.src);
                const blob = await response.blob();
                const img = new Image();
                img.crossOrigin = 'anonymous';

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });

                // Calculate framed image size to fit nicely in 4:5 with margins
                const imgAspect = img.naturalWidth / img.naturalHeight;
                const maxFrameWidth = canvasWidth * 0.7;
                const maxFrameHeight = canvasHeight * 0.75;

                let frameWidth, frameHeight;
                if (imgAspect > maxFrameWidth / maxFrameHeight) {
                    frameWidth = maxFrameWidth;
                    frameHeight = frameWidth / imgAspect;
                } else {
                    frameHeight = maxFrameHeight;
                    frameWidth = frameHeight * imgAspect;
                }

                // Frame dimensions
                const frameThickness = 24;
                const matThickness = 8;
                const totalFrameWidth = frameWidth + (frameThickness + matThickness) * 2;
                const totalFrameHeight = frameHeight + (frameThickness + matThickness) * 2;

                // Center the frame
                const frameX = (canvasWidth - totalFrameWidth) / 2;
                const frameY = (canvasHeight - totalFrameHeight) / 2;

                // Use currently selected frame color
                const dlFrameColors = typeof frameColorMap !== 'undefined' ? frameColorMap : {
                    'light-wood': { frame: '#c4a47a', inner: '#a88b62' },
                    'white': { frame: '#faf9f7', inner: '#4a4846' },
                    'black': { frame: '#1a1a1a', inner: '#0a0a0a' },
                    'dark-wood': { frame: '#5a3d2b', inner: '#3d2a1c' }
                };
                const dlColor = dlFrameColors[typeof currentFrameColor !== 'undefined' ? currentFrameColor : 'light-wood'] || dlFrameColors['light-wood'];

                // Draw shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
                ctx.shadowBlur = 40;
                ctx.shadowOffsetX = 8;
                ctx.shadowOffsetY = 12;

                // Draw outer frame (uses selected color)
                ctx.fillStyle = dlColor.frame;
                ctx.fillRect(frameX, frameY, totalFrameWidth, totalFrameHeight);

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Draw inner mat/border
                ctx.fillStyle = dlColor.inner;
                ctx.fillRect(
                    frameX + frameThickness,
                    frameY + frameThickness,
                    totalFrameWidth - frameThickness * 2,
                    totalFrameHeight - frameThickness * 2
                );

                // Draw the artwork
                ctx.drawImage(img,
                    frameX + frameThickness + matThickness,
                    frameY + frameThickness + matThickness,
                    frameWidth, frameHeight);

                // Download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Cities-by-Efdot-x-Diid-${currentTokenId}-framed.jpg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    URL.revokeObjectURL(img.src);
                    showStatus('FRAMED IMAGE SAVED');
                }, 'image/jpeg', 0.95);

            } catch (e) {
                console.error('Frame download error:', e);
                showStatus('DOWNLOAD FAILED');
            }
        }

        document.getElementById('downloadFramed').addEventListener('click', (e) => {
            e.stopPropagation();
            downloadFramedImage();
        });

        // Frame mockup navigation
        document.getElementById('frameMockupPrev')?.addEventListener('click', (e) => {
            e.stopPropagation();
            frameMockupPrev();
        });
        document.getElementById('frameMockupNext')?.addEventListener('click', (e) => {
            e.stopPropagation();
            frameMockupNext();
        });
        document.getElementById('frameMockupMode')?.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFrameMockupDarkMode();
        });

        // Frame color picker
        const frameColorMap = {
            'light-wood': { frame: '#c4a47a', inner: '#a88b62' },
            'white': { frame: '#faf9f7', inner: '#4a4846' },
            'black': { frame: '#1a1a1a', inner: '#0a0a0a' },
            'dark-wood': { frame: '#5a3d2b', inner: '#3d2a1c' }
        };
        let currentFrameColor = 'light-wood';
        document.querySelectorAll('.frame-color-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.frame-color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFrameColor = btn.dataset.color;
                const wrapper = document.getElementById('frameWrapper');
                const inner = wrapper.querySelector('.frame-inner');
                // Remove any existing frame color classes
                wrapper.classList.remove('frame-white', 'frame-black', 'frame-dark-wood');
                if (currentFrameColor !== 'light-wood') {
                    wrapper.classList.add('frame-' + currentFrameColor);
                }
                // Also set inline for immediate visual feedback
                const colors = frameColorMap[currentFrameColor];
                wrapper.style.background = colors.frame;
                inner.style.background = colors.inner;
            });
        });

        // Order print from frame mockup
        document.getElementById('orderPrint')?.addEventListener('click', (e) => {
            e.stopPropagation();
            const tokenId = frameMockupTokens[frameMockupCurrentIndex] || currentTokenId;
            closeFrameMockup();
            openPrintInquiryModal([tokenId]);
        });

        // Order print from sidebar
        document.getElementById('sidebarOrderPrint')?.addEventListener('click', () => {
            openPrintInquiryModal([currentTokenId]);
        });

        // Close frame mockup when clicking outside the frame
        document.getElementById('frameMockup').addEventListener('click', (e) => {
            if (e.target.id === 'frameMockup' || e.target.classList.contains('frame-mockup-content')) {
                closeFrameMockup();
            }
        });

        // Click on frame/image to open OpenSea offer page
        document.getElementById('frameWrapper')?.addEventListener('click', (e) => {
            e.stopPropagation();
            const tokenId = frameMockupTokens[frameMockupCurrentIndex] || currentTokenId;
            if (tokenId !== undefined) {
                const confirmed = confirm('Taking a detour to opensea.io');
                if (confirmed) {
                    window.open(`https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}`, '_blank');
                }
            }
        });

        function randomFiltered() {
            const matches = getFilteredTokens();
            if (matches.length === 0) { showStatus('NO MATCHES', 'error'); return; }
            const randomToken = matches[Math.floor(Math.random() * matches.length)];
            tokenIdInput.value = randomToken;
            loadOutput(randomToken);
            showStatus(`#${randomToken}`);
        }

        function copyLink() {
            const url = `${window.location.origin}${window.location.pathname}?token=${currentTokenId}`;
            navigator.clipboard.writeText(url).then(() => showStatus('Link copied. Share the view.')).catch(() => {
                prompt('Copy this link:', url);
            });
        }

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            document.body.classList.toggle('fullscreen-mode', isFullscreen);
            // Handle image loading state for smooth fullscreen transition
            if (isFullscreen) {
                // If image is already loaded, show it after a brief delay for smooth transition
                if (previewImage.complete && previewImage.naturalHeight !== 0) {
                    setTimeout(() => previewImage.classList.add('loaded'), 100);
                } else {
                    previewImage.classList.remove('loaded');
                }
            } else {
                previewImage.classList.remove('loaded');
            }
        }

        let exploreTimeout = null;
        let exploreActive = false;
        let isFirstExplore = true;
        const EXPLORE_DELAY_FIRST = 12000; // 12 seconds for first output (after load)
        const EXPLORE_DELAY = 8000; // 8 seconds between subsequent cities

        function exploreNext() {
            if (!exploreActive) return;
            const randomToken = getPreloadedToken();
            tokenIdInput.value = randomToken;
            loadOutput(randomToken);
            isFirstExplore = false;
        }

        function scheduleNextExplore() {
            if (!exploreActive) return;
            const delay = isFirstExplore ? EXPLORE_DELAY_FIRST : EXPLORE_DELAY;
            exploreTimeout = setTimeout(exploreNext, delay);
        }

        // Hook into image load to trigger next explore only after image is ready
        previewImage.addEventListener('load', () => {
            if (exploreActive) {
                // Reset and restart the progress bar animation
                const progressBar = document.querySelector('.explore-progress');
                if (progressBar) {
                    const duration = isFirstExplore ? 12 : 8;
                    progressBar.style.animation = 'none';
                    progressBar.offsetHeight; // Force reflow
                    progressBar.style.animation = `exploreCountdown ${duration}s linear forwards`;
                }
                // Wait a moment after image loads before scheduling next
                setTimeout(() => scheduleNextExplore(), 500);
            }
        });

        function stopExplore() {
            if (!exploreActive) return;
            const btn = document.getElementById('exploreRandom');
            exploreActive = false;
            isFirstExplore = true; // Reset for next time
            document.body.classList.remove('explore-active');
            if (exploreTimeout) { clearTimeout(exploreTimeout); exploreTimeout = null; }
            if (exploreInterval) { clearInterval(exploreInterval); exploreInterval = null; }
            btn.classList.remove('active');
            btn.innerHTML = 'âŸ³ SHUFFLE<span class="explore-progress" aria-hidden="true"></span>';
        }

        function toggleExploreRandom() {
            // Simple random - just pick a random minted token
            const mintedTokens = getFilteredTokens();
            if (mintedTokens.length === 0) {
                showStatus('NO CITIES FOUND');
                return;
            }
            const randomIndex = Math.floor(Math.random() * mintedTokens.length);
            const randomToken = mintedTokens[randomIndex];
            tokenIdInput.value = randomToken;
            loadOutput(randomToken, true, true); // Add to history so back button works
            showStatus('RANDOM #' + randomToken);
            updateNavButtonStates();

            // Scatter droplet animation
            const btn = document.getElementById('exploreRandom');
            if (btn) {
                for (let i = 0; i < 6; i++) {
                    const droplet = document.createElement('span');
                    droplet.className = 'shuffle-droplet';
                    btn.appendChild(droplet);
                }
                setTimeout(() => {
                    btn.querySelectorAll('.shuffle-droplet').forEach(d => d.remove());
                }, 800);
            }
        }

        // Explore fullscreen button - in fullscreen mode, exit to single view
        document.getElementById('exploreFullscreenBtn').addEventListener('click', (e) => {
            // Always prevent click from bubbling to frameContainer (which opens Art Blocks link)
            e.preventDefault();
            e.stopPropagation();

            // If in fullscreen explore mode, exit completely back to single view
            if (isFullscreen && exploreActive) {
                stopExplore();
                isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
                document.getElementById('exploreFullscreenBtn').title = 'Enter Fullscreen';
                showStatus('EXIT');
                return;
            }
            // Normal toggle behavior when not in explore mode
            isFullscreen = !isFullscreen;
            document.body.classList.toggle('fullscreen-mode', isFullscreen);
            document.getElementById('exploreFullscreenBtn').textContent = isFullscreen ? 'â›¶' : 'â›¶';
            document.getElementById('exploreFullscreenBtn').title = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
        });

        // Exit fullscreen on tap (for mobile) - clicking the hint or the image
        document.getElementById('fullscreenExitHint').addEventListener('click', () => {
            if (isFullscreen) {
                if (exploreActive) stopExplore();
                isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
            }
        });

        // Fullscreen swipe navigation for mobile
        let fullscreenTouchStartX = 0;
        let fullscreenTouchStartY = 0;
        let fullscreenTouchStartTime = 0;
        let fullscreenSwiped = false;

        previewImage.addEventListener('touchstart', (e) => {
            if (isFullscreen) {
                fullscreenTouchStartX = e.changedTouches[0].screenX;
                fullscreenTouchStartY = e.changedTouches[0].screenY;
                fullscreenTouchStartTime = Date.now();
                fullscreenSwiped = false;
            }
        }, { passive: true });

        previewImage.addEventListener('touchend', (e) => {
            if (isFullscreen) {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                const diffX = fullscreenTouchStartX - touchEndX;
                const diffY = fullscreenTouchStartY - touchEndY;
                const touchDuration = Date.now() - fullscreenTouchStartTime;
                const swipeThreshold = 50;

                // Check if horizontal swipe (more horizontal than vertical movement)
                if (Math.abs(diffX) > swipeThreshold && Math.abs(diffX) > Math.abs(diffY)) {
                    fullscreenSwiped = true;
                    if (diffX > 0) {
                        // Swipe left - next
                        document.getElementById('nextToken').click();
                    } else {
                        // Swipe right - previous
                        document.getElementById('prevToken').click();
                    }
                }
            }
        }, { passive: true });

        // Also exit fullscreen when tapping the image (not swiping)
        previewImage.addEventListener('click', (e) => {
            if (isFullscreen && !fullscreenSwiped) {
                e.preventDefault();
                e.stopPropagation();
                if (exploreActive) stopExplore();
                isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
            }
            fullscreenSwiped = false;
        });

        // Exit fullscreen or open grid when clicking the black area (main-content background)
        document.querySelector('.main-content')?.addEventListener('click', (e) => {
            // Only trigger if clicking the actual background, not child elements
            if (e.target === e.currentTarget || e.target.classList.contains('main-content')) {
                if (isFullscreen) {
                    if (exploreActive) stopExplore();
                    isFullscreen = false;
                    document.body.classList.remove('fullscreen-mode');
                } else {
                    // In normal mode, clicking black area opens grid view
                    document.getElementById('gridPanel')?.classList.add('open');
                    document.getElementById('viewToggleBtn')?.classList.add('grid-open');
                    document.body.classList.add('grid-open');
                }
            }
        });

        // More outputs feature - curated suggestions based on color relationships
        function getColorBrightness(hex) {
            if (!hex || hex.length < 7) return 128;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return (r * 299 + g * 587 + b * 114) / 1000;
        }

        function getColorSaturation(hex) {
            if (!hex || hex.length < 7) return 0;
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            return max === 0 ? 0 : (max - min) / max;
        }

        function updateSimilarOutputs() {
            const grid = document.getElementById('similarOutputsGrid');
            const traits = tokenTraits[currentTokenId];
            if (!traits) { grid.innerHTML = ''; return; }

            const currentEnergy = traits['Energy'];
            const currentTraffic = traits['Traffic'];

            // Categorize outputs by shared Energy type
            const sameEnergy = [];

            for (let i = 0; i <= MAX_TOKEN; i++) {
                if (i === currentTokenId) continue;
                const t = tokenTraits[i];
                if (!t || !t['Energy']) continue;

                // Only include outputs with the same Energy type
                if (t['Energy'] !== currentEnergy) continue;

                const traffic = t['Traffic'];
                const palette = t['Palette'];

                // Weight: Rush Hour (rare) = 5, Heavy = 3, common traffic = 1
                let weight = 1;
                if (traffic === 'Rush Hour') weight = 5;
                else if (traffic === 'Heavy') weight = 3;

                // Slight boost for different palettes (variety)
                const bg = PALETTE_DATA[palette]?.bg || '#000000';
                const currentBg = PALETTE_DATA[traits['Palette']]?.bg || '#000000';
                if (bg.toLowerCase() !== currentBg.toLowerCase()) {
                    weight += 0.5;
                }

                sameEnergy.push({ id: i, weight, traffic, palette });
            }

            // Weighted random selection helper
            function weightedPick(arr, exclude = []) {
                const filtered = arr.filter(item => !exclude.includes(item.id));
                if (filtered.length === 0) return null;
                const totalWeight = filtered.reduce((sum, item) => sum + item.weight, 0);
                let random = Math.random() * totalWeight;
                for (const item of filtered) {
                    random -= item.weight;
                    if (random <= 0) return item;
                }
                return filtered[filtered.length - 1];
            }

            // Pick 4 outputs with balanced distribution
            const picks = [];
            const usedIds = [];

            // Try to get 1 Rush Hour (rare), 1 Heavy, and 2 commons for variety
            const rushHour = sameEnergy.filter(e => e.traffic === 'Rush Hour');
            const heavy = sameEnergy.filter(e => e.traffic === 'Heavy');
            const common = sameEnergy.filter(e => e.traffic !== 'Rush Hour' && e.traffic !== 'Heavy');

            // Pick rare first (higher priority)
            if (rushHour.length > 0) {
                const pick = weightedPick(rushHour, usedIds);
                if (pick) { picks.push(pick); usedIds.push(pick.id); }
            }

            // Then heavy traffic
            if (heavy.length > 0 && picks.length < 4) {
                const pick = weightedPick(heavy, usedIds);
                if (pick) { picks.push(pick); usedIds.push(pick.id); }
            }

            // Fill with some common outputs
            while (picks.length < 4 && common.length > usedIds.filter(id => common.find(c => c.id === id)).length) {
                const pick = weightedPick(common, usedIds);
                if (pick) { picks.push(pick); usedIds.push(pick.id); }
                else break;
            }

            // If still need more, pick from any remaining
            while (picks.length < 4 && sameEnergy.length > usedIds.length) {
                const pick = weightedPick(sameEnergy, usedIds);
                if (pick) { picks.push(pick); usedIds.push(pick.id); }
                else break;
            }

            // Shuffle the final picks so rare aren't always first
            for (let i = picks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [picks[i], picks[j]] = [picks[j], picks[i]];
            }

            grid.innerHTML = picks.map(s => `
                <div class="similar-output" data-token="${s.id}" title="Output #${s.id} - ${s.traffic || 'Standard'} Traffic">
                    <img src="${getSmallThumbnailUrl(s.id)}" alt="Output ${s.id}" loading="eager" onerror="this.parentElement.style.display='none'">
                    <div class="similar-output-id">#${s.id}</div>
                </div>
            `).join('');

            grid.querySelectorAll('.similar-output').forEach(el => {
                el.addEventListener('click', () => loadOutput(parseInt(el.dataset.token), true, true));
            });

            // Also update sidebar sections
            updateSamePaletteCities();
            updatePairsWellWith();
        }

        // Toggle pairs well with expansion
        document.getElementById('pairsWellLabel')?.addEventListener('click', () => {
            document.getElementById('pairsWellSection').classList.toggle('collapsed');
        });

        // Toggle same palette expansion
        document.getElementById('samePaletteLabel')?.addEventListener('click', () => {
            document.getElementById('samePaletteSection').classList.toggle('collapsed');
        });

        // Same Palette Cities (Neighbors) - other cities with the same palette + owners
        function updateSamePaletteCities() {
            const section = document.getElementById('samePaletteSection');
            const grid = document.getElementById('samePaletteGrid');
            const ownersEl = document.getElementById('samePaletteOwners');
            const traits = tokenTraits[currentTokenId];

            if (!traits || !traits['Palette']) {
                section.style.display = 'none';
                return;
            }

            const currentPalette = traits['Palette'];
            const samePalette = [];
            const otherCollectors = new Set();

            // Build tokenâ†’collector lookup once
            const tokenToCollectorMap = {};
            COLLECTORS_DATA.forEach(c => {
                if (c.tokens) c.tokens.forEach(t => { tokenToCollectorMap[t] = c.name; });
            });
            const currentOwnerName = tokenToCollectorMap[currentTokenId];

            // Find other cities with the same palette and their collectors
            for (let i = 0; i <= MAX_TOKEN; i++) {
                if (i === currentTokenId) continue;
                const t = tokenTraits[i];
                if (t && t['Palette'] === currentPalette) {
                    samePalette.push(i);
                    const collectorName = tokenToCollectorMap[i];
                    if (collectorName && collectorName !== currentOwnerName) {
                        otherCollectors.add(collectorName);
                    }
                }
            }

            if (samePalette.length === 0) {
                section.style.display = 'none';
                return;
            }

            // Show ALL neighbors (no limit)
            grid.innerHTML = samePalette.map(id => `
                <div class="same-palette-item" data-token="${id}">
                    <img src="${getSmallThumbnailUrl(id)}" alt="#${id}" loading="lazy" onerror="this.parentElement.style.display='none'">
                </div>
            `).join('');

            grid.querySelectorAll('.same-palette-item').forEach(el => {
                el.addEventListener('click', () => loadOutput(parseInt(el.dataset.token), true, true)); // Add to history for back button
            });

            // Show other collectors with same palette
            const collectors = [...otherCollectors].slice(0, 6);
            if (collectors.length > 0) {
                ownersEl.innerHTML = collectors.map(name => `<span class="same-palette-owner" data-collector="${name}">${name}</span>`).join(', ');
                ownersEl.style.display = 'block';

                // Add click handlers for collector names
                ownersEl.querySelectorAll('.same-palette-owner').forEach(el => {
                    el.addEventListener('click', () => fetchCollectorTokens(el.dataset.collector));
                });
            } else {
                ownersEl.style.display = 'none';
            }

            // Uncollapse by default when showing neighbors
            section.classList.remove('collapsed');
            section.style.display = 'block';
        }

        // Pairs Well With - complementary/harmonious palettes based on color theory
        function updatePairsWellWith() {
            const section = document.getElementById('pairsWellSection');
            const grid = document.getElementById('pairsWellGrid');
            const traits = tokenTraits[currentTokenId];

            if (!traits) {
                section.style.display = 'none';
                return;
            }

            const currentPalette = traits['Palette'];
            const currentData = PALETTE_DATA[currentPalette];
            if (!currentData || !currentData.bg) {
                section.style.display = 'none';
                return;
            }

            const currentHsl = hexToHsl(currentData.bg);
            const pairs = [];

            // Find complementary, analogous, and triadic palettes
            for (const [name, data] of Object.entries(PALETTE_DATA)) {
                if (name === currentPalette || !data.bg) continue;

                const hsl = hexToHsl(data.bg);
                const hueDiff = Math.abs(hsl.h - currentHsl.h);
                const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);

                let type = null;
                let score = 0;

                // Complementary: ~180Â° apart
                if (normalizedHueDiff >= 150 && normalizedHueDiff <= 210) {
                    type = 'contrast';
                    score = 100 - Math.abs(normalizedHueDiff - 180);
                }
                // Analogous: ~30Â° apart
                else if (normalizedHueDiff <= 40) {
                    type = 'harmony';
                    score = 40 - normalizedHueDiff;
                }
                // Triadic: ~120Â° apart
                else if (normalizedHueDiff >= 100 && normalizedHueDiff <= 140) {
                    type = 'similar';
                    score = 40 - Math.abs(normalizedHueDiff - 120);
                }

                if (type && score > 0) {
                    // Find cities with this palette
                    const citiesWithPalette = Object.entries(tokenTraits)
                        .filter(([id, t]) => t && t['Palette'] === name)
                        .map(([id]) => parseInt(id));
                    if (citiesWithPalette.length > 0) {
                        // Pick a random city from this palette to show as example
                        const exampleCity = citiesWithPalette[Math.floor(Math.random() * citiesWithPalette.length)];
                        pairs.push({ name, type, score, data, exampleCity });
                    }
                }
            }

            // Sort by score and take top 3 (one of each type if possible)
            const contrast = pairs.filter(p => p.type === 'contrast').sort((a, b) => b.score - a.score)[0];
            const harmony = pairs.filter(p => p.type === 'harmony').sort((a, b) => b.score - a.score)[0];
            const similar = pairs.filter(p => p.type === 'similar').sort((a, b) => b.score - a.score)[0];

            const topPairs = [contrast, harmony, similar].filter(Boolean).slice(0, 3);

            if (topPairs.length === 0) {
                section.style.display = 'none';
                return;
            }

            grid.innerHTML = topPairs.map(p => {
                // Truncate palette name if too long, add ellipsis
                const maxLen = 14;
                const paletteName = p.name.length > maxLen ? p.name.substring(0, maxLen) + '...' : p.name;
                return `
                    <div class="pairs-well-item" data-token="${p.exampleCity}" data-palette="${p.name}" title="${p.name}">
                        <div class="pairs-well-thumb">
                            <img src="${getSmallThumbnailUrl(p.exampleCity)}" alt="#${p.exampleCity}" loading="lazy">
                        </div>
                        <div class="pairs-well-info">
                            <span class="pairs-well-id">#${p.exampleCity}</span>
                            <span class="pairs-well-type">${paletteName}</span>
                        </div>
                    </div>
                `;
            }).join('');

            grid.querySelectorAll('.pairs-well-item').forEach(el => {
                el.addEventListener('click', () => {
                    // Navigate to this city's single output view
                    const tokenId = parseInt(el.dataset.token);
                    if (!isNaN(tokenId)) {
                        loadOutput(tokenId);
                    }
                });
            });

            section.style.display = 'block';
        }

        // Color theory helpers
        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return { h: 0, s: 0, l: 0 };

            const r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
                h *= 360;
            }
            return { h, s, l };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Favorite palettes
        let favoritePalettes = JSON.parse(localStorage.getItem('cities-fav-palettes') || '[]');

        function toggleFavoritePalette(palette) {
            const idx = favoritePalettes.indexOf(palette);
            if (idx > -1) {
                favoritePalettes.splice(idx, 1);
            } else {
                favoritePalettes.push(palette);
            }
            localStorage.setItem('cities-fav-palettes', JSON.stringify(favoritePalettes));
            updateGallery(); // Update the favorites panel
        }

        function isPaletteFavorited(palette) {
            return favoritePalettes.includes(palette);
        }

        function addPaletteFavorite(palette) {
            if (!favoritePalettes.includes(palette)) {
                favoritePalettes.push(palette);
                localStorage.setItem('cities-fav-palettes', JSON.stringify(favoritePalettes));
                updateGallery();
                showStatus(`SAVED ${palette.toUpperCase()}`);
            }
        }

        function removePaletteFavorite(palette) {
            const idx = favoritePalettes.indexOf(palette);
            if (idx > -1) {
                favoritePalettes.splice(idx, 1);
                localStorage.setItem('cities-fav-palettes', JSON.stringify(favoritePalettes));
                updateGallery();
                showStatus(`REMOVED ${palette.toUpperCase()}`);
            }
        }

        // Check if a city is favorited
        function isCityFavorited(tokenId) {
            return favorites.some(f => f.tokenId === tokenId);
        }

        // Toggle favorite for a city (from grid)
        function toggleCityFavorite(tokenId, e) {
            if (e) e.stopPropagation();
            const exists = favorites.some(f => f.tokenId === tokenId);
            if (exists) {
                const idx = favorites.findIndex(f => f.tokenId === tokenId);
                favorites.splice(idx, 1);
                showStatus(`REMOVED #${tokenId}`);
            } else {
                favorites.unshift({ id: Date.now(), tokenId: tokenId, timestamp: new Date().toISOString() });
                showStatus(`SAVED #${tokenId}`);
            }
            localStorage.setItem('cities-favorites', JSON.stringify(favorites));
            updateGallery();
            // Update button state if in grid
            const btn = document.querySelector(`.grid-item[data-token="${tokenId}"] .grid-item-fav`);
            if (btn) btn.classList.toggle('favorited', isCityFavorited(tokenId));
            // Update note visibility if this is the current city
            if (tokenId === currentTokenId) {
                updateCityNote();
                updateFavoriteButton();
            }
            // Update collection planner
            if (typeof updateCollectionPlanner === 'function') {
                updateCollectionPlanner();
            }
        }

        // City notes - only visible for favorited cities
        function getCityNote(tokenId) {
            const fav = favorites.find(f => f.tokenId === tokenId);
            return fav?.note || '';
        }

        // Save note for already-favorited city
        function saveCityNote(tokenId, note) {
            const existingIdx = favorites.findIndex(f => f.tokenId === tokenId);
            if (existingIdx < 0) return; // Only save notes for favorited cities

            favorites[existingIdx].note = note;
            localStorage.setItem('cities-favorites', JSON.stringify(favorites));

            const noteContainer = document.getElementById('cityNote');
            noteContainer?.classList.toggle('has-note', !!note.trim());
        }

        function updateCityNote() {
            const noteInput = document.getElementById('cityNoteInput');
            const noteContainer = document.getElementById('cityNote');
            if (!noteInput || !noteContainer) return;
            const isFav = isCityFavorited(currentTokenId);

            // Only show note input for favorited cities
            noteContainer.classList.toggle('visible', isFav);

            if (isFav) {
                const note = getCityNote(currentTokenId);
                noteInput.value = note;
                noteContainer.classList.toggle('has-note', !!note);
            } else {
                noteInput.value = '';
                noteContainer.classList.remove('has-note');
            }
        }

        // Debounce for auto-save - longer delay to avoid issues
        let noteDebounceTimer = null;
        document.getElementById('cityNoteInput')?.addEventListener('input', (e) => {
            clearTimeout(noteDebounceTimer);
            noteDebounceTimer = setTimeout(() => {
                saveCityNote(currentTokenId, e.target.value);
            }, 1500);
        });

        // Save on blur
        document.getElementById('cityNoteInput')?.addEventListener('blur', (e) => {
            clearTimeout(noteDebounceTimer);
            saveCityNote(currentTokenId, e.target.value);
        });

        // Filters toggle
        document.getElementById('filtersToggle').addEventListener('click', () => {
            document.getElementById('filtersSection').classList.toggle('collapsed');
        });

        // Metadata toggle - toggles open/close
        document.getElementById('metadataToggle').addEventListener('click', () => {
            const section = document.getElementById('metadataSection');
            section.classList.toggle('collapsed');
        });

        function updateBackgroundColors(passedTraits) {
            const traits = passedTraits || tokenTraits[currentTokenId];
            if (!traits) { console.log('No traits found for token', currentTokenId); return; }
            const palette = traits['Palette'];
            if (!palette) { console.log('No Palette trait found'); return; }
            const paletteInfo = PALETTE_DATA[palette];
            if (!paletteInfo) { console.log('Palette not found in PALETTE_DATA:', palette); return; }

            const bubble1 = document.querySelector('.bubble-1');
            const bubble2 = document.querySelector('.bubble-2');
            const bubble3 = document.querySelector('.bubble-3');

            if (bubble1 && paletteInfo.colors[0]) bubble1.style.background = paletteInfo.colors[0];
            if (bubble2 && paletteInfo.colors[1]) bubble2.style.background = paletteInfo.colors[1];
            if (bubble3 && paletteInfo.colors[2]) bubble3.style.background = paletteInfo.colors[2];
        }

        // Preload cache for explore mode
        let preloadedImages = [];
        const PRELOAD_COUNT = 8;

        function preloadAdjacentImages() {
            const matches = getFilteredTokens();
            if (matches.length === 0) return;
            const currentIndex = matches.indexOf(currentTokenId);
            if (currentIndex === -1) return;
            const prevToken = currentIndex > 0 ? matches[currentIndex - 1] : matches[matches.length - 1];
            const nextToken = currentIndex < matches.length - 1 ? matches[currentIndex + 1] : matches[0];
            [prevToken, nextToken].forEach(tokenId => {
                if (tokenId !== undefined) {
                    const img = new Image();
                    img.src = getPreviewUrl(tokenId);
                }
            });
        }

        // Curated fullscreen journey - dark to light with deviation, mix of rare and common
        let curatedSequence = [];
        let curatedIndex = 0;

        function buildCuratedSequence() {
            // Group tokens by time of day (dark to light journey)
            const timeOrder = ['Night', 'Dusk', 'Dawn', 'Day'];
            const byTime = { 'Night': [], 'Dusk': [], 'Dawn': [], 'Day': [] };

            Object.entries(tokenTraits).forEach(([id, traits]) => {
                const time = traits['Time of Day'] || 'Day';
                if (byTime[time]) byTime[time].push(parseInt(id));
            });

            // Build sequence: mostly dark-to-light but with some back-and-forth
            const sequence = [];
            const totalCities = 30; // Show about 30 cities in a full journey

            // Weights for each phase (more night at start, more day at end)
            const phases = [
                { weights: [0.6, 0.3, 0.1, 0], count: 6 },    // Start: mostly night
                { weights: [0.4, 0.4, 0.2, 0], count: 5 },    // Transition
                { weights: [0.2, 0.4, 0.3, 0.1], count: 5 },  // Dusk heavy
                { weights: [0.1, 0.3, 0.4, 0.2], count: 5 },  // Dawn emerging
                { weights: [0, 0.2, 0.4, 0.4], count: 5 },    // Light increasing
                { weights: [0, 0.1, 0.3, 0.6], count: 4 },    // End: mostly day
            ];

            phases.forEach(phase => {
                for (let i = 0; i < phase.count; i++) {
                    // Pick time based on weights
                    const rand = Math.random();
                    let cumulative = 0;
                    let selectedTime = 'Day';
                    for (let t = 0; t < timeOrder.length; t++) {
                        cumulative += phase.weights[t];
                        if (rand < cumulative) {
                            selectedTime = timeOrder[t];
                            break;
                        }
                    }

                    const pool = byTime[selectedTime];
                    if (pool && pool.length > 0) {
                        // Pick random from pool, avoid recent duplicates
                        let token;
                        let attempts = 0;
                        do {
                            token = pool[Math.floor(Math.random() * pool.length)];
                            attempts++;
                        } while (sequence.slice(-5).includes(token) && attempts < 10);
                        sequence.push(token);
                    }
                }
            });

            // Shuffle slightly to add natural deviation (swap some adjacent pairs)
            for (let i = 0; i < sequence.length - 1; i++) {
                if (Math.random() < 0.2) { // 20% chance to swap
                    [sequence[i], sequence[i + 1]] = [sequence[i + 1], sequence[i]];
                }
            }

            return sequence;
        }

        function preloadRandomImages() {
            // If user has favorites, show those first (shuffled), then fall back to curated
            const favs = JSON.parse(localStorage.getItem('cities-favorites') || '[]');

            if (favs.length >= 5) {
                // Enough favorites - shuffle and show them
                curatedSequence = [...favs].sort(() => Math.random() - 0.5);
            } else if (favs.length > 0) {
                // Some favorites - mix them into the curated sequence
                const curated = buildCuratedSequence();
                // Insert favorites at intervals throughout the curated sequence
                curatedSequence = [];
                const interval = Math.floor(curated.length / (favs.length + 1));
                let favIndex = 0;
                curated.forEach((token, i) => {
                    if (favIndex < favs.length && i > 0 && i % interval === 0) {
                        curatedSequence.push(favs[favIndex]);
                        favIndex++;
                    }
                    curatedSequence.push(token);
                });
            } else {
                // No favorites - use curated dark-to-light journey
                curatedSequence = buildCuratedSequence();
            }

            curatedIndex = 0;

            // Preload first several images
            preloadedImages = [];
            for (let i = 0; i < Math.min(PRELOAD_COUNT, curatedSequence.length); i++) {
                const token = curatedSequence[i];
                const img = new Image();
                img.src = getPreviewUrl(token);
                preloadedImages.push({ tokenId: token, img });
            }
        }

        function getPreloadedToken() {
            if (curatedSequence.length > 0 && curatedIndex < curatedSequence.length) {
                const token = curatedSequence[curatedIndex];
                curatedIndex++;

                // Preload upcoming image
                if (curatedIndex + PRELOAD_COUNT < curatedSequence.length) {
                    const futureToken = curatedSequence[curatedIndex + PRELOAD_COUNT - 1];
                    const img = new Image();
                    img.src = getPreviewUrl(futureToken);
                }

                // Loop back to start if we reach the end
                if (curatedIndex >= curatedSequence.length) {
                    curatedSequence = buildCuratedSequence();
                    curatedIndex = 0;
                }

                return token;
            }

            // Fallback to random
            const matches = getFilteredTokens();
            return matches[Math.floor(Math.random() * matches.length)];
        }

        function saveLastViewed() {
            localStorage.setItem('cities-last-viewed', currentTokenId.toString());
        }

        function getLastViewed() {
            return parseInt(localStorage.getItem('cities-last-viewed')) || 0;
        }

        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    document.getElementById('nextToken').click();
                } else {
                    document.getElementById('prevToken').click();
                }
            }
        }

        function clearFilters() {
            filterTime.value = ''; filterEnergy.value = ''; filterPalette.value = ''; filterBounds.value = '';
            filterTraffic.value = ''; filterLine.value = ''; filterRender.value = '';
            filterZoom.value = ''; filterWater.value = '';
            // Clear time color picker
            const timeColorGradient = document.getElementById('timeColorGradient');
            if (timeColorGradient) {
                timeColorGradient.classList.remove('active');
                window.timeColorActive = false;
            }
            // Reset dependent filters (restore full palette list)
            updateDependentFilters();
            updateMatchCount();
            try { localStorage.removeItem('cities-filters'); } catch (e) {}
            showStatus('CLEARED');
        }

        function updateGallery() {
            const palettesSection = document.getElementById('favPalettesSection');
            const palettesGrid = document.getElementById('favPalettesGrid');

            // Update total count (cities + palettes)
            const totalFavs = favorites.length + favoritePalettes.length;
            favCount.textContent = totalFavs;

            // Render favorited palettes
            if (favoritePalettes.length > 0) {
                palettesSection.style.display = 'block';
                palettesGrid.innerHTML = favoritePalettes.map(palette => {
                    const paletteInfo = PALETTE_DATA[palette];
                    const bgColor = paletteInfo?.bg || '#333';
                    // Count cities in this palette
                    const paletteTokens = Object.keys(tokenTraits).filter(id => tokenTraits[id]?.Palette === palette);
                    return `<div class="fav-palette-item" data-palette="${palette}">
                        <div class="fav-palette-swatch" style="background: ${bgColor};"></div>
                        <div>
                            <div class="fav-palette-name">${palette}</div>
                            <div class="fav-palette-count">${paletteTokens.length} cities</div>
                        </div>
                        <button class="fav-palette-remove" data-palette="${palette}" title="Remove palette">Ã—</button>
                    </div>`;
                }).join('');

                // Add click handlers - jump to palette in grid view
                palettesGrid.querySelectorAll('.fav-palette-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (e.target.closest('.fav-palette-remove')) return;
                        const palette = item.dataset.palette;
                        galleryPanel.classList.remove('open');
                        jumpToPalette(palette);
                    });
                });
                palettesGrid.querySelectorAll('.fav-palette-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const palette = btn.dataset.palette;
                        toggleFavoritePalette(palette);
                        updateGallery();
                        renderGrid(); // Update grid hearts
                    });
                });
            } else {
                palettesSection.style.display = 'none';
            }

            // Render favorited cities
            if (favorites.length === 0 && favoritePalettes.length === 0) {
                galleryGrid.innerHTML = '<div class="empty-gallery">Nothing here yet. Go explore.</div>';
            } else if (favorites.length === 0) {
                galleryGrid.innerHTML = '<div class="empty-gallery" style="padding: 30px 20px;">Nothing here yet. Go explore.</div>';
            } else {
                galleryGrid.innerHTML = favorites.map((fav, i) => {
                    const thumbUrl = getThumbnailUrl(fav.tokenId);
                    const fullUrl = getPreviewUrl(fav.tokenId);
                    return `<div class="gallery-item"><div class="item-info"><img src="${thumbUrl}" alt="City #${fav.tokenId}" loading="eager" onerror="this.src='${fullUrl}'" style="width:100%;height:100%;object-fit:cover;"><span class="gallery-item-id">#${fav.tokenId}</span></div><div class="item-actions"><button class="load-btn" onclick="loadFavorite(${i})">LOAD</button><button class="delete-btn" onclick="deleteFavorite(${i})">REMOVE</button></div></div>`;
                }).join('');
            }

            // Sync grid-group-fav buttons across grid view
            document.querySelectorAll('.grid-group-fav').forEach(btn => {
                const palette = btn.dataset.palette;
                const isFav = isPaletteFavorited(palette);
                btn.classList.toggle('favorited', isFav);
                btn.textContent = isFav ? 'â™¥' : 'â™¡';
            });

            // Sync palette inspector fav button if open
            const inspectorFavBtn = document.getElementById('pantoneFavBtn');
            if (inspectorFavBtn && inspectorFavBtn.dataset.palette) {
                const isFav = isPaletteFavorited(inspectorFavBtn.dataset.palette);
                inspectorFavBtn.classList.toggle('favorited', isFav);
                inspectorFavBtn.textContent = isFav ? 'â™¥' : 'â™¡';
            }
        }
        // Expose to window for inline onclick
        window.updateGallery = updateGallery;

        window.loadFavorite = function(i) { const fav = favorites[i]; tokenIdInput.value = fav.tokenId; loadOutput(fav.tokenId); galleryPanel.classList.remove('open'); };
        window.deleteFavorite = function(i) { favorites.splice(i, 1); localStorage.setItem('cities-favorites', JSON.stringify(favorites)); updateGallery(); showStatus('REMOVED'); };

        // Enter key on token input loads the city
        tokenIdInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadOutput(parseInt(tokenIdInput.value) || 0);
            }
        });
        document.getElementById('saveFavorite').addEventListener('click', saveFavorite);
        document.getElementById('downloadPng').addEventListener('click', downloadPng);
        document.getElementById('frameViewBtn').addEventListener('click', () => openFrameMockup());
        document.getElementById('closeFrameMockup').addEventListener('click', closeFrameMockup);
        document.getElementById('frameMockupBack')?.addEventListener('click', closeFrameMockup);
        document.getElementById('clearFilters')?.addEventListener('click', clearFilters);

        // Time of Day Color Picker
        const timeColorGradient = document.getElementById('timeColorGradient');
        const timeColorMarker = document.getElementById('timeColorMarker');
        let timeColorActive = false;

        if (timeColorGradient) {
            // Map position to time periods and filter
            // Actual time values: Night, Dawn, Morning, Daylight, Afternoon, Dusk, Evening
            const getTimeFromPosition = (percent) => {
                // Map gradient position to actual time categories from Art Blocks traits
                // Gradient flows: Night â†’ Dawn â†’ Morning â†’ Daylight â†’ Afternoon â†’ Dusk â†’ Evening â†’ Night
                if (percent < 10) return 'Night';
                if (percent < 20) return 'Dawn';
                if (percent < 30) return 'Morning';
                if (percent < 45) return 'Daylight';
                if (percent < 60) return 'Afternoon';
                if (percent < 75) return 'Dusk';
                if (percent < 90) return 'Evening';
                return 'Night';
            };

            const handleTimeColorClick = (e) => {
                const rect = timeColorGradient.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = (x / rect.width) * 100;
                const clampedPercent = Math.max(0, Math.min(100, percent));

                // Position marker
                timeColorMarker.style.left = `${clampedPercent}%`;
                timeColorGradient.classList.add('active');
                timeColorActive = true;

                // Get time period and set filter
                const timePeriod = getTimeFromPosition(clampedPercent);
                const filterTime = document.getElementById('filterTime');
                if (filterTime) {
                    // Find matching option
                    const options = Array.from(filterTime.options);
                    const match = options.find(opt => opt.value.toLowerCase().includes(timePeriod.toLowerCase()));
                    if (match) {
                        filterTime.value = match.value;
                        filterTime.dispatchEvent(new Event('change'));
                    }
                }
            };

            timeColorGradient.addEventListener('click', handleTimeColorClick);

            // Track mouse for marker position on hover
            timeColorGradient.addEventListener('mousemove', (e) => {
                if (!timeColorActive) {
                    const rect = timeColorGradient.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
                    timeColorMarker.style.left = `${percent}%`;
                }
            });
        }
        document.getElementById('copyLink').addEventListener('click', copyLink);
        document.getElementById('exploreRandom').addEventListener('click', toggleExploreRandom);
        document.getElementById('fullscreenBtn')?.addEventListener('click', toggleFullscreen);

        // Update nav button states based on position in minted tokens
        function updateNavButtonStates() {
            // Navigation now wraps around, so buttons are always enabled
            const prevBtn = document.getElementById('prevToken');
            const nextBtn = document.getElementById('nextToken');
            if (prevBtn) {
                prevBtn.disabled = false;
                prevBtn.style.opacity = '1';
            }
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
            }
        }

        document.getElementById('prevToken').addEventListener('click', () => {
            // Use grid navigation list if user came from grid, otherwise use sidebar filters
            const matches = (window.gridNavigationList && window.gridNavigationList.length > 0) ? window.gridNavigationList : getFilteredTokens();
            if (matches.length === 0) return;
            const currentValue = parseInt(tokenIdInput.value) || 0;
            const currentIndex = matches.indexOf(currentValue);

            let newToken;
            if (currentIndex === -1) {
                // Current token not in list - find closest previous token
                const smaller = matches.filter(t => t < currentValue);
                newToken = smaller.length > 0 ? smaller[smaller.length - 1] : matches[matches.length - 1];
            } else if (currentIndex === 0) {
                // At start, wrap to end
                newToken = matches[matches.length - 1];
            } else {
                // Normal: go to previous
                newToken = matches[currentIndex - 1];
            }
            tokenIdInput.value = newToken;
            loadOutput(newToken, true, false);
            updateNavButtonStates();
        });

        document.getElementById('nextToken').addEventListener('click', () => {
            // Use grid navigation list if user came from grid, otherwise use sidebar filters
            const matches = (window.gridNavigationList && window.gridNavigationList.length > 0) ? window.gridNavigationList : getFilteredTokens();
            if (matches.length === 0) return;
            const currentValue = parseInt(tokenIdInput.value) || 0;
            const currentIndex = matches.indexOf(currentValue);

            let newToken;
            if (currentIndex === -1) {
                // Current token not in list - find closest next token
                const larger = matches.filter(t => t > currentValue);
                newToken = larger.length > 0 ? larger[0] : matches[0];
            } else if (currentIndex >= matches.length - 1) {
                // At end, wrap to start
                newToken = matches[0];
            } else {
                // Normal: go to next
                newToken = matches[currentIndex + 1];
            }
            tokenIdInput.value = newToken;
            loadOutput(newToken, true, false);
            updateNavButtonStates();
        });

        // Back to previous output button
        document.getElementById('backToPrevious')?.addEventListener('click', () => {
            if (outputHistory.length > 1) {
                outputHistory.pop(); // Remove current
                const previousToken = outputHistory.pop(); // Get and remove previous (will be re-added)
                if (previousToken !== undefined) {
                    loadOutput(previousToken, true, false);
                }
            }
        });

        // Founding patrons - special collectors highlighted in lists
        const FOUNDING_PATRONS = new Set([
            'selkie', 'willep', 'oblivion', 'valdi', 'simonsays', 'batsoupyum', 'jasmina', 'wsavas', 'diid',
            'georgie', 'blondie23lmd', 'zanzibar', 'redbeard', 'cosimo de medici', 'snowfro',
            'brynbrinkman', 'pinstripedgator', 'rhynotic', 'dave krugman', 'sendrock', 'yungwknd',
            'batz', 'm0dest', 'funghibull', 'alderman', 'healing lens', 'hardart', 'goonie goo goo',
            'elmookador', 'tortita', 'paper buddha', 'sighduck', 'og',
            'defianceworks', 'hjfcfo', 'ryanis', 'soren wrenn', 'shillr'
        ]);

        function isFoundingPatron(name) {
            if (!name) return false;
            const normalized = applyNameAlias(name).toLowerCase();
            return FOUNDING_PATRONS.has(normalized);
        }

        let patronsAutoRevealTimer = null;

        function setupPatronsSection() {
            const patronsSection = document.getElementById('patronsSection');
            const patronsHeader = document.getElementById('patronsHeader');

            if (!patronsSection || !patronsHeader) return;

            // Toggle message on header click
            patronsHeader.addEventListener('click', () => {
                patronsSection.classList.toggle('expanded');
                // Clear auto-reveal timer if manually toggled
                if (patronsAutoRevealTimer) {
                    clearTimeout(patronsAutoRevealTimer);
                    patronsAutoRevealTimer = null;
                }
            });
        }

        function startPatronsAutoReveal() {
            const patronsSection = document.getElementById('patronsSection');
            if (!patronsSection || patronsSection.classList.contains('expanded')) return;

            // Clear any existing timer
            if (patronsAutoRevealTimer) {
                clearTimeout(patronsAutoRevealTimer);
            }

            // Auto-expand after 4 seconds
            patronsAutoRevealTimer = setTimeout(() => {
                if (collectorsPanel.classList.contains('open') && !patronsSection.classList.contains('expanded')) {
                    patronsSection.classList.add('expanded');
                }
            }, 4000);
        }

        function stopPatronsAutoReveal() {
            if (patronsAutoRevealTimer) {
                clearTimeout(patronsAutoRevealTimer);
                patronsAutoRevealTimer = null;
            }
        }

        function openCollectorsPanel() {
            collectorsPanel.classList.add('open');
            galleryPanel.classList.remove('open');
            document.body.classList.add('collectors-open');
            // Start auto-reveal timer for patrons section
            startPatronsAutoReveal();
        }
        function closeCollectorsPanel() {
            collectorsPanel.classList.remove('open');
            document.body.classList.remove('collectors-open');
            // Stop auto-reveal timer
            stopPatronsAutoReveal();
        }
        function toggleCollectorsPanel() {
            if (collectorsPanel.classList.contains('open')) {
                closeCollectorsPanel();
            } else {
                openCollectorsPanel();
            }
        }

        document.getElementById('toggleGallery')?.addEventListener('click', () => { galleryPanel.classList.toggle('open'); closeCollectorsPanel(); updateGallery(); });
        document.getElementById('closeGallery')?.addEventListener('click', () => galleryPanel.classList.remove('open'));
        document.getElementById('galleryTitleClose')?.addEventListener('click', () => galleryPanel.classList.remove('open'));
        document.getElementById('favPalettesToggle')?.addEventListener('click', () => {
            document.getElementById('favPalettesSection')?.classList.toggle('collapsed');
        });
        document.getElementById('toggleCollectors')?.addEventListener('click', toggleCollectorsPanel);
        document.getElementById('sidebarCollectorsBtn')?.addEventListener('click', toggleCollectorsPanel);
        document.getElementById('closeCollectors')?.addEventListener('click', () => {
            // If on guide or leaderboard view, go back to pills view instead of closing
            const guideView = document.getElementById('collectorGuideView');
            const leaderboardView = document.getElementById('leaderboardView');
            if (guideView?.classList.contains('active') || leaderboardView?.classList.contains('active')) {
                showPillsView();
            } else {
                closeCollectorsPanel();
            }
        });
        document.getElementById('collectorsTitle')?.addEventListener('click', closeCollectorsPanel);

        // Collection Planner Modal
        const collectionPlannerModal = document.getElementById('collectionPlannerModal');
        const sidebarCollectionBtn = document.getElementById('sidebarCollectionBtn');
        const collectionPlannerCloseBtn = document.getElementById('collectionPlannerClose');

        if (sidebarCollectionBtn && collectionPlannerModal) {
            sidebarCollectionBtn.addEventListener('click', () => {
                collectionPlannerModal.classList.add('open');
                if (typeof updateCollectionPlanner === 'function') updateCollectionPlanner();
            });
        }
        if (collectionPlannerCloseBtn && collectionPlannerModal) {
            collectionPlannerCloseBtn.addEventListener('click', () => {
                collectionPlannerModal.classList.remove('open');
            });
        }
        if (collectionPlannerModal) {
            collectionPlannerModal.addEventListener('click', (e) => {
                if (e.target === collectionPlannerModal) {
                    collectionPlannerModal.classList.remove('open');
                }
            });
        }

        // Swipe/drag to close panels
        function setupPanelSwipe(panel, direction = 'right') {
            let startX = 0, startY = 0, currentX = 0, isDragging = false;
            let touchStartedOnHandle = false;
            const threshold = 120; // Higher threshold to prevent accidental closes
            const handleZone = 40; // Only trigger from left edge handle area

            panel.addEventListener('touchstart', (e) => {
                // Only allow swipe-to-close if touch started near the left edge (handle area)
                const touch = e.touches[0];
                const rect = panel.getBoundingClientRect();
                const touchOffsetX = touch.clientX - rect.left;

                if (touchOffsetX > handleZone) {
                    touchStartedOnHandle = false;
                    return; // Don't start drag if not near handle
                }

                touchStartedOnHandle = true;
                startX = touch.clientX;
                startY = touch.clientY;
                currentX = startX;
                isDragging = true;
                panel.classList.add('dragging');
            }, { passive: true });

            panel.addEventListener('touchmove', (e) => {
                if (!isDragging || !touchStartedOnHandle) return;
                currentX = e.touches[0].clientX;
                const diffX = currentX - startX;
                const diffY = Math.abs(e.touches[0].clientY - startY);
                // Cancel if vertical movement is too high
                if (diffY > 50) { isDragging = false; panel.style.transform = ''; return; }
                if (direction === 'right' && diffX > 0) {
                    // Use GPU-accelerated transform
                    panel.style.transform = `translateX(${diffX}px)`;
                }
            }, { passive: true });

            panel.addEventListener('touchend', () => {
                panel.classList.remove('dragging');
                if (isDragging && touchStartedOnHandle) {
                    const diffX = currentX - startX;
                    if (direction === 'right' && diffX > threshold) {
                        panel.classList.remove('open');
                        document.body.classList.remove('collectors-open');
                    }
                }
                panel.style.transform = '';
                isDragging = false;
                touchStartedOnHandle = false;
            });

            // Desktop drag from edge handle only - with deliberate click required
            let mouseStartX = 0, mouseIsDragging = false;
            const panelHandle = panel.querySelector('::before') || panel;

            panel.addEventListener('mousedown', (e) => {
                // Only trigger from very narrow handle zone (left 15px)
                if (e.offsetX > 15) return;
                // Ignore if it's from a trackpad gesture (usually has no buttons or button 0 with movement)
                if (e.button !== 0) return;

                mouseStartX = e.clientX;
                mouseIsDragging = true;
                panel.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!mouseIsDragging) return;
                const diffX = e.clientX - mouseStartX;
                if (direction === 'right' && diffX > 0) {
                    panel.style.transform = `translateX(${diffX}px)`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (!mouseIsDragging) return;
                panel.classList.remove('dragging');
                const rect = panel.getBoundingClientRect();
                const shouldClose = rect.left > window.innerWidth - 200;
                if (shouldClose) {
                    panel.classList.remove('open');
                    document.body.classList.remove('collectors-open');
                    // Reset transform after transition completes
                    setTimeout(() => { panel.style.transform = ''; }, 300);
                } else {
                    panel.style.transform = '';
                }
                mouseIsDragging = false;
            });
        }

        setupPanelSwipe(collectorsPanel, 'right');
        setupPanelSwipe(galleryPanel, 'right');

        [filterTime, filterEnergy, filterPalette, filterBounds, filterTraffic, filterLine, filterRender, filterZoom, filterWater].forEach(filter => filter.addEventListener('change', () => {
            // Update dependent filters when Time or Energy changes
            if (filter === filterTime || filter === filterEnergy) {
                updateDependentFilters();
            }
            updateMatchCount();
            // Auto-pause explore when a filter is applied
            if (filter.value) stopExplore();
            // Save filters to localStorage
            saveFiltersToStorage();
            // Update Set Filter button state
            updateSetFilterButton();
        }));

        // Set Filter button functionality
        const setFilterBtn = document.getElementById('setFilterBtn');

        function updateSetFilterButton() {
            const matches = getFilteredTokens();
            const hasFilters = [filterTime, filterEnergy, filterPalette, filterBounds, filterTraffic, filterLine, filterRender, filterZoom, filterWater].some(f => f.value);

            if (!hasFilters) {
                setFilterBtn.textContent = 'SET FILTER';
                setFilterBtn.classList.remove('no-match');
                setFilterBtn.disabled = true;
            } else if (matches.length === 0) {
                setFilterBtn.textContent = 'TRY ANOTHER COMBO';
                setFilterBtn.classList.add('no-match');
                setFilterBtn.disabled = false;
            } else {
                setFilterBtn.textContent = 'SET FILTER';
                setFilterBtn.classList.remove('no-match');
                setFilterBtn.disabled = false;
            }
        }

        setFilterBtn.addEventListener('click', () => {
            const matches = getFilteredTokens();
            if (matches.length > 0) {
                // Pick a random city from matches
                const randomIndex = Math.floor(Math.random() * matches.length);
                const randomCity = matches[randomIndex];
                loadOutput(randomCity);
            }
        });

        // Initialize button state
        updateSetFilterButton();

        function saveFiltersToStorage() {
            const filters = {
                timeOfDay: filterTime.value,
                energy: filterEnergy.value,
                palette: filterPalette.value,
                bounds: filterBounds.value,
                traffic: filterTraffic.value,
                line: filterLine.value,
                render: filterRender.value,
                zoom: filterZoom.value,
                water: filterWater.value
            };
            try { localStorage.setItem('cities-filters', JSON.stringify(filters)); } catch (e) {}
        }

        function loadFiltersFromStorage() {
            try {
                const saved = localStorage.getItem('cities-filters');
                if (saved) {
                    const filters = JSON.parse(saved);
                    if (filters.timeOfDay) filterTime.value = filters.timeOfDay;
                    if (filters.energy) filterEnergy.value = filters.energy;
                    if (filters.palette) filterPalette.value = filters.palette;
                    if (filters.bounds) filterBounds.value = filters.bounds;
                    if (filters.traffic) filterTraffic.value = filters.traffic;
                    if (filters.line) filterLine.value = filters.line;
                    if (filters.render) filterRender.value = filters.render;
                    if (filters.zoom) filterZoom.value = filters.zoom;
                    if (filters.water) filterWater.value = filters.water;
                    updateMatchCount();
                }
            } catch (e) {}
        }

        document.getElementById('toggleShortcuts')?.addEventListener('click', () => {
            const hints = document.getElementById('keyboardHints');
            if (hints) hints.style.display = hints.style.display === 'none' ? 'block' : 'none';
        });

        // Palette inspector
        function getContrastColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            // WCAG relative luminance
            const R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
            const G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
            const B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
            const L = 0.2126 * R + 0.7152 * G + 0.0722 * B;
            return L > 0.179 ? '#000000' : '#ffffff';
        }
        function getContrastShadow(textColor) {
            return textColor === '#ffffff'
                ? '0 1px 3px rgba(0,0,0,0.8), 0 0 1px rgba(0,0,0,0.5)'
                : '0 1px 2px rgba(255,255,255,0.8), 0 0 1px rgba(255,255,255,0.5)';
        }

        // Track palette history for fan navigation
        let paletteHistory = [];
        let currentPaletteIndex = 0;
        let lastInspectorGradientPalette = null;
        let inspectorGradientDragging = false;

        function openPaletteInspector(targetPalette = null) {
            const traits = tokenTraits[currentTokenId];
            const paletteName = targetPalette || (traits ? traits['Palette'] : null);
            if (!paletteName) return;

            const paletteInfo = PALETTE_DATA[paletteName];
            if (!paletteInfo) return;

            // Reset history when opening fresh from the main palette
            if (!targetPalette) {
                paletteHistory = [paletteName];
                currentPaletteIndex = 0;
            }

            const inspector = document.getElementById('paletteInspector');
            const bgColor = paletteInfo.bg;
            const colors = paletteInfo.colors;

            // Set inspector background to match the palette bg with transparency
            const bgR = parseInt(bgColor.slice(1, 3), 16);
            const bgG = parseInt(bgColor.slice(3, 5), 16);
            const bgB = parseInt(bgColor.slice(5, 7), 16);
            inspector.style.background = `rgba(${bgR}, ${bgG}, ${bgB}, 0.92)`;

            // Add light-bg class if background is light for better text contrast
            const luminance = (0.299 * bgR + 0.587 * bgG + 0.114 * bgB) / 255;
            inspector.classList.toggle('light-bg', luminance > 0.5);

            // Render the fan navigation - always show with similar palettes
            const fanEl = document.getElementById('paletteFan');
            const fanContainer = document.getElementById('paletteFanContainer');
            const leftArrow = document.getElementById('fanArrowLeft');
            const rightArrow = document.getElementById('fanArrowRight');

            // If opening fresh (no target), populate history with current + similar palettes
            if (!targetPalette && paletteHistory.length === 1) {
                // Find similar palettes to populate the fan
                const currentColors = new Set([bgColor, ...colors]);
                const similarForFan = [];

                Object.entries(PALETTE_DATA).forEach(([name, info]) => {
                    if (name === paletteName) return;
                    const otherColors = [info.bg, ...info.colors];
                    const shared = otherColors.filter(c => currentColors.has(c)).length;
                    if (shared >= 2) {
                        similarForFan.push({ name, shared });
                    }
                });

                // Sort by most shared and take top 4 to add to fan
                similarForFan.sort((a, b) => b.shared - a.shared);
                const topForFan = similarForFan.slice(0, 4).map(p => p.name);
                paletteHistory = [paletteName, ...topForFan];
                currentPaletteIndex = 0;
            }

            if (paletteHistory.length > 1) {
                // Render only a window of chips around the active one (max 5 visible)
                fanEl.innerHTML = paletteHistory.map((p, idx) => {
                    const pData = PALETTE_DATA[p];
                    const chipBg = pData ? pData.bg : '#333';
                    const offset = idx - currentPaletteIndex;
                    const posClass = (offset >= -2 && offset <= 2) ? `fan-pos-${offset}` : 'fan-hidden';
                    return `<div class="palette-fan-chip ${posClass}" data-palette="${p}" data-index="${idx}" style="background: ${chipBg};"></div>`;
                }).join('');

                fanEl.querySelectorAll('.palette-fan-chip:not(.fan-hidden)').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const palette = chip.dataset.palette;
                        const idx = parseInt(chip.dataset.index);
                        currentPaletteIndex = idx;
                        openPaletteInspector(palette);
                    });
                });

                // Update arrow states based on position in full alphabetical list
                const allNames = Object.keys(PALETTE_DATA).sort((a, b) => a.localeCompare(b));
                const alphaIdx = allNames.findIndex(p => p === paletteName);
                leftArrow.classList.toggle('disabled', alphaIdx <= 0);
                rightArrow.classList.toggle('disabled', alphaIdx >= allNames.length - 1);

                fanContainer.style.display = 'flex';
            } else {
                // Single palette - still show the active chip with navigation arrows
                const pData = PALETTE_DATA[paletteName];
                const chipBg = pData ? pData.bg : '#333';
                fanEl.innerHTML = `<div class="palette-fan-chip fan-pos-0" data-palette="${paletteName}" style="background: ${chipBg};"></div>`;
                const allNames = Object.keys(PALETTE_DATA).sort((a, b) => a.localeCompare(b));
                const alphaIdx = allNames.findIndex(p => p === paletteName);
                leftArrow.classList.toggle('disabled', alphaIdx <= 0);
                rightArrow.classList.toggle('disabled', alphaIdx >= allNames.length - 1);
                fanContainer.style.display = 'flex';
            }

            // Set up floating swatch
            const nameEl = document.getElementById('pantoneName');
            const metaEl = document.getElementById('pantoneMeta');
            const colorsEl = document.getElementById('pantoneColors');
            const hexSection = document.getElementById('pantoneHexSection');

            // Set name with contrasting color
            const textColor = getContrastColor(bgColor);
            nameEl.style.color = textColor;
            nameEl.textContent = paletteName.toUpperCase();

            // Show palette metadata (time, energy, hour)
            const meta = PALETTE_META[paletteName];
            if (meta) {
                metaEl.innerHTML = `
                    <div class="pantone-meta-item">TIME<span>${meta.time}</span></div>
                    <div class="pantone-meta-item">ENERGY<span>${meta.energy}</span></div>
                    <div class="pantone-meta-item">HOUR<span>${meta.hour}</span></div>
                `;
            } else {
                metaEl.innerHTML = '';
            }

            // Segment colors by type
            // Colors array: [Grid1, Grid2, Bold1-4, Subtle1-4, Spot1-2]
            const gridColors = colors.slice(0, 2);
            const boldColors = colors.slice(2, 6);
            const subtleColors = colors.slice(6, 10);
            const spotColors = colors.slice(10, 12);

            function renderPantoneChip(color) {
                const chipTextColor = getContrastColor(color);
                const chipShadow = getContrastShadow(chipTextColor);
                return `<div class="pantone-color-chip" style="background: ${color};" onclick="navigator.clipboard.writeText('${color.toUpperCase()}')">
                    <span class="chip-hex" style="color: ${chipTextColor}; text-shadow: ${chipShadow};">${color.toUpperCase()}</span>
                </div>`;
            }

            function renderCategory(label, colorArr) {
                if (!colorArr || colorArr.length === 0) return '';
                return `
                    <div class="pantone-category">
                        <div class="pantone-category-label">${label}</div>
                        <div class="pantone-color-row">${colorArr.map(c => renderPantoneChip(c)).join('')}</div>
                    </div>
                `;
            }

            colorsEl.innerHTML = `
                ${renderCategory('GRID', gridColors)}
                ${renderCategory('BOLD', boldColors)}
                ${renderCategory('SUBTLE', subtleColors)}
                ${renderCategory('SPOT', spotColors)}
            `;

            // Hex codes section - colored chips
            const allColors = [bgColor, ...colors];
            hexSection.innerHTML = `
                <div class="pantone-category-label">HEX CODES</div>
                <div class="pantone-hex-row">
                    ${allColors.map(c => {
                        const hexTextColor = getContrastColor(c);
                        const hexShadow = getContrastShadow(hexTextColor);
                        return `<span class="pantone-hex-chip" style="background: ${c}; color: ${hexTextColor}; text-shadow: ${hexShadow};" onclick="navigator.clipboard.writeText('${c.toUpperCase()}')">${c.toUpperCase()}</span>`;
                    }).join('')}
                </div>
            `;

            // Build palette suggestions - similar, harmonious, and contrasting
            const similarEl = document.getElementById('paletteInspectorSimilar');
            const currentColors = new Set([bgColor, ...colors]);

            // Helper to get average hue of a palette
            function getAverageHue(bg, cols) {
                const allCols = [bg, ...cols];
                let totalHue = 0;
                allCols.forEach(c => {
                    const r = parseInt(c.slice(1, 3), 16) / 255;
                    const g = parseInt(c.slice(3, 5), 16) / 255;
                    const b = parseInt(c.slice(5, 7), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h = 0;
                    if (max !== min) {
                        const d = max - min;
                        if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                        else if (max === g) h = ((b - r) / d + 2) / 6;
                        else h = ((r - g) / d + 4) / 6;
                    }
                    totalHue += h;
                });
                return totalHue / allCols.length;
            }

            const currentHue = getAverageHue(bgColor, colors);

            // Categorize all other palettes
            const similar = [], harmonious = [], contrasting = [];

            Object.entries(PALETTE_DATA).forEach(([name, info]) => {
                if (name === paletteName) return;
                const otherColors = [info.bg, ...info.colors];
                const shared = otherColors.filter(c => currentColors.has(c)).length;
                const otherHue = getAverageHue(info.bg, info.colors);
                const hueDiff = Math.abs(currentHue - otherHue);
                const hueDistance = Math.min(hueDiff, 1 - hueDiff); // Circular distance

                if (shared >= 2) {
                    similar.push({ name, info, score: shared });
                } else if (hueDistance < 0.15) {
                    // Analogous/harmonious (within 54 degrees)
                    harmonious.push({ name, info, score: 1 - hueDistance });
                } else if (hueDistance > 0.4) {
                    // Contrasting/complementary (144+ degrees apart)
                    contrasting.push({ name, info, score: hueDistance });
                }
            });

            // Sort each category
            similar.sort((a, b) => b.score - a.score);
            harmonious.sort((a, b) => b.score - a.score);
            contrasting.sort((a, b) => b.score - a.score);

            // Build suggestion sections
            let suggestionsHtml = '';

            if (similar.length > 0) {
                const items = similar.slice(0, 4);
                suggestionsHtml += `
                    <div class="palette-suggestions-section">
                        <div class="palette-suggestions-label">Similar</div>
                        <div class="similar-palettes-row">
                            ${items.map(p => {
                                const textColor = getContrastColor(p.info.bg);
                                return `<span class="similar-palette-chip" data-palette="${p.name}" style="background: ${p.info.bg}; color: ${textColor};">${p.name}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            if (harmonious.length > 0) {
                const items = harmonious.slice(0, 4);
                suggestionsHtml += `
                    <div class="palette-suggestions-section">
                        <div class="palette-suggestions-label">Harmonious</div>
                        <div class="similar-palettes-row">
                            ${items.map(p => {
                                const textColor = getContrastColor(p.info.bg);
                                return `<span class="similar-palette-chip" data-palette="${p.name}" style="background: ${p.info.bg}; color: ${textColor};">${p.name}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            if (contrasting.length > 0) {
                const items = contrasting.slice(0, 4);
                suggestionsHtml += `
                    <div class="palette-suggestions-section">
                        <div class="palette-suggestions-label">Contrast</div>
                        <div class="similar-palettes-row">
                            ${items.map(p => {
                                const textColor = getContrastColor(p.info.bg);
                                return `<span class="similar-palette-chip" data-palette="${p.name}" style="background: ${p.info.bg}; color: ${textColor};">${p.name}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // If no suggestions found, show random palettes
            if (!suggestionsHtml) {
                const allPalettes = Object.entries(PALETTE_DATA).filter(([name]) => name !== paletteName);
                const shuffled = allPalettes.sort(() => Math.random() - 0.5).slice(0, 5);
                suggestionsHtml = `
                    <div class="palette-suggestions-section">
                        <div class="palette-suggestions-label">Explore</div>
                        <div class="similar-palettes-row">
                            ${shuffled.map(([name, info]) => {
                                const textColor = getContrastColor(info.bg);
                                return `<span class="similar-palette-chip" data-palette="${name}" style="background: ${info.bg}; color: ${textColor};">${name}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            similarEl.innerHTML = suggestionsHtml;

            // Click to view that palette in the inspector
            similarEl.querySelectorAll('.similar-palette-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const targetPalette = chip.dataset.palette;
                    if (!paletteHistory.includes(targetPalette)) {
                        paletteHistory.push(targetPalette);
                    }
                    currentPaletteIndex = paletteHistory.indexOf(targetPalette);
                    openPaletteInspector(targetPalette);
                });
            });

            // Update favorite button state
            const favBtn = document.getElementById('pantoneFavBtn');
            if (favBtn) {
                const isFav = isPaletteFavorited(paletteName);
                favBtn.classList.toggle('favorited', isFav);
                favBtn.textContent = isFav ? 'â™¥' : 'â™¡';
                favBtn.dataset.palette = paletteName;
            }

            // Reset hex section visibility
            const hexToggle = document.getElementById('pantoneHexToggle');
            if (hexToggle) {
                hexToggle.classList.remove('active');
                hexToggle.textContent = 'Show Hex';
            }
            hexSection.classList.remove('visible');
            colorsEl.classList.remove('hex-visible');

            // Build and position the gradient navigation strip
            const inspStrip = document.getElementById('paletteGradientStrip');
            const inspMarker = document.getElementById('paletteGradientMarker');
            if (inspStrip) {
                // Build gradient once (same day-cycle gradient as the grid)
                if (!inspStrip.dataset.built) {
                    const cssStops = DAY_GRADIENT_STOPS.map(s => {
                        const hex = '#' + [s[1], s[2], s[3]].map(v => v.toString(16).padStart(2, '0')).join('');
                        return `${hex} ${s[0]}%`;
                    });
                    inspStrip.style.background = `linear-gradient(to right, ${cssStops.join(', ')})`;
                    inspStrip.dataset.built = '1';
                }
                // Position marker at current palette's slot on the gradient (skip during scrub)
                if (inspMarker && !inspectorGradientDragging) {
                    const slotPercent = getGradientPercentForPalette(paletteName);
                    inspMarker.style.left = `${slotPercent}%`;
                    inspStrip.classList.add('active');
                }
                lastInspectorGradientPalette = paletteName;
            }

            inspector.classList.add('open');
        }

        window.openPaletteInspector = openPaletteInspector;
        document.getElementById('inspectPalette')?.addEventListener('click', () => openPaletteInspector());
        document.getElementById('closePaletteInspector')?.addEventListener('click', () => {
            document.getElementById('paletteInspector').classList.remove('open');
        });

        // Palette favorite button
        document.getElementById('pantoneFavBtn')?.addEventListener('click', (e) => {
            e.stopPropagation();
            const btn = e.currentTarget;
            const paletteName = btn.dataset.palette;
            if (!paletteName) return;

            const isFav = isPaletteFavorited(paletteName);
            if (isFav) {
                removePaletteFavorite(paletteName);
                btn.classList.remove('favorited');
                btn.textContent = 'â™¡';
            } else {
                addPaletteFavorite(paletteName);
                btn.classList.add('favorited');
                btn.textContent = 'â™¥';
            }
        });

        // Hex codes toggle - transforms circle swatches into pills with hex codes
        document.getElementById('pantoneHexToggle')?.addEventListener('click', (e) => {
            e.stopPropagation();
            const btn = e.currentTarget;
            const colorsContainer = document.getElementById('pantoneColors');
            btn.classList.toggle('active');
            colorsContainer.classList.toggle('hex-visible');
            btn.textContent = btn.classList.contains('active') ? 'Hide Hex' : 'Show Hex';
        });
        document.getElementById('paletteInspector').addEventListener('click', (e) => {
            if (e.target.id === 'paletteInspector') {
                document.getElementById('paletteInspector').classList.remove('open');
            }
        });

        // Palette fan arrow navigation - navigate through all palettes alphabetically
        document.getElementById('fanArrowLeft').addEventListener('click', () => navigatePaletteInList(-1));
        document.getElementById('fanArrowRight').addEventListener('click', () => navigatePaletteInList(1));

        // Palette inspector gradient strip - scrub to navigate by color
        let inspectorGradientRAFPending = false;
        function handleInspectorGradientInteraction(e) {
            const strip = document.getElementById('paletteGradientStrip');
            const marker = document.getElementById('paletteGradientMarker');
            if (!strip) return;
            const rect = strip.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const percent = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            marker.style.left = `${percent}%`;
            strip.classList.add('active');

            // Throttle expensive palette lookup + inspector render to once per frame
            if (!inspectorGradientRAFPending) {
                inspectorGradientRAFPending = true;
                requestAnimationFrame(() => {
                    inspectorGradientRAFPending = false;
                    const bestPalette = getPaletteAtGradientPercent(percent);
                    if (bestPalette && bestPalette !== lastInspectorGradientPalette) {
                        lastInspectorGradientPalette = bestPalette;
                        if (!paletteHistory.includes(bestPalette)) paletteHistory.push(bestPalette);
                        currentPaletteIndex = paletteHistory.indexOf(bestPalette);
                        openPaletteInspector(bestPalette);
                    }
                });
            }
        }
        const paletteGradientStrip = document.getElementById('paletteGradientStrip');
        if (paletteGradientStrip) {
            paletteGradientStrip.addEventListener('mousedown', (e) => {
                inspectorGradientDragging = true;
                handleInspectorGradientInteraction(e);
            });
            paletteGradientStrip.addEventListener('touchstart', (e) => {
                inspectorGradientDragging = true;
                handleInspectorGradientInteraction(e);
            }, { passive: true });
            document.addEventListener('mousemove', (e) => {
                if (inspectorGradientDragging) handleInspectorGradientInteraction(e);
            });
            document.addEventListener('touchmove', (e) => {
                if (inspectorGradientDragging) handleInspectorGradientInteraction(e);
            }, { passive: true });
            document.addEventListener('mouseup', () => { inspectorGradientDragging = false; });
            document.addEventListener('touchend', () => { inspectorGradientDragging = false; });
        }

        // Full palette list navigation (prev/next through all palettes alphabetically)
        const allPaletteNamesSorted = Object.keys(PALETTE_DATA).sort((a, b) => a.localeCompare(b));

        function navigatePaletteInList(direction) {
            const inspector = document.getElementById('paletteInspector');
            if (!inspector.classList.contains('open')) return;

            // Get current palette name from the inspector
            const currentName = document.getElementById('pantoneName')?.textContent;
            if (!currentName) return;

            // Find in sorted list (case-insensitive match)
            const idx = allPaletteNamesSorted.findIndex(p => p.toUpperCase() === currentName);
            if (idx === -1) return;

            const newIdx = idx + direction;
            if (newIdx < 0 || newIdx >= allPaletteNamesSorted.length) return;

            const targetPalette = allPaletteNamesSorted[newIdx];
            // Update fan history to include the new palette
            if (!paletteHistory.includes(targetPalette)) {
                paletteHistory.push(targetPalette);
            }
            currentPaletteIndex = paletteHistory.indexOf(targetPalette);
            openPaletteInspector(targetPalette);
        }

        document.getElementById('paletteNavPrev').addEventListener('click', () => navigatePaletteInList(-1));
        document.getElementById('paletteNavNext').addEventListener('click', () => navigatePaletteInList(1));

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
            switch(e.key.toLowerCase()) {
                case 's': saveFavorite(); break;
                case 'd': downloadPng(); break;
                case 'arrowleft':
                    e.preventDefault();
                    if (document.getElementById('frameMockup')?.classList.contains('open')) {
                        frameMockupPrev();
                    } else if (document.getElementById('wallViewModal')?.classList.contains('open')) {
                        navigateToPrevCollector();
                    } else if (document.getElementById('paletteInspector')?.classList.contains('open')) {
                        navigatePaletteInList(-1);
                    } else if (currentCollectorFilter && document.getElementById('gridPanel')?.classList.contains('open')) {
                        navigateToPrevCollector();
                    } else if (!document.getElementById('gridPanel')?.classList.contains('open')) {
                        document.getElementById('prevToken')?.click();
                    }
                    break;
                case 'arrowright':
                    e.preventDefault();
                    if (document.getElementById('frameMockup')?.classList.contains('open')) {
                        frameMockupNext();
                    } else if (document.getElementById('wallViewModal')?.classList.contains('open')) {
                        navigateToNextCollector();
                    } else if (document.getElementById('paletteInspector')?.classList.contains('open')) {
                        navigatePaletteInList(1);
                    } else if (currentCollectorFilter && document.getElementById('gridPanel')?.classList.contains('open')) {
                        navigateToNextCollector();
                    } else if (!document.getElementById('gridPanel')?.classList.contains('open')) {
                        document.getElementById('nextToken')?.click();
                    }
                    break;
                case 'g': galleryPanel.classList.toggle('open'); collectorsPanel.classList.remove('open'); updateGallery(); break;
                case 'c': collectorsPanel.classList.toggle('open'); galleryPanel.classList.remove('open'); break;
                case 'enter': openFullView(); break;
                case 'f': randomFiltered(); break;
                case 'l': copyLink(); break;
                case ' ': e.preventDefault(); if (!gridPanel.classList.contains('open')) toggleFullscreen(); break;
                case 'escape':
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    // Priority 0: Close about modal
                    if (document.getElementById('aboutModal')?.classList.contains('open')) {
                        document.getElementById('aboutModal').classList.remove('open');
                    }
                    // Priority 1: Close frame mockup (single piece view)
                    else if (document.getElementById('frameMockup').classList.contains('open')) {
                        closeFrameMockup();
                    }
                    // Priority 2: Close wall view modal
                    else if (document.getElementById('wallViewModal').classList.contains('open')) {
                        closeWallView();
                        // After closing wall view, show grid view with collector filter
                        if (currentCollectorFilter) {
                            openGridView();
                        }
                    }
                    // Priority 3: Close palette inspector
                    else if (document.getElementById('paletteInspector').classList.contains('open')) {
                        document.getElementById('paletteInspector').classList.remove('open');
                    }
                    // Priority 4: Exit fullscreen
                    else if (isFullscreen) { toggleFullscreen(); }
                    // Priority 5: In single view from wall, go back to grid (then wall on next escape)
                    else if (window.cameFromWallView && currentCollectorFilter) {
                        window.cameFromWallView = false;
                        openGridView();
                    }
                    // Priority 6: In grid view
                    else if (gridPanel.classList.contains('open')) {
                        if (currentCollectorFilter && enteredCollectorFromTimeline) {
                            clearCollectorFilter(true);
                        } else if (currentCollectorFilter) {
                            // Clear collector filter to show all cities
                            clearCollectorFilter();
                        } else if (isZoomedIn()) {
                            zoomOutToFullGrid();
                        } else {
                            closeGridView();
                        }
                    }
                    // Priority 7: Not in grid, open grid view
                    else { openGridView(); }
                    break;
            }
        });

        // Touch swipe gestures for mobile - on entire main content area
        const mainContent = document.querySelector('.main-content');
        let touchStartY = 0;
        if (mainContent) {
            mainContent.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            mainContent.addEventListener('touchend', (e) => {
                // Don't trigger swipe if sidebar is open or grid is open
                if (sidebar?.classList.contains('open')) return;
                if (gridPanel?.classList.contains('open')) return;
                if (isFullscreen) return; // Fullscreen has its own handler

                touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;

                // Only trigger if horizontal swipe (more horizontal than vertical)
                const swipeThreshold = 50;
                if (Math.abs(diffX) > swipeThreshold && Math.abs(diffX) > Math.abs(diffY) * 1.5) {
                    if (diffX > 0) {
                        document.getElementById('nextToken')?.click();
                    } else {
                        document.getElementById('prevToken')?.click();
                    }
                }
            }, { passive: true });
        }

        window.addEventListener('popstate', () => {
            const params = getUrlParams();
            if (params.token !== null) {
                const tokenId = parseInt(params.token);
                if (!isNaN(tokenId) && tokenId >= 0 && tokenId <= MAX_TOKEN) loadOutput(tokenId, false);
            }
        });

        // ===== Mobile Bottom Bar & Action Sheet =====
        (function initMobileBar() {
            const mobToken = document.getElementById('mobToken');
            const mobSheet = document.getElementById('mobileSheet');
            const mobOverlay = document.getElementById('mobileSheetOverlay');

            // Sync token display
            function syncMobToken() {
                if (mobToken && typeof currentTokenId !== 'undefined') {
                    mobToken.textContent = '#' + currentTokenId;
                }
                // Sync favorite state
                const mobFavBtn = document.getElementById('mobFav');
                if (mobFavBtn && typeof favorites !== 'undefined') {
                    const isFav = favorites.some(f => f.tokenId === currentTokenId);
                    mobFavBtn.classList.toggle('active', isFav);
                    mobFavBtn.textContent = isFav ? 'â¤' : 'â™¡';
                }
                // Sync owner into sheet
                const mobOwner = document.getElementById('mobOwnerDisplay');
                const ownerEl = document.getElementById('ownerDisplay');
                if (mobOwner && ownerEl) {
                    mobOwner.textContent = ownerEl.textContent || '';
                }
            }

            // Observe displayToken changes to sync mobile bar
            const displayTokenEl = document.getElementById('displayToken');
            if (displayTokenEl) {
                const observer = new MutationObserver(syncMobToken);
                observer.observe(displayTokenEl, { childList: true, characterData: true, subtree: true });
            }

            // Sheet toggle
            function openSheet() {
                mobSheet?.classList.add('open');
                mobOverlay?.classList.add('open');
            }
            function closeSheet() {
                mobSheet?.classList.remove('open');
                mobOverlay?.classList.remove('open');
            }

            document.getElementById('mobMore')?.addEventListener('click', () => {
                if (mobSheet?.classList.contains('open')) closeSheet();
                else openSheet();
            });
            mobOverlay?.addEventListener('click', closeSheet);

            // Nav buttons
            document.getElementById('mobPrev')?.addEventListener('click', () => {
                document.getElementById('prevToken')?.click();
            });
            document.getElementById('mobNext')?.addEventListener('click', () => {
                document.getElementById('nextToken')?.click();
            });
            document.getElementById('mobRandom')?.addEventListener('click', () => {
                document.getElementById('exploreRandom')?.click();
            });
            document.getElementById('mobFav')?.addEventListener('click', () => {
                document.getElementById('saveFavorite')?.click();
                setTimeout(syncMobToken, 100);
            });

            // Token tap -> show input
            mobToken?.addEventListener('click', () => {
                const val = prompt('Go to City #', currentTokenId);
                if (val !== null && val !== '') {
                    const num = parseInt(val);
                    if (!isNaN(num)) loadOutput(num);
                }
            });

            // Sheet action buttons
            document.getElementById('mobFullscreen')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('fullscreenBtn')?.click();
            });
            document.getElementById('mobFrame')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('frameViewBtn')?.click();
            });
            document.getElementById('mobDownload')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('downloadPng')?.click();
            });
            document.getElementById('mobPrint')?.addEventListener('click', () => {
                closeSheet();
                if (typeof openPrintInquiryModal === 'function') openPrintInquiryModal([currentTokenId]);
            });
            document.getElementById('mobCopyLink')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('copyLink')?.click();
            });
            document.getElementById('mobOpenSea')?.addEventListener('click', () => {
                closeSheet();
                const osLink = document.getElementById('iconOpenSea');
                if (osLink?.href) window.open(osLink.href, '_blank');
            });
            document.getElementById('mobPalette')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('inspectPalette')?.click();
            });
            document.getElementById('mobFilters')?.addEventListener('click', () => {
                closeSheet();
                // Open the grid view with filters
                if (typeof openGridView === 'function') openGridView();
            });
            document.getElementById('mobGrid')?.addEventListener('click', () => {
                closeSheet();
                if (typeof openGridView === 'function') openGridView();
            });
            document.getElementById('mobCollectors')?.addEventListener('click', () => {
                closeSheet();
                if (typeof openCollectorsPanel === 'function') openCollectorsPanel();
                else document.getElementById('sidebarCollectorsBtn')?.click();
            });
            document.getElementById('mobFavorites')?.addEventListener('click', () => {
                closeSheet();
                document.getElementById('toggleGallery')?.click();
            });
            document.getElementById('mobAbout')?.addEventListener('click', () => {
                closeSheet();
                if (typeof window.toggleAboutModal === 'function') window.toggleAboutModal();
                else if (typeof window.openAboutModal === 'function') window.openAboutModal();
            });

            // Initial sync
            setTimeout(syncMobToken, 500);
        })();

        updateGallery();
        setSize('medium');
        initCollectorsPanel();
        initCollectorGuide();

        // Grid View functionality
        const gridPanel = document.getElementById('gridPanel');
        const gridContent = document.getElementById('gridContent');
        const gridStats = document.getElementById('gridStats');
        const gridPrevPage = document.getElementById('gridPrevPage');
        const gridNextPage = document.getElementById('gridNextPage');
        const gridPageInfo = document.getElementById('gridPageInfo');
        const gridModeBtns = document.querySelectorAll('.grid-mode-btn');

        // Event delegation for grid item clicks (more reliable on mobile)
        if (gridContent) {
            // Handler function for grid item selection
            function handleGridItemSelect(e) {
                // Don't interfere with collector originals - they have their own onclick
                if (e.target.closest('.collector-original-item')) return;

                const gridItem = e.target.closest('.grid-item');
                if (!gridItem) return;
                if (e.target.closest('.grid-item-fav')) return; // Let fav button handle itself

                const tokenId = parseInt(gridItem.dataset.token);
                if (isNaN(tokenId)) return;

                e.stopPropagation();
                e.preventDefault();

                // Check if we're in aspiring collector mode with an active slot
                if (typeof activeSlot !== 'undefined' && activeSlot !== null) {
                    const added = addToAspiringGrid(tokenId);
                    if (added) {
                        // Go back to aspiring view
                        const vtb = document.getElementById('viewToggleBtn');
                        if (gridPanel) gridPanel.classList.remove('open');
                        if (vtb) vtb.classList.remove('grid-open');
                        document.body.classList.remove('grid-open');
                        // Reopen collectors panel to aspiring view
                        const collectorsPanel = document.getElementById('collectorsPanel');
                        if (collectorsPanel) {
                            collectorsPanel.classList.add('open');
                            document.body.classList.add('collectors-open');
                            startPatronsAutoReveal();
                        }
                        showAspiringCollectorView();
                    }
                    return;
                }

                // Close grid and load city
                const vtb = document.getElementById('viewToggleBtn');
                if (gridPanel) gridPanel.classList.remove('open');
                if (vtb) vtb.classList.remove('grid-open');
                document.body.classList.remove('grid-open');

                // Load the selected city
                if (window.loadOutput) {
                    window.loadOutput(tokenId, true);
                }
            }

            // Use both click and touchend for maximum compatibility
            gridContent.addEventListener('click', handleGridItemSelect);

            // Touch handler for mobile - track touch position to avoid triggering on scroll
            let touchStartY = 0;
            let touchStartX = 0;
            gridContent.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }, { passive: true });

            gridContent.addEventListener('touchend', (e) => {
                const touch = e.changedTouches[0];
                if (!touch) return;

                // Only trigger if it wasn't a scroll (moved less than 10px)
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                if (deltaX > 10 || deltaY > 10) return;

                const gridItem = e.target.closest('.grid-item');
                if (!gridItem) return;
                if (e.target.closest('.grid-item-fav')) return;

                const tokenId = parseInt(gridItem.dataset.token);
                if (isNaN(tokenId)) return;

                e.preventDefault();

                // Check if we're in aspiring collector mode with an active slot
                if (typeof activeSlot !== 'undefined' && activeSlot !== null) {
                    const added = addToAspiringGrid(tokenId);
                    if (added) {
                        const vtb = document.getElementById('viewToggleBtn');
                        if (gridPanel) gridPanel.classList.remove('open');
                        if (vtb) vtb.classList.remove('grid-open');
                        document.body.classList.remove('grid-open');
                        const collectorsPanel = document.getElementById('collectorsPanel');
                        if (collectorsPanel) {
                            collectorsPanel.classList.add('open');
                            document.body.classList.add('collectors-open');
                            startPatronsAutoReveal();
                        }
                        showAspiringCollectorView();
                    }
                    return;
                }

                // Close grid and load city
                const vtb = document.getElementById('viewToggleBtn');
                if (gridPanel) gridPanel.classList.remove('open');
                if (vtb) vtb.classList.remove('grid-open');
                document.body.classList.remove('grid-open');

                // Load the selected city
                if (window.loadOutput) {
                    window.loadOutput(tokenId, true);
                }
            });
        }

        document.getElementById('toggleGrid').addEventListener('click', () => {
            openGridView();
        });

        // Click "Cities" title to return to grid
        document.getElementById('sidebarTitle')?.addEventListener('click', () => {
            openGridView();
        });

        // Grid title click - close grid view
        document.getElementById('gridTitle')?.addEventListener('click', () => {
            closeGridView();
        });

        // View toggle button (fixed in top right)
        const viewToggleBtn = document.getElementById('viewToggleBtn');
        function openGridView() {
            const gp = document.getElementById('gridPanel');
            const vtb = document.getElementById('viewToggleBtn');
            if (gp) gp.classList.add('open');
            if (vtb) vtb.classList.add('grid-open');
            document.body.classList.add('grid-open');
            // Clear stale grid navigation - will be recaptured on next grid click
            window.gridNavigationList = null;
            populateGridFilters();
            renderGrid();
        }
        window.openGridView = openGridView;

        function closeGridView() {
            gridPanel.classList.remove('open');
            viewToggleBtn.classList.remove('grid-open');
            document.body.classList.remove('grid-open');
            // Save collector context so we can restore it when re-opening
            if (currentCollectorFilter) {
                sessionStorage.setItem('cities-gallery-context', JSON.stringify(currentCollectorFilter));
            }
            // If no city loaded yet (first time clicking X), load the current or rarest city
            if (!previewImage.src || previewImage.src === window.location.href) {
                if (currentTokenId > 0) {
                    loadOutput(currentTokenId);
                } else {
                    const rarestToken = getRarestToken();
                    if (rarestToken) {
                        loadOutput(rarestToken);
                    }
                }
            }
        }
        viewToggleBtn.addEventListener('click', () => {
            if (gridPanel.classList.contains('open')) {
                closeGridView();
            } else {
                // Check if we should return to collector gallery context
                if (typeof returnToCollectorGallery === 'function' && returnToCollectorGallery()) {
                    return; // Successfully returned to collector view
                }
                openGridView();
            }
        });

        // Jump to a specific palette in grid view
        function jumpToPalette(paletteName) {
            // Make sure we're in "by palette" mode
            document.querySelector('.grid-mode-btn[data-mode="palette"]')?.click();

            // Open grid view if not already open
            if (!gridPanel.classList.contains('open')) {
                openGridView();
            }

            // Wait for render, then scroll to the palette
            setTimeout(() => {
                const paletteGroup = gridContent.querySelector(`.grid-group[data-palette="${paletteName}"]`);
                if (paletteGroup) {
                    // Expand if collapsed
                    paletteGroup.classList.remove('collapsed');
                    // Scroll into view
                    paletteGroup.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }

        // Mobile filter toggle
        const filterToggleBar = document.getElementById('filterToggleBar');
        const gridFilterBar = document.getElementById('gridFilterBar');
        filterToggleBar.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close gradient picker if open
            if (colorGradientActive) {
                toggleColorGradient();
            }
            filterToggleBar.classList.toggle('open');
            gridFilterBar.classList.toggle('open');
        });

        // Title hover animation - text breaks apart on long hover
        // Open grid view by default on page load
        function openGridOnLoad() {
            openGridView();
            // Update active button to show palette is selected
            const btns = document.querySelectorAll('.grid-mode-btn');
            btns.forEach(b => b.classList.remove('active'));
            document.querySelector('[data-mode="palette"]')?.classList.add('active');
        }

        // Palette/Color/A-Z/Rarity toggle button
        const paletteColorToggle = document.getElementById('paletteColorToggle');
        let paletteColorState = 'palette'; // toggles between 'palette', 'gradient', 'collector', 'az'
        const toggleStates = {
            palette: { next: 'gradient', text: 'BY PALETTE', color: 'var(--warm)' },
            gradient: { next: 'collector', text: 'BY COLOR', color: 'var(--warm)' },
            collector: { next: 'az', text: 'BY COLLECTOR', color: 'var(--warm)' },
            az: { next: 'palette', text: 'A-Z', color: 'var(--warm)' }
        };

        function updateToggleStyle() {
            const state = toggleStates[paletteColorState];
            paletteColorToggle.dataset.mode = paletteColorState === 'gradient' ? 'gradient' : paletteColorState;
            paletteColorToggle.style.borderColor = state.color;
            paletteColorToggle.style.color = state.color;

            if (paletteColorState === 'palette') {
                paletteColorToggle.dataset.emoji = 'ðŸŽ¨';
                paletteColorToggle.innerHTML = 'BY PALETTE <span class="palette-sort-arrow">â†“</span>';
            } else if (paletteColorState === 'gradient') {
                paletteColorToggle.dataset.emoji = 'gradient';
                paletteColorToggle.innerHTML = '<span class="mode-gradient-dot"></span> BY COLOR';
            } else if (paletteColorState === 'collector') {
                paletteColorToggle.dataset.emoji = 'ðŸ‘¥';
                paletteColorToggle.textContent = 'BY COLLECTOR';
            } else if (paletteColorState === 'az') {
                paletteColorToggle.dataset.emoji = 'az';
                paletteColorToggle.innerHTML = '<span class="mode-az-label"><span style="color:#FFD93D;font-weight:900">A</span><span style="color:#FF6B6B;font-weight:900">-</span><span style="color:#4D96FF;font-weight:900">Z</span></span>';
            }
        }

        gridModeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.id === 'gridCollectorsBtn' || btn.id === 'gridAllFavBtn' || btn.id === 'gridOriginsBtn') return; // Handled separately
                if (btn.id === 'paletteColorToggle') {
                    // Cycle through palette -> gradient -> collector -> az -> palette
                    paletteColorState = toggleStates[paletteColorState].next;
                    updateToggleStyle();
                }
                gridModeBtns.forEach(b => { if (!b.classList.contains('collectors-btn') && b.id !== 'gridAllFavBtn' && b.id !== 'gridOriginsBtn') b.classList.remove('active'); });
                // Also remove active from origins button when switching to other modes
                document.getElementById('gridOriginsBtn')?.classList.remove('active');
                btn.classList.add('active');
                gridMode = btn.dataset.mode;
                gridPage = 1;

                // Handle gradient mode transitions
                if (paletteColorState === 'gradient') {
                    // Entering gradient mode - activate color gradient
                    if (!colorGradientActive) {
                        // Ensure filter bar is open so gradient bar is visible
                        if (!gridFilterBar.classList.contains('open')) {
                            filterToggleBar.classList.add('open');
                            gridFilterBar.classList.add('open');
                        }
                        toggleColorGradient();
                    }
                } else {
                    // Leaving gradient or in non-gradient mode - deactivate
                    if (typeof deactivateColorGradient === 'function') deactivateColorGradient();
                    // Close filter bar when switching away from gradient mode
                    filterToggleBar.classList.remove('open');
                    gridFilterBar.classList.remove('open');
                }

                // Clear collector filter when switching modes (hide the banner)
                if (currentCollectorFilter) {
                    currentCollectorFilter = null;
                    enteredCollectorFromTimeline = false;
                    document.getElementById('collectorBanner').classList.remove('visible');
                }

                renderGrid();
            });
        });

        // Grid size toggle - cycles from small to large (zoom in effect)
        // Reversed order: starts at responsive (6, 8, or 11 based on width), zooms in to 2-col (largest view)
        // 2-col is the max zoom - use single output view for individual cities
        const sizeModes = ['auto', '12-col', '11-col', '8-col', '6-col', '4-col', '3-col', '2-col'];
        const sizeIcons = ['size-auto', 'size-12', 'size-10', 'size-8', 'size-6', 'size-4', 'size-3', 'size-2'];

        // Always start with 12-col (zoomed out, many thumbnails)
        function getResponsiveGridSize() {
            return '12-col';
        }

        // Initialize with 12-col (zoomed out)
        let gridSize = '12-col';
        let gridSizeIndex = 1; // 12-col is second in sizeModes

        function updateSizeIcon() {
            const icon = document.getElementById('sizeIcon');
            const sizeClass = sizeIcons[gridSizeIndex];
            icon.className = 'size-icon ' + sizeClass;

            // Generate <b> elements based on grid pattern
            let count = 1;
            if (['size-2', 'size-3', 'size-4'].includes(sizeClass)) count = 4;      // 2x2
            else if (['size-6', 'size-8'].includes(sizeClass)) count = 9;            // 3x3
            else if (['size-10', 'size-12', 'size-auto'].includes(sizeClass)) count = 16; // 4x4

            icon.innerHTML = '<b></b>'.repeat(count);
        }

        // On mobile, only cycle through sizes that produce visually distinct layouts
        const mobileSizeModes = ['12-col', '3-col', '2-col'];

        function isMobileView() {
            return window.innerWidth <= 768;
        }

        document.getElementById('gridSizeToggle').addEventListener('click', () => {
            const oldSize = gridSize;

            if (isMobileView()) {
                // On mobile, many sizes map to the same column count, so only cycle distinct ones
                let mobileIndex = mobileSizeModes.indexOf(gridSize);
                if (mobileIndex === -1) mobileIndex = 0;
                mobileIndex = (mobileIndex + 1) % mobileSizeModes.length;
                gridSize = mobileSizeModes[mobileIndex];
                gridSizeIndex = sizeModes.indexOf(gridSize);
            } else {
                gridSizeIndex = (gridSizeIndex + 1) % sizeModes.length;
                gridSize = sizeModes[gridSizeIndex];
            }

            updateSizeIcon();

            // Just update CSS classes instead of full re-render for performance
            const gridContainers = gridContent.querySelectorAll('.grid-items, .grid-group-items, .origins-group-items');
            if (gridContainers.length > 0) {
                gridContainers.forEach(container => {
                    container.classList.remove('grid-' + oldSize);
                    container.classList.add('grid-' + gridSize);
                });
            } else {
                renderGrid();
            }
        });

        updateSizeIcon();

        // Grid sort toggle
        document.getElementById('gridSortToggle').addEventListener('click', () => {
            gridSortOrder = gridSortOrder === 'desc' ? 'asc' : 'desc';
            const btn = document.getElementById('gridSortToggle');
            btn.classList.toggle('sort-desc', gridSortOrder === 'desc');
            btn.innerHTML = gridSortOrder === 'desc' ? 'NEW <span class="sort-arrow">â†‘</span>' : 'OLD <span class="sort-arrow">â†“</span>';
            renderGrid();
        });

        // Grid numbers toggle
        document.getElementById('gridNumbersToggle')?.addEventListener('click', () => {
            const btn = document.getElementById('gridNumbersToggle');
            const gridPanel = document.getElementById('gridPanel');
            btn.classList.toggle('active');
            gridPanel.classList.toggle('hide-numbers');
        });

        // Energy clock - displays current energy based on user's timezone
        // Dawn (Rising): 5am-9am, Day (Living): 9am-5pm, Dusk (Fading): 5pm-9pm, Night (Resting): 9pm-5am
        function getCurrentEnergy() {
            const hour = new Date().getHours();
            // 4 distinct city icons for each energy state
            if (hour >= 5 && hour < 9) return { name: 'Rising', icon: '\u{1F305}', cityIcon: '\u{1F307}', iconColor: '#ffb347', className: 'energy-rising' };   // Dawn/sunrise â†’ ðŸŒ‡
            if (hour >= 9 && hour < 17) return { name: 'Living', icon: '\u2600', cityIcon: '\u{1F3D9}\uFE0F', iconColor: '#87ceeb', className: 'energy-living' };  // Day/sun â†’ ðŸ™ï¸
            if (hour >= 17 && hour < 21) return { name: 'Fading', icon: '\u{1F306}', cityIcon: '\u{1F306}', iconColor: '#dda0dd', className: 'energy-fading' }; // Dusk/sunset â†’ ðŸŒ†
            return { name: 'Resting', icon: '\u{1F319}', cityIcon: '\u{1F303}', iconColor: '#4a5568', className: 'energy-resting' };                            // Night/moon â†’ ðŸŒƒ
        }

        function updateEnergyClock() {
            const energy = getCurrentEnergy();
            const btn = document.getElementById('gridEnergyToggle');
            if (btn) {
                btn.className = 'grid-energy-clock ' + energy.className;
                btn.innerHTML = `<span class="energy-icon">${energy.icon}</span>`;
                btn.title = `${energy.name} (${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})})`;
            }
            // Update top-left city emoji clock
            const clockEl = document.getElementById('gridClock');
            if (clockEl) {
                const timeStr = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                clockEl.innerHTML = `<span class="clock-emoji">${energy.cityIcon}</span><span class="clock-time">${timeStr}</span>`;
            }
        }

        // Initialize and update every minute
        updateEnergyClock();
        setInterval(updateEnergyClock, 60000);

        // Check if grid is zoomed in (showing 2-4 columns = large view)
        function isZoomedIn() {
            return ['2-col', '3-col', '4-col'].includes(gridSize);
        }

        // Zoom out to full grid view (10-12 columns based on screen width)
        function zoomOutToFullGrid() {
            const oldSize = gridSize;
            const w = window.innerWidth;
            // Set to zoomed out view based on screen width
            if (w >= 1600) {
                gridSize = '12-col';
                gridSizeIndex = sizeModes.indexOf('12-col');
            } else if (w >= 1200) {
                gridSize = '11-col';
                gridSizeIndex = sizeModes.indexOf('11-col');
            } else {
                gridSize = '8-col';
                gridSizeIndex = sizeModes.indexOf('8-col');
            }
            updateSizeIcon();

            // Update CSS classes
            const gridContainers = gridContent.querySelectorAll('.grid-items, .grid-group-items');
            if (gridContainers.length > 0) {
                gridContainers.forEach(container => {
                    container.classList.remove('grid-' + oldSize);
                    container.classList.add('grid-' + gridSize);
                });
            } else {
                renderGrid();
            }
        }

        // Collectors button in grid
        document.getElementById('gridCollectorsBtn').addEventListener('click', () => {
            toggleCollectorsPanel();
            document.getElementById('gridStatsBar').classList.toggle('visible');
        });

        // Origins button in grid
        const gridOriginsBtn = document.getElementById('gridOriginsBtn');
        if (gridOriginsBtn) {
            gridOriginsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Open the timeline directly (user's preferred default)
                if (window.openTimeline) window.openTimeline();
            });
        }

        // ALL/FAVS toggle button
        const gridAllFavBtn = document.getElementById('gridAllFavBtn');
        if (gridAllFavBtn) {
            gridAllFavBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showingFavoritesOnly = !showingFavoritesOnly;
                // Show current state as button label + update emoji for mobile
                gridAllFavBtn.textContent = showingFavoritesOnly ? 'FAVS' : 'ALL';
                gridAllFavBtn.dataset.emoji = showingFavoritesOnly ? 'â¤ï¸' : 'ðŸŒ';
                gridAllFavBtn.classList.toggle('favorites-active', showingFavoritesOnly);
                gridPage = 1;
                renderGrid();
            });
        }

        // Multi-select dropdown functionality
        function setupMultiSelect(containerId, filterKey, label) {
            const container = document.getElementById(containerId);
            const btn = container.querySelector('.multi-select-btn');
            const dropdown = container.querySelector('.multi-select-dropdown');

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Close other dropdowns
                document.querySelectorAll('.multi-select.open').forEach(ms => {
                    if (ms !== container) ms.classList.remove('open');
                });
                container.classList.toggle('open');
            });

            dropdown.addEventListener('click', (e) => e.stopPropagation());
        }

        function populateMultiSelect(containerId, filterKey, valueCounts, label) {
            const container = document.getElementById(containerId);
            const dropdown = container.querySelector('.multi-select-dropdown');
            const btn = container.querySelector('.multi-select-btn');
            const sortedValues = Object.keys(valueCounts).sort();

            dropdown.innerHTML = `
                <label class="multi-select-item select-all">
                    <input type="checkbox" checked> <span class="select-all-text">DESELECT ALL</span>
                </label>
                ${sortedValues.map(v => {
                    const count = valueCounts[v];
                    const pct = totalMinted > 0 ? Math.round((count / totalMinted) * 100) : 0;
                    // Add color swatch for palette filter
                    let swatchHtml = '';
                    if (filterKey === 'palettes' && PALETTE_DATA[v]) {
                        const bg = PALETTE_DATA[v].bg;
                        const colors = PALETTE_DATA[v].colors.slice(0, 4);
                        swatchHtml = `<span class="multi-select-swatch" style="background:${bg}">${colors.map(c => `<span style="background:${c}"></span>`).join('')}</span>`;
                    }
                    return `
                    <label class="multi-select-item">
                        <input type="checkbox" value="${v}" checked>
                        ${swatchHtml}
                        <span class="multi-select-label">${v.toUpperCase()}</span>
                        <span class="multi-select-count">${count} (${pct}%)</span>
                    </label>
                `}).join('')}
            `;

            // Initialize state with all values selected
            gridFilterState[filterKey] = new Set(sortedValues);

            const selectAllCheckbox = dropdown.querySelector('.select-all input');
            const selectAllText = dropdown.querySelector('.select-all-text');
            const itemCheckboxes = dropdown.querySelectorAll('.multi-select-item:not(.select-all) input');

            function updateSelectAllText() {
                const allSelected = gridFilterState[filterKey].size === sortedValues.length;
                selectAllText.textContent = allSelected ? 'DESELECT ALL' : 'SELECT ALL';
            }

            selectAllCheckbox.addEventListener('change', () => {
                const checked = selectAllCheckbox.checked;
                itemCheckboxes.forEach(cb => {
                    cb.checked = checked;
                    if (checked) gridFilterState[filterKey].add(cb.value);
                    else gridFilterState[filterKey].delete(cb.value);
                });
                updateSelectAllText();
                updateMultiSelectBtn(btn, gridFilterState[filterKey], sortedValues.length, label);
                gridPage = 1; renderGrid();
                if (gridFilterState[filterKey].size < sortedValues.length) stopExplore();
            });

            itemCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    // When user clicks to SELECT an item while all are currently selected,
                    // deselect the others (starting to filter = single-select behavior)
                    const allCurrentlySelected = gridFilterState[filterKey].size === sortedValues.length;
                    if (cb.checked && allCurrentlySelected) {
                        // User is starting to filter - deselect all others
                        itemCheckboxes.forEach(otherCb => {
                            if (otherCb !== cb) {
                                otherCb.checked = false;
                                gridFilterState[filterKey].delete(otherCb.value);
                            }
                        });
                    }

                    if (cb.checked) gridFilterState[filterKey].add(cb.value);
                    else gridFilterState[filterKey].delete(cb.value);
                    selectAllCheckbox.checked = gridFilterState[filterKey].size === sortedValues.length;
                    updateSelectAllText();
                    updateMultiSelectBtn(btn, gridFilterState[filterKey], sortedValues.length, label);
                    gridPage = 1; renderGrid();
                    if (gridFilterState[filterKey].size < sortedValues.length) stopExplore();
                });
            });

            updateMultiSelectBtn(btn, gridFilterState[filterKey], sortedValues.length, label);
        }

        function updateMultiSelectBtn(btn, selectedSet, totalCount, label) {
            const count = selectedSet.size;
            if (count === 0) {
                btn.innerHTML = `NONE <span class="arrow">â–¼</span>`;
                btn.classList.add('has-selection');
            } else if (count === totalCount) {
                btn.innerHTML = `${label} <span class="arrow">â–¼</span>`;
                btn.classList.remove('has-selection');
            } else {
                btn.innerHTML = `${count} ${label} <span class="arrow">â–¼</span>`;
                btn.classList.add('has-selection');
            }
        }

        // Reset all grid filters to default (all selected)
        function resetGridFilters() {
            // Re-setup all multi-selects to reset them
            setupMultiSelect('paletteMultiSelect', 'palettes', 'PALETTES');
            setupMultiSelect('timeMultiSelect', 'times', 'TIMES');
            setupMultiSelect('energyMultiSelect', 'energy', 'ENERGY');
            setupMultiSelect('zoomMultiSelect', 'zooms', 'ZOOMS');
            setupMultiSelect('boundsMultiSelect', 'bounds', 'BOUNDS');
            setupMultiSelect('trafficMultiSelect', 'traffic', 'TRAFFIC');
            // Uncheck water filter
            document.getElementById('gridWaterFilter').checked = false;
            // Close color gradient if active
            deactivateColorGradient();
            gridPage = 1;
            renderGrid();
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', () => {
            document.querySelectorAll('.multi-select.open').forEach(ms => ms.classList.remove('open'));
        });

        // Setup multi-selects
        setupMultiSelect('paletteMultiSelect', 'palettes', 'PALETTES');
        setupMultiSelect('timeMultiSelect', 'times', 'TIMES');
        setupMultiSelect('energyMultiSelect', 'energy', 'ENERGY');
        setupMultiSelect('zoomMultiSelect', 'zooms', 'ZOOMS');
        setupMultiSelect('boundsMultiSelect', 'bounds', 'BOUNDS');
        setupMultiSelect('trafficMultiSelect', 'traffic', 'TRAFFIC');

        document.getElementById('gridWaterFilter').addEventListener('change', () => { gridPage = 1; renderGrid(); if (document.getElementById('gridWaterFilter').checked) stopExplore(); });
        gridPrevPage.addEventListener('click', () => { if (gridPage > 1) { gridPage--; renderGrid(); } });
        gridNextPage.addEventListener('click', () => { gridPage++; renderGrid(); });

        // === Color Gradient Slider for Grid View ===
        const colorGradientToggle = document.getElementById('gridColorGradientToggle');
        const colorGradientBar = document.getElementById('gridColorGradientBar');
        const colorGradientStrip = document.getElementById('gridColorGradientStrip');
        const colorGradientMarker = document.getElementById('gridColorGradientMarker');
        const colorGradientClose = document.getElementById('gridColorGradientClose');
        const colorGradientHint = document.getElementById('gridColorGradientHint');
        const colorGradientClock = document.getElementById('gridColorGradientClock');
        const gradientStepToggle = document.getElementById('gradientStepToggle');
        let colorGradientActive = false;
        let colorGradientDragging = false;
        let colorGradientStepped = false; // false = smooth, true = stepped
        let savedFilterState = null; // Store original filter state to restore
        let gradientTargetColor = null; // Store target color for sorting by proximity

        // Day-cycle gradient stops: midnight â†’ dawn â†’ midday â†’ dusk â†’ midnight
        const DAY_GRADIENT_STOPS = [
            [0,   0x0a, 0x0a, 0x1a], [4,   0x0d, 0x10, 0x30], [8,   0x1a, 0x15, 0x45],
            [12,  0x2a, 0x1f, 0x5c], [16,  0x3d, 0x2a, 0x6e], [19,  0x5c, 0x3d, 0x7a],
            [22,  0x8b, 0x5e, 0x6b], [25,  0xc4, 0x7a, 0x4a], [28,  0xe8, 0xa6, 0x35],
            [31,  0xf0, 0xc0, 0x40], [35,  0xf5, 0xd8, 0x70], [39,  0xfa, 0xe8, 0xa0],
            [43,  0xff, 0xf5, 0xd6], [47,  0xff, 0xfb, 0xe8], [50,  0xff, 0xff, 0xff],
            [53,  0xff, 0xf8, 0xe0], [57,  0xff, 0xe8, 0xb0], [61,  0xff, 0xd0, 0x80],
            [65,  0xf0, 0xa8, 0x48], [69,  0xe8, 0x80, 0x30], [72,  0xd0, 0x5a, 0x28],
            [75,  0xa8, 0x3a, 0x30], [78,  0x7a, 0x2a, 0x50], [81,  0x5c, 0x20, 0x60],
            [84,  0x3d, 0x1a, 0x5c], [88,  0x2a, 0x15, 0x50], [92,  0x1a, 0x10, 0x40],
            [96,  0x0d, 0x0d, 0x30], [100, 0x0a, 0x0a, 0x1a]
        ];

        // Interpolate the day-cycle gradient to get RGB at any percent, then convert to HSL
        function getGradientColorAtPercent(percent) {
            const p = Math.max(0, Math.min(100, percent));
            // Find surrounding stops
            let lo = DAY_GRADIENT_STOPS[0], hi = DAY_GRADIENT_STOPS[DAY_GRADIENT_STOPS.length - 1];
            for (let i = 0; i < DAY_GRADIENT_STOPS.length - 1; i++) {
                if (p >= DAY_GRADIENT_STOPS[i][0] && p <= DAY_GRADIENT_STOPS[i + 1][0]) {
                    lo = DAY_GRADIENT_STOPS[i]; hi = DAY_GRADIENT_STOPS[i + 1]; break;
                }
            }
            const t = lo[0] === hi[0] ? 0 : (p - lo[0]) / (hi[0] - lo[0]);
            const r = (lo[1] + t * (hi[1] - lo[1])) / 255;
            const g = (lo[2] + t * (hi[2] - lo[2])) / 255;
            const b = (lo[3] + t * (hi[3] - lo[3])) / 255;
            // RGB to HSL
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                else if (max === g) h = ((b - r) / d + 2) / 6;
                else h = ((r - g) / d + 4) / 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function buildColorGradient() {
            if (colorGradientStepped) {
                // Stepped mode: discrete blocks, one per palette, using bg colors
                buildPaletteGradientSlots();
                const n = paletteGradientSlots.length;
                const stops = [];
                for (let i = 0; i < n; i++) {
                    const color = PALETTE_DATA[paletteGradientSlots[i].name].bg;
                    const start = (i / n) * 100;
                    const end = ((i + 1) / n) * 100;
                    stops.push(`${color} ${start}%`, `${color} ${end}%`);
                }
                colorGradientStrip.style.background = `linear-gradient(to right, ${stops.join(', ')})`;
            } else {
                // Smooth mode: continuous day-cycle gradient
                const cssStops = DAY_GRADIENT_STOPS.map(s => {
                    const hex = '#' + [s[1], s[2], s[3]].map(v => v.toString(16).padStart(2, '0')).join('');
                    return `${hex} ${s[0]}%`;
                });
                colorGradientStrip.style.background = `linear-gradient(to right, ${cssStops.join(', ')})`;
            }
        }

        // Pre-computed palette HSL values (populated once on first gradient use)
        let paletteHSLCache = null;
        function getPaletteHSLCache() {
            if (paletteHSLCache) return paletteHSLCache;
            paletteHSLCache = {};
            for (const [name, info] of Object.entries(PALETTE_DATA)) {
                if (!info || !info.bg) { paletteHSLCache[name] = { h: 0, s: 0, l: 0 }; continue; }
                const hex = info.bg.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h = 0, s = 0, l = (max + min) / 2;
                if (max !== min) {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    else if (max === g) h = ((b - r) / d + 2) / 6;
                    else h = ((r - g) / d + 4) / 6;
                }
                paletteHSLCache[name] = { h: h * 360, s: s * 100, l: l * 100 };
            }
            return paletteHSLCache;
        }

        function getPaletteColorDist(palette, tH, tS, tL) {
            const c = getPaletteHSLCache()[palette];
            if (!c) return 9999;
            const hueDiff = Math.abs(c.h - tH);
            const hd = Math.min(hueDiff, 360 - hueDiff);
            return hd * 2 + Math.abs(c.s - tS) + Math.abs(c.l - tL) * 0.5;
        }

        // Pre-computed palette gradient slots â€” guarantees every palette is reachable
        let paletteGradientSlots = null;   // sorted array of { name, slotPercent }
        let paletteGradientSlotMap = null;  // name -> slotPercent

        function buildPaletteGradientSlots() {
            if (paletteGradientSlots) return;
            const cache = getPaletteHSLCache();
            const names = Object.keys(cache);
            // Find each palette's best natural gradient position
            const entries = names.map(name => {
                const hsl = cache[name];
                let bestPercent = 50, bestDist = Infinity;
                for (let p = 0; p <= 100; p += 1) {
                    const tc = getGradientColorAtPercent(p);
                    const hueDiff = Math.abs(hsl.h - tc.h);
                    const hd = Math.min(hueDiff, 360 - hueDiff);
                    const dist = hd * 2 + Math.abs(hsl.s - tc.s) + Math.abs(hsl.l - tc.l) * 0.5;
                    if (dist < bestDist) { bestDist = dist; bestPercent = p; }
                }
                return { name, naturalPercent: bestPercent };
            });
            // Sort by natural position on the day-cycle gradient
            entries.sort((a, b) => a.naturalPercent - b.naturalPercent);
            // Assign evenly-spaced slots so every palette owns a unique region
            const count = entries.length;
            paletteGradientSlots = entries.map((e, i) => ({
                name: e.name,
                slotPercent: count > 1 ? (i / (count - 1)) * 100 : 50
            }));
            paletteGradientSlotMap = {};
            for (const slot of paletteGradientSlots) {
                paletteGradientSlotMap[slot.name] = slot.slotPercent;
            }
        }

        function getPaletteAtGradientPercent(percent) {
            buildPaletteGradientSlots();
            let best = paletteGradientSlots[0];
            let bestDist = Math.abs(best.slotPercent - percent);
            for (let i = 1; i < paletteGradientSlots.length; i++) {
                const dist = Math.abs(paletteGradientSlots[i].slotPercent - percent);
                if (dist < bestDist) { bestDist = dist; best = paletteGradientSlots[i]; }
            }
            return best.name;
        }

        function getGradientPercentForPalette(paletteName) {
            buildPaletteGradientSlots();
            return paletteGradientSlotMap[paletteName] ?? 50;
        }

        // Gradient grid state: pre-rendered DOM nodes for instant reordering
        let gradientGridItems = null; // Map<tokenId, { el, palette }>
        let gradientGridContainer = null; // The .grid-items wrapper
        let gradientPaletteGroups = null; // { paletteName: [el, el, ...] } for fast reorder
        let gradientImageObserver = null; // IntersectionObserver for lazy image loading

        function preRenderGradientGrid() {
            // Build all tokens that pass current non-palette filters
            const waterFilter = document.getElementById('gridWaterFilter').checked;
            const allTokens = [];
            for (let i = 0; i <= MAX_TOKEN; i++) {
                const traits = tokenTraits[i];
                if (!traits) continue;
                if (showingFavoritesOnly && !isCityFavorited(i)) continue;
                if (currentEnergyFilter && traits['Time of Day'] !== currentEnergyFilter) continue;
                if (gridFilterState.times.size > 0 && !gridFilterState.times.has(traits['Time of Day'])) continue;
                if (gridFilterState.energy.size > 0 && !gridFilterState.energy.has(traits['Energy'])) continue;
                if (gridFilterState.zooms.size > 0 && !gridFilterState.zooms.has(traits['Zoom'])) continue;
                if (gridFilterState.bounds.size > 0 && !gridFilterState.bounds.has(traits['Bounds'])) continue;
                if (gridFilterState.traffic.size > 0 && !gridFilterState.traffic.has(traits['Traffic'])) continue;
                const waterVal = (traits['Water Feature'] || '').toLowerCase();
                if (waterFilter && (!waterVal || waterVal === 'none' || waterVal === 'no')) continue;
                allTokens.push(i);
            }

            gradientGridItems = new Map();
            gradientPaletteGroups = {};
            const fragment = document.createDocumentFragment();
            const container = document.createElement('div');
            container.className = `grid-items grid-${gridSize}`;
            container.style.display = 'grid';

            allTokens.forEach((id, idx) => {
                const traits = tokenTraits[id];
                const palette = traits?.['Palette'] || 'Unknown';
                const paletteData = PALETTE_DATA[palette];
                const bgColor = paletteData?.bg || '#1a1a2e';
                const rawSpotColor = paletteData?.colors?.[10] || '#FFE135';
                const spotColor = getContrastingSpotColor(rawSpotColor, bgColor);
                const colors = paletteData?.colors || [];
                let spotTextColor = getLuminance(spotColor) > 0.5 ? '#000' : '#fff';
                for (const c of [colors[0], colors[1], colors[2], colors[3], bgColor, colors[11]]) {
                    if (c && getContrastRatio(c, spotColor) >= 3) { spotTextColor = c; break; }
                }

                const div = document.createElement('div');
                div.className = 'grid-item';
                div.dataset.token = id;
                div.setAttribute('onclick', `handleGridItemClick(event, ${id})`);
                div.style.cssText = `background:${bgColor}; --spot-color:${spotColor}; --spot-text:${spotTextColor}; order:${idx};`;

                const favBtn = document.createElement('button');
                favBtn.className = `grid-item-fav ${isCityFavorited(id) ? 'favorited' : ''}`;
                favBtn.dataset.token = id;
                favBtn.textContent = '\u2665';
                favBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleCityFavorite(id, e); });

                const check = document.createElement('div');
                check.className = 'compare-check';
                check.textContent = '\u2713';

                // 20px micro-thumb on all images (~400 bytes each, ~200KB total â€” instant fill)
                // IntersectionObserver upgrades visible ones to 50px for clarity
                const img = document.createElement('img');
                img.src = getMicroThumbnailUrl(id);
                img.dataset.hires = getSmallThumbnailUrl(id);
                img.alt = '';
                img.decoding = 'async';

                const label = document.createElement('div');
                label.className = 'grid-item-label';
                label.textContent = `#${id}`;

                div.append(favBtn, check, img, label);
                container.appendChild(div);
                gradientGridItems.set(id, { el: div, palette });
                // Build palette groups for fast reorder (sort ~50 groups, not 500 items)
                if (!gradientPaletteGroups[palette]) gradientPaletteGroups[palette] = [];
                gradientPaletteGroups[palette].push(div);
            });

            fragment.appendChild(container);
            gradientGridContainer = container;
            gridContent.innerHTML = '';
            gridContent.appendChild(fragment);
            document.getElementById('gridPagination').style.display = 'none';

            // Upgrade visible images from 20px micro-thumbs to 50px via IntersectionObserver
            // Use larger rootMargin on mobile to pre-load further ahead (fast scroll/reorder)
            if (gradientImageObserver) gradientImageObserver.disconnect();
            const obsMargin = window.innerWidth <= 768 ? '600px 0px' : '150px 0px';
            gradientImageObserver = new IntersectionObserver((entries) => {
                for (let i = 0; i < entries.length; i++) {
                    if (entries[i].isIntersecting) {
                        const img = entries[i].target;
                        if (img.dataset.hires) {
                            img.src = img.dataset.hires;
                            delete img.dataset.hires;
                        }
                        gradientImageObserver.unobserve(img);
                    }
                }
            }, { rootMargin: obsMargin });
            container.querySelectorAll('.grid-item img').forEach(img => {
                gradientImageObserver.observe(img);
            });
        }

        // Reusable palette name array for sorting (~50 items, not 500)
        let gradientPaletteKeys = null;

        function reorderGradientGrid(tH, tS, tL) {
            if (!gradientPaletteGroups) return;
            // Build palette key list once, reuse across frames
            if (!gradientPaletteKeys) {
                gradientPaletteKeys = Object.keys(gradientPaletteGroups);
            }
            // Sort only ~50 palette names by color distance
            gradientPaletteKeys.sort((a, b) => {
                return getPaletteColorDist(a, tH, tS, tL) - getPaletteColorDist(b, tH, tS, tL);
            });
            // Assign CSS order sequentially by palette group â€” only touch changed elements
            let order = 0;
            for (let p = 0; p < gradientPaletteKeys.length; p++) {
                const group = gradientPaletteGroups[gradientPaletteKeys[p]];
                for (let i = 0; i < group.length; i++) {
                    const el = group[i];
                    if (el._gradOrder !== order) {
                        el.style.order = order;
                        el._gradOrder = order;
                    }
                    order++;
                }
            }
        }

        function reobserveGradientImages() {
            if (!gradientImageObserver || !gradientGridContainer) return;
            // Eagerly upgrade images currently in (or near) the viewport â€” skip IO latency
            const scrollParent = gradientGridContainer.closest('.grid-content') || document.documentElement;
            const vpTop = scrollParent.scrollTop - 200;
            const vpBot = scrollParent.scrollTop + scrollParent.clientHeight + 200;
            gradientGridContainer.querySelectorAll('.grid-item img[data-hires]').forEach(img => {
                const rect = img.getBoundingClientRect();
                const parentRect = scrollParent.getBoundingClientRect();
                const relTop = rect.top - parentRect.top + scrollParent.scrollTop;
                if (relTop + rect.height >= vpTop && relTop <= vpBot) {
                    img.src = img.dataset.hires;
                    delete img.dataset.hires;
                    gradientImageObserver.unobserve(img);
                } else {
                    gradientImageObserver.observe(img);
                }
            });
        }

        function teardownGradientGrid() {
            if (gradientImageObserver) { gradientImageObserver.disconnect(); gradientImageObserver = null; }
            if (gradientReobserveTimer) { clearTimeout(gradientReobserveTimer); gradientReobserveTimer = null; }
            gradientGridItems = null;
            gradientGridContainer = null;
            gradientPaletteGroups = null;
            gradientPaletteKeys = null;
        }

        function toggleColorGradient() {
            colorGradientActive = !colorGradientActive;
            colorGradientToggle.classList.toggle('active', colorGradientActive);
            colorGradientBar.classList.toggle('open', colorGradientActive);

            if (colorGradientActive) {
                buildColorGradient();
                savedFilterState = new Set(gridFilterState.palettes);
                // Clear palette filter so all palettes are included
                gridFilterState.palettes = new Set();
                // Pre-render the entire grid (50px thumbs, lazy-loaded beyond first viewport)
                preRenderGradientGrid();
                // Show label then fade it out after 5 seconds
                const gradLabel = document.querySelector('.grid-color-gradient-label');
                if (gradLabel) {
                    gradLabel.classList.remove('hidden');
                    if (window._gradLabelTimer) clearTimeout(window._gradLabelTimer);
                    window._gradLabelTimer = setTimeout(() => gradLabel.classList.add('hidden'), 5000);
                }
            } else {
                teardownGradientGrid();
                // Keep palette selection if user interacted, restore if not
                if (savedFilterState && !colorGradientStrip.classList.contains('active')) {
                    gridFilterState.palettes = savedFilterState;
                }
                savedFilterState = null;
                gradientTargetColor = null;
                colorGradientStrip.classList.remove('active');
                colorGradientHint.classList.remove('visible');
                colorGradientClock.classList.remove('visible');
                // Sync mode button if it was in gradient state
                if (paletteColorState === 'gradient') {
                    paletteColorState = 'palette';
                    updateToggleStyle();
                    gridMode = 'palette';
                }
                gridPage = 1;
                renderGrid();
            }
        }

        let gradientRAFPending = false;
        let gradientReobserveTimer = null;
        function getGradientRGBAtPercent(percent) {
            const p = Math.max(0, Math.min(100, percent));
            let lo = DAY_GRADIENT_STOPS[0], hi = DAY_GRADIENT_STOPS[DAY_GRADIENT_STOPS.length - 1];
            for (let i = 0; i < DAY_GRADIENT_STOPS.length - 1; i++) {
                if (p >= DAY_GRADIENT_STOPS[i][0] && p <= DAY_GRADIENT_STOPS[i + 1][0]) {
                    lo = DAY_GRADIENT_STOPS[i]; hi = DAY_GRADIENT_STOPS[i + 1]; break;
                }
            }
            const t = lo[0] === hi[0] ? 0 : (p - lo[0]) / (hi[0] - lo[0]);
            return [Math.round(lo[1] + t * (hi[1] - lo[1])), Math.round(lo[2] + t * (hi[2] - lo[2])), Math.round(lo[3] + t * (hi[3] - lo[3]))];
        }

        function handleGradientInteraction(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            // Update marker position immediately (cheap CSS update)
            const rect = colorGradientStrip.getBoundingClientRect();
            const percent = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            colorGradientMarker.style.left = `${percent}%`;
            colorGradientStrip.classList.add('active');

            // Update marker color to match gradient position
            if (colorGradientStepped) {
                const palName = getPaletteAtGradientPercent(percent);
                colorGradientMarker.style.background = `radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), ${PALETTE_DATA[palName].bg} 70%)`;
            } else {
                const [mr, mg, mb] = getGradientRGBAtPercent(percent);
                colorGradientMarker.style.background = `radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), rgb(${mr},${mg},${mb}) 70%)`;
            }

            // Show clock time immediately (cheap text update)
            const posHour = (percent / 100) * 24;
            const hh = String(Math.floor(posHour)).padStart(2, '0');
            const mm = String(Math.floor((posHour % 1) * 60)).padStart(2, '0');
            colorGradientClock.textContent = `${hh}:${mm}`;
            colorGradientClock.classList.add('visible');
            colorGradientHint.classList.remove('visible');

            // Throttle expensive reorder to once per animation frame
            if (!gradientRAFPending) {
                gradientRAFPending = true;
                requestAnimationFrame(() => {
                    gradientRAFPending = false;
                    if (colorGradientStepped) {
                        const palName = getPaletteAtGradientPercent(percent);
                        gradientTargetColor = getPaletteHSLCache()[palName];
                    } else {
                        gradientTargetColor = getGradientColorAtPercent(percent);
                    }
                    reorderGradientGrid(gradientTargetColor.h, gradientTargetColor.s, gradientTargetColor.l);
                });
            }

            // Re-observe images periodically during drag so newly visible items start loading
            if (!gradientReobserveTimer) {
                gradientReobserveTimer = setTimeout(() => {
                    gradientReobserveTimer = null;
                    reobserveGradientImages();
                }, 250);
            }
        }

        colorGradientToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleColorGradient();
        });

        // Mobile: press-and-drag from color wheel to immediately start scrubbing
        colorGradientToggle.addEventListener('touchstart', (e) => {
            if (window.innerWidth <= 768) {
                e.preventDefault(); // prevent subsequent click from toggling back off
                e.stopPropagation();
                if (!colorGradientActive) {
                    toggleColorGradient();
                }
                colorGradientDragging = true;
                handleGradientInteraction(e);
            }
        }, { passive: false });

        colorGradientClose.addEventListener('click', (e) => {
            e.stopPropagation();
            if (colorGradientActive) toggleColorGradient();
        });

        // Stepped / smooth gradient toggle
        gradientStepToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            colorGradientStepped = !colorGradientStepped;
            gradientStepToggle.classList.toggle('active', colorGradientStepped);
            // Swap icon: staircase for smooth mode, wave for stepped mode
            gradientStepToggle.innerHTML = colorGradientStepped
                ? '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><path d="M2 12 C5 4, 8 14, 14 4"/></svg>'
                : '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2 14 h3.5 v-4 h3.5 v-4 h3.5 v-4"/></svg>';
            buildColorGradient();
        });

        colorGradientStrip.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent text selection when dragging off-window
            colorGradientDragging = true;
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
            handleGradientInteraction(e);
        });
        colorGradientStrip.addEventListener('touchstart', (e) => {
            colorGradientDragging = true;
            handleGradientInteraction(e);
        }, { passive: true });

        document.addEventListener('mousemove', (e) => {
            if (colorGradientDragging) handleGradientInteraction(e);
            else if (colorGradientActive && !colorGradientStrip.classList.contains('active')) {
                // Hover preview of marker position + clock
                const rect = colorGradientStrip.getBoundingClientRect();
                if (e.clientY >= rect.top && e.clientY <= rect.bottom && e.clientX >= rect.left && e.clientX <= rect.right) {
                    const x = e.clientX - rect.left;
                    const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
                    colorGradientMarker.style.left = `${percent}%`;
                    // Update marker color on hover
                    if (colorGradientStepped) {
                        const palName = getPaletteAtGradientPercent(percent);
                        colorGradientMarker.style.background = `radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), ${PALETTE_DATA[palName].bg} 70%)`;
                    } else {
                        const [hr, hg, hb] = getGradientRGBAtPercent(percent);
                        colorGradientMarker.style.background = `radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), rgb(${hr},${hg},${hb}) 70%)`;
                    }
                    // Show clock on hover too
                    const posHour = (percent / 100) * 24;
                    const hh = String(Math.floor(posHour)).padStart(2, '0');
                    const mm = String(Math.floor((posHour % 1) * 60)).padStart(2, '0');
                    colorGradientClock.textContent = `${hh}:${mm}`;
                    colorGradientClock.classList.add('visible');
                } else {
                    colorGradientClock.classList.remove('visible');
                }
            }
        });
        document.addEventListener('touchmove', (e) => {
            if (colorGradientDragging) handleGradientInteraction(e);
        }, { passive: true });
        document.addEventListener('mouseup', () => {
            if (colorGradientDragging) {
                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
                reobserveGradientImages();
            }
            colorGradientDragging = false;
        });
        document.addEventListener('touchend', () => {
            if (colorGradientDragging) reobserveGradientImages();
            colorGradientDragging = false;
        });

        // Also close gradient when grid mode changes
        function deactivateColorGradient() {
            if (colorGradientActive) {
                colorGradientActive = false;
                colorGradientToggle.classList.remove('active');
                colorGradientBar.classList.remove('open');
                teardownGradientGrid();
                // Keep palette selection if user interacted, restore if not
                if (savedFilterState && !colorGradientStrip.classList.contains('active')) {
                    gridFilterState.palettes = savedFilterState;
                }
                savedFilterState = null;
                colorGradientStrip.classList.remove('active');
                colorGradientHint.classList.remove('visible');
                colorGradientClock.classList.remove('visible');
                gradientTargetColor = null;
                // Sync mode button if it was in gradient state
                if (paletteColorState === 'gradient') {
                    paletteColorState = 'palette';
                    updateToggleStyle();
                    gridMode = 'palette';
                }
            }
        }

        function populateGridFilters() {
            // Reset counts
            traitCounts.palettes = {};
            traitCounts.times = {};
            traitCounts.zooms = {};
            traitCounts.bounds = {};
            traitCounts.traffic = {};
            traitCounts.lines = {};
            traitCounts.energy = {};
            traitCounts.commute = {};
            traitCounts.transit = {};
            traitCounts.water = {};
            totalMinted = 0;

            for (let i = 0; i <= MAX_TOKEN; i++) {
                const traits = tokenTraits[i];
                if (traits) {
                    totalMinted++;
                    if (traits['Palette']) {
                        traitCounts.palettes[traits['Palette']] = (traitCounts.palettes[traits['Palette']] || 0) + 1;
                    }
                    if (traits['Time of Day']) {
                        traitCounts.times[traits['Time of Day']] = (traitCounts.times[traits['Time of Day']] || 0) + 1;
                    }
                    if (traits['Zoom']) {
                        traitCounts.zooms[traits['Zoom']] = (traitCounts.zooms[traits['Zoom']] || 0) + 1;
                    }
                    if (traits['Bounds']) {
                        traitCounts.bounds[traits['Bounds']] = (traitCounts.bounds[traits['Bounds']] || 0) + 1;
                    }
                    if (traits['Traffic']) {
                        traitCounts.traffic[traits['Traffic']] = (traitCounts.traffic[traits['Traffic']] || 0) + 1;
                    }
                    if (traits['Line']) {
                        traitCounts.lines[traits['Line']] = (traitCounts.lines[traits['Line']] || 0) + 1;
                    }
                    if (traits['Energy']) {
                        traitCounts.energy[traits['Energy']] = (traitCounts.energy[traits['Energy']] || 0) + 1;
                    }
                    if (traits['Commute']) {
                        traitCounts.commute[traits['Commute']] = (traitCounts.commute[traits['Commute']] || 0) + 1;
                    }
                    if (traits['Transit']) {
                        traitCounts.transit[traits['Transit']] = (traitCounts.transit[traits['Transit']] || 0) + 1;
                    }
                    if (traits['Water Feature']) {
                        traitCounts.water[traits['Water Feature']] = (traitCounts.water[traits['Water Feature']] || 0) + 1;
                    }
                }
            }
            populateMultiSelect('paletteMultiSelect', 'palettes', traitCounts.palettes, 'PALETTE');
            populateMultiSelect('timeMultiSelect', 'times', traitCounts.times, 'TIME');
            populateMultiSelect('energyMultiSelect', 'energy', traitCounts.energy, 'ENERGY');
            populateMultiSelect('zoomMultiSelect', 'zooms', traitCounts.zooms, 'ZOOM');
            populateMultiSelect('boundsMultiSelect', 'bounds', traitCounts.bounds, 'BOUNDS', { 'Aboveground Current': 'AB Current' });
            populateMultiSelect('trafficMultiSelect', 'traffic', traitCounts.traffic, 'TRAFFIC');
        }

        function getGridFilteredTokens() {
            // If collector filter is active, only show their tokens
            if (currentCollectorFilter && currentCollectorFilter.tokens.length > 0) {
                let collectorTokens = [...currentCollectorFilter.tokens];
                // Apply energy filter to collector tokens too
                if (currentEnergyFilter) {
                    collectorTokens = collectorTokens.filter(id => {
                        const traits = tokenTraits[id];
                        return traits && traits['Time of Day'] === currentEnergyFilter;
                    });
                }
                return gridSortOrder === 'desc' ? collectorTokens.sort((a, b) => b - a) : collectorTokens.sort((a, b) => a - b);
            }

            const waterFilter = document.getElementById('gridWaterFilter').checked;
            const tokens = [];
            for (let i = 0; i <= MAX_TOKEN; i++) {
                const traits = tokenTraits[i];
                if (!traits) continue;
                // Favorites filter: if showing favorites only, skip non-favorited cities
                if (showingFavoritesOnly && !isCityFavorited(i)) continue;
                // Energy filter: filter by time of day
                if (currentEnergyFilter && traits['Time of Day'] !== currentEnergyFilter) continue;
                // Multi-select filters: if none selected, show none; if value not in set, skip
                if (gridFilterState.palettes.size > 0 && !gridFilterState.palettes.has(traits['Palette'])) continue;
                if (gridFilterState.times.size > 0 && !gridFilterState.times.has(traits['Time of Day'])) continue;
                if (gridFilterState.energy.size > 0 && !gridFilterState.energy.has(traits['Energy'])) continue;
                if (gridFilterState.zooms.size > 0 && !gridFilterState.zooms.has(traits['Zoom'])) continue;
                if (gridFilterState.bounds.size > 0 && !gridFilterState.bounds.has(traits['Bounds'])) continue;
                if (gridFilterState.traffic.size > 0 && !gridFilterState.traffic.has(traits['Traffic'])) continue;
                // Water filter: show items where Water Feature exists and is not "None"
                const waterVal = (traits['Water Feature'] || '').toLowerCase();
                if (waterFilter && (!waterVal || waterVal === 'none' || waterVal === 'no')) continue;
                tokens.push(i);
            }
            // When gradient is active, sort by closest color to the target
            if (colorGradientActive && gradientTargetColor) {
                const tH = gradientTargetColor.h, tS = gradientTargetColor.s, tL = gradientTargetColor.l;
                const distCache = {};
                const getColorDist = (palette) => {
                    if (distCache[palette] !== undefined) return distCache[palette];
                    const info = PALETTE_DATA[palette];
                    if (!info || !info.bg) { distCache[palette] = 9999; return 9999; }
                    const hex = info.bg.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16) / 255;
                    const g = parseInt(hex.substr(2, 2), 16) / 255;
                    const b = parseInt(hex.substr(4, 2), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h = 0, s = 0, l = (max + min) / 2;
                    if (max !== min) {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                        else if (max === g) h = ((b - r) / d + 2) / 6;
                        else h = ((r - g) / d + 4) / 6;
                    }
                    h *= 360; s *= 100; l *= 100;
                    const hueDiff = Math.abs(h - tH);
                    const hd = Math.min(hueDiff, 360 - hueDiff);
                    // Weighted distance: hue matters most, then saturation, then lightness
                    distCache[palette] = hd * 2 + Math.abs(s - tS) + Math.abs(l - tL) * 0.5;
                    return distCache[palette];
                };
                return tokens.sort((a, b) => {
                    const pa = tokenTraits[a]?.['Palette'] || '';
                    const pb = tokenTraits[b]?.['Palette'] || '';
                    return getColorDist(pa) - getColorDist(pb);
                });
            }
            // Sort by mint order: desc = newest first (high ID), asc = oldest first (low ID)
            return gridSortOrder === 'desc' ? tokens.sort((a, b) => b - a) : tokens.sort((a, b) => a - b);
        }

        function getColorSortValue(palette) {
            const info = PALETTE_DATA[palette];
            if (!info || !info.bg) return 999; // Unknown palettes go last
            const hex = info.bg.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16) / 255;
            const g = parseInt(hex.substr(2, 2), 16) / 255;
            const b = parseInt(hex.substr(4, 2), 16) / 255;

            // Convert to HSL
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                else if (max === g) h = ((b - r) / d + 2) / 6;
                else h = ((r - g) / d + 4) / 6;
            }
            h *= 360;
            s *= 100;
            l *= 100;

            // Categorize: saturated first (0-99), then day/light (100-199), then night/dark (200-299)
            const isDark = l < 20;
            const isSaturated = s > 35 && l > 20 && l < 85;

            let category;
            if (isSaturated) category = 0; // Saturated/colorful first
            else if (isDark) category = 2; // Night - dark backgrounds last
            else category = 1; // Day - light or desaturated in middle

            // Within category, sort by hue (0-360 normalized to 0-99)
            return category * 100 + (h / 360) * 99;
        }

        function renderGrid() {
            const tokens = getGridFilteredTokens();
            const totalMinted = MAX_TOKEN + 1; // Use actual minted count from API

            // Check if any filters are active (filter is active when fewer than all options are selected)
            const hasActiveFilters = showingFavoritesOnly ||
                currentCollectorFilter !== null ||
                currentEnergyFilter !== null ||
                gridFilterState.palettes.size < Object.keys(traitCounts.palettes).length ||
                gridFilterState.times.size < Object.keys(traitCounts.times).length ||
                gridFilterState.energy.size < Object.keys(traitCounts.energy).length ||
                gridFilterState.zooms.size < Object.keys(traitCounts.zooms).length ||
                gridFilterState.bounds.size < Object.keys(traitCounts.bounds).length ||
                gridFilterState.traffic.size < Object.keys(traitCounts.traffic).length ||
                document.getElementById('gridWaterFilter').checked;

            // Update showing count - only visible when filters are active
            const showingEl = document.getElementById('gridShowingCount');
            if (showingEl) {
                showingEl.textContent = `${tokens.length} showing`;
                if (hasActiveFilters) {
                    showingEl.classList.add('visible');
                } else {
                    showingEl.classList.remove('visible');
                }
            }

            // Update supply bar
            const supplyFill = document.getElementById('gridSupplyFill');
            const mintedCount = document.getElementById('gridMintedCount');
            if (supplyFill) supplyFill.style.width = `${(totalMinted / 500) * 100}%`;
            if (mintedCount) mintedCount.textContent = totalMinted;

            // When gradient is actively being used, grid is pre-rendered with CSS order reordering
            // (skip full re-render; reorderGradientGrid handles sorting via CSS order)
            if (colorGradientActive && gradientGridItems && !showingFavoritesOnly) {
                // Check if gradient grid is still in the DOM (it gets destroyed when switching to favorites view)
                if (gradientGridContainer && gradientGridContainer.parentNode) {
                    return;
                }
                // Gradient grid was destroyed, rebuild it
                preRenderGradientGrid();
                if (gradientTargetColor) {
                    reorderGradientGrid(gradientTargetColor.h, gradientTargetColor.s, gradientTargetColor.l);
                }
                return;
            } else if (showingFavoritesOnly) {
                renderFavoritesGrid(tokens);
            } else if (gridMode === 'origins') {
                renderOriginsGrid();
            } else if (gridMode === 'grid') {
                renderSimpleGrid(tokens);
            } else if (gridMode === 'palette') {
                renderPaletteGroups(tokens);
            } else if (gridMode === 'gradient') {
                // Gradient mode - normally handled by colorGradientActive early return above
                if (!colorGradientActive) renderPaletteGroups(tokens);
            } else if (gridMode === 'color') {
                renderColorSorted(tokens);
            } else if (gridMode === 'az') {
                renderAZPalettes(tokens);
            } else if (gridMode === 'rarity') {
                renderRaritySorted(tokens);
            } else if (gridMode === 'collector') {
                renderCollectorGroups(tokens);
            }
        }

        function renderFavoritesGrid(tokens) {
            // Special clean grid for favorites - sized big for viewing
            if (tokens.length === 0) {
                gridContent.innerHTML = `<div class="empty-gallery">Go explore and click ðŸ’™ to save your favorites.</div>`;
                document.getElementById('gridPagination').style.display = 'none';
                return;
            }

            // Calculate optimal columns based on number of favorites
            let favGridSize;
            if (tokens.length <= 4) {
                favGridSize = '2-col';
            } else if (tokens.length <= 9) {
                favGridSize = '3-col';
            } else if (tokens.length <= 16) {
                favGridSize = '4-col';
            } else if (tokens.length <= 36) {
                favGridSize = '6-col';
            } else {
                favGridSize = '8-col';
            }

            gridContent.innerHTML = `<div class="grid-items grid-${favGridSize} favorites-grid">${tokens.map(id => generateGridItem(id, false, 0, true)).join('')}</div>`;

            document.getElementById('gridPagination').style.display = 'none';

            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
            // Grid item click handled by inline onclick="handleGridItemClick()"
        }

        function renderAZPalettes(tokens) {
            // Group by palette, then sort palettes A-Z alphabetically
            const groups = {};
            tokens.forEach(id => {
                const traits = tokenTraits[id];
                const palette = traits?.['Palette'] || 'Unknown';
                if (!groups[palette]) groups[palette] = [];
                groups[palette].push(id);
            });

            // Sort palettes alphabetically A-Z
            const sortedPalettes = Object.keys(groups).sort((a, b) => a.localeCompare(b));

            // Build tokenâ†’collector lookup once
            const tokenToCollector = {};
            COLLECTORS_DATA.forEach(c => {
                if (c.tokens) c.tokens.forEach(t => { tokenToCollector[t] = c.name; });
            });

            let html = sortedPalettes.map(palette => {
                const paletteInfo = PALETTE_DATA[palette];
                const swatches = paletteInfo?.colors ? paletteInfo.colors.map(c => `<span style="background:${c}"></span>`).join('') : '';
                const isFav = isPaletteFavorited(palette);
                const bgColor = paletteInfo?.bg || '#333';
                const rawSpotColor = paletteInfo?.colors?.[10] || '#FFE135';
                const spotColor = getContrastingSpotColor(rawSpotColor, '#14131c'); // Contrast against panel bg

                // Dark background with light text for better readability
                const blurb = PALETTE_BLURBS[palette] || '';

                // Get collectors who own cities in this palette (fast lookup)
                const paletteCollectors = new Set();
                groups[palette].forEach(tokenId => {
                    const name = tokenToCollector[tokenId];
                    if (name) paletteCollectors.add(name);
                });
                const collectorsArray = [...paletteCollectors];
                const maxShow = 3;
                const abbreviateName = (name) => {
                    if (name.length <= 12) return name;
                    if (name.startsWith('0x')) return name.slice(0, 6) + 'â€¦' + name.slice(-4);
                    return name.slice(0, 10) + 'â€¦';
                };
                const collectorsHtml = collectorsArray.length > 0 ? `
                    <div class="grid-group-collectors">
                        ${collectorsArray.slice(0, maxShow).map(name => `<span class="grid-group-collector" data-collector="${name}" title="${name}">${abbreviateName(name)}</span>`).join('')}
                        ${collectorsArray.length > maxShow ? `<span class="grid-group-collectors-more">+${collectorsArray.length - maxShow}</span>` : ''}
                    </div>
                ` : '';

                return `
                <div class="grid-group" data-palette="${palette}" style="--spot-color:${spotColor};">
                    <div class="grid-group-header">
                        <button class="grid-group-fav ${isFav ? 'favorited' : ''}" data-palette="${palette}" title="Favorite palette">${isFav ? 'â™¥' : 'â™¡'}</button>
                        <div class="grid-group-color" style="background:${bgColor}"></div>
                        <div class="grid-group-swatches">${swatches}</div>
                        <span class="grid-group-name" data-palette="${palette}">${palette.toUpperCase()}</span>
                        <button class="grid-group-inspect" data-palette="${palette}" title="Inspect palette">ðŸ‘</button>
                        ${collectorsHtml}
                        <span class="grid-group-count">${groups[palette].length}</span>
                        <button class="grid-group-shuffle" data-palette="${palette}" title="Shuffle order">âŸ³</button>
                        <span class="grid-group-toggle">â–¼</span>
                    </div>
                    <div class="grid-group-blurb" data-palette="${palette}">${blurb}</div>
                    <div class="grid-group-items grid-${gridSize}">${groups[palette].map(id => generateGridItem(id)).join('')}</div>
                </div>
            `}).join('');

            gridContent.innerHTML = html;

            document.getElementById('gridPagination').style.display = 'none';

            // Palette favorite buttons
            gridContent.querySelectorAll('.grid-group-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = btn.dataset.palette;
                    toggleFavoritePalette(palette);
                });
            });

            // Shuffle buttons
            gridContent.querySelectorAll('.grid-group-shuffle').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const group = btn.closest('.grid-group');
                    const itemsContainer = group.querySelector('.grid-group-items');
                    const items = [...itemsContainer.querySelectorAll('.grid-item')];
                    items.sort(() => Math.random() - 0.5);
                    items.forEach(item => itemsContainer.appendChild(item));
                    // Scatter droplet animation
                    for (let i = 0; i < 6; i++) {
                        const droplet = document.createElement('span');
                        droplet.className = 'shuffle-droplet';
                        btn.appendChild(droplet);
                    }
                    setTimeout(() => {
                        btn.querySelectorAll('.shuffle-droplet').forEach(d => d.remove());
                    }, 800);
                });
            });

            // Inspect palette buttons
            gridContent.querySelectorAll('.grid-group-inspect').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = btn.dataset.palette;
                    if (typeof openPaletteInspector === 'function') {
                        paletteHistory = [palette];
                        currentPaletteIndex = 0;
                        openPaletteInspector(palette);
                    }
                });
            });

            // Collector name clicks - open their wall view
            gridContent.querySelectorAll('.grid-group-collector').forEach(collector => {
                collector.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const collectorName = collector.dataset.collector;
                    const collectorData = COLLECTORS_DATA.find(c => c.name === collectorName);
                    if (collectorData && collectorData.tokens && collectorData.tokens.length > 0) {
                        const wallFn = window.openWallView || openWallViewFn;
                        if (typeof wallFn === 'function') {
                            wallFn(collectorName, collectorData.tokens);
                            // Set dark mode
                            setTimeout(() => {
                                const modal = document.getElementById('wallViewModal');
                                if (modal) {
                                    modal.classList.remove('wall-gray');
                                    modal.classList.add('wall-black');
                                    currentWallColor = 'black';
                                }
                            }, 50);
                        }
                    }
                });
            });

            // Header collapse toggle
            gridContent.querySelectorAll('.grid-group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    if (e.target.closest('.grid-group-fav') || e.target.closest('.grid-group-shuffle') || e.target.closest('.grid-group-collector') || e.target.closest('.grid-group-inspect')) return;
                    header.parentElement.classList.toggle('collapsed');
                });
            });

            // Double-click palette name to reveal blurb
            gridContent.querySelectorAll('.grid-group-name').forEach(name => {
                name.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const palette = name.dataset.palette;
                    if (!palette) return;
                    const blurb = name.closest('.grid-group').querySelector('.grid-group-blurb');
                    if (blurb) {
                        blurb.classList.toggle('visible');
                    }
                });
            });

            // Grid item click handled by inline onclick="handleGridItemClick()"
            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
        }

        function renderCollectorGroups(tokens) {
            // Group cities by collector, sorted by most cities first
            // Exclude "The Lost Cities" as it's not a real collector
            const tokenSet = new Set(tokens);

            // Check if COLLECTORS_DATA is loaded
            if (!COLLECTORS_DATA || COLLECTORS_DATA.length === 0) {
                gridContent.innerHTML = `<div class="empty-gallery">LOADING COLLECTORS...<br><br><span style="font-size: 11px; opacity: 0.5;">Please wait or try refreshing</span></div>`;
                document.getElementById('gridPagination').style.display = 'none';
                return;
            }

            // Build collector groups from COLLECTORS_DATA, filtering to only include tokens in our set
            // Exclude Lost Cities distribution wallet (by name or address prefix)
            const LOST_CITIES_PREFIX = '0xcf22';
            const collectorGroups = COLLECTORS_DATA
                .filter(c => c.name !== 'The Lost Cities' &&
                    !c.name.startsWith('0x') &&
                    !(c.address && c.address.toLowerCase().startsWith(LOST_CITIES_PREFIX)) &&
                    c.tokens && c.tokens.length > 0)
                .map(c => ({
                    name: c.name,
                    address: c.address,
                    tokens: (c.tokens || []).filter(id => tokenSet.has(id)),
                    allTokens: c.tokens || [],
                    totalCount: c.count
                }))
                .filter(c => c.tokens.length > 0)
                .sort((a, b) => b.tokens.length - a.tokens.length);

            if (collectorGroups.length === 0) {
                gridContent.innerHTML = `<div class="empty-gallery">NO COLLECTORS FOUND<br><br><span style="font-size: 11px; opacity: 0.5;">Try adjusting your filters</span></div>`;
                document.getElementById('gridPagination').style.display = 'none';
                return;
            }

            let html = collectorGroups.map((collector, idx) => {
                const rank = idx + 1;
                const isTopCollector = rank <= 3;
                const rankBadge = isTopCollector ? `<span class="collector-rank rank-${rank}">#${rank}</span>` : `<span class="collector-rank">#${rank}</span>`;
                // Store ALL token IDs (full collection) for wall button - not just filtered ones
                const tokenIds = collector.allTokens.join(',');

                return `
                <div class="grid-group collector-group" data-collector="${collector.name}">
                    <div class="grid-group-header collector-header">
                        ${rankBadge}
                        <span class="grid-group-name collector-name" data-collector="${collector.name}">${collector.name.toUpperCase()}</span>
                        <button class="collector-group-wall-btn" data-collector="${collector.name}" data-tokens="${tokenIds}">WALL</button>
                        <span class="grid-group-count">${collector.tokens.length}</span>
                        <span class="grid-group-toggle">â–¼</span>
                    </div>
                    <div class="grid-group-items grid-${gridSize}">${collector.tokens.map(id => generateGridItem(id)).join('')}</div>
                </div>
            `}).join('');

            gridContent.innerHTML = html;
            document.getElementById('gridPagination').style.display = 'none';

            // Header collapse toggle
            gridContent.querySelectorAll('.grid-group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    // Don't collapse when clicking name or wall button
                    if (e.target.closest('.collector-name') || e.target.closest('.collector-group-wall-btn')) return;
                    header.parentElement.classList.toggle('collapsed');
                });
            });

            // Click collector name to open their filtered grid
            gridContent.querySelectorAll('.collector-name').forEach(name => {
                name.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const collectorName = name.dataset.collector;
                    fetchCollectorTokens(collectorName);
                });
            });

            // Click wall button to open wall view in dark mode
            gridContent.querySelectorAll('.collector-group-wall-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const collectorName = btn.dataset.collector;
                    const tokensStr = btn.dataset.tokens;
                    if (!tokensStr) {
                        console.error('No tokens data for', collectorName);
                        return;
                    }
                    const tokenIds = tokensStr.split(',').map(id => parseInt(id)).filter(id => !isNaN(id) && id > 0);
                    console.log('Opening wall for', collectorName, 'with', tokenIds.length, 'tokens');
                    const wallFn = window.openWallView || openWallViewFn;
                    if (tokenIds.length > 0 && typeof wallFn === 'function') {
                        wallFn(collectorName, tokenIds);
                        // Ensure dark/black mode
                        setTimeout(() => {
                            const modal = document.getElementById('wallViewModal');
                            if (modal) {
                                modal.classList.remove('wall-gray');
                                modal.classList.add('wall-black');
                                currentWallColor = 'black';
                            }
                        }, 50);
                    } else {
                        console.error('Cannot open wall view - function not available or no tokens');
                    }
                });
            });

            // Grid item click handled by inline onclick="handleGridItemClick()"
            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
        }

        function renderSimpleGrid(tokens) {
            // Check if collector has originals to display
            let originalsHtml = '';
            if (currentCollectorFilter && currentCollectorFilter.name) {
                const collectorOriginals = getCollectorOriginals(currentCollectorFilter.name);
                if (collectorOriginals.length > 0) {
                    originalsHtml = `
                        <div class="collector-originals-section">
                            <div class="collector-originals-header">
                                <span class="collector-originals-label">Originals</span>
                                <span class="collector-originals-count">${collectorOriginals.length}</span>
                            </div>
                            <div class="collector-originals-grid">
                                ${collectorOriginals.map(o => `
                                    <div class="collector-original-item" data-origin-id="${o.id}" onclick="scrollToOriginInTimeline('${o.id}')">
                                        <div class="collector-original-img" style="background-image: url('${getThumbUrl(o.img, 400)}')"></div>
                                        <div class="collector-original-arrow">â†—</div>
                                        <div class="collector-original-info">
                                            <span class="collector-original-title">${o.title}</span>
                                            <span class="collector-original-collection">${o.collection}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            }

            // Show empty state if no matches
            if (tokens.length === 0 && !originalsHtml) {
                gridContent.innerHTML = `<div class="empty-gallery">NO CITIES MATCH THESE FILTERS<br><br><button class="btn btn-secondary" onclick="resetGridFilters()">RESET FILTERS</button></div>`;
                document.getElementById('gridPagination').style.display = 'none';
                return;
            }

            // Use eager loading for collector views (always eager for better UX)
            const useEagerLoad = currentCollectorFilter !== null || tokens.length <= 50;

            // Build cities section first (on top)
            let citiesHtml = '';
            if (tokens.length > 0) {
                const citiesLabel = originalsHtml ? `<div class="collector-cities-header"><span class="collector-cities-label">Cities</span><span class="collector-cities-count">${tokens.length}</span></div>` : '';
                citiesHtml = `${citiesLabel}<div class="grid-items grid-${gridSize}">${tokens.map(id => generateGridItem(id, false, 0, useEagerLoad)).join('')}</div>`;
            }

            // Cities first, then Originals below
            gridContent.innerHTML = citiesHtml + originalsHtml;

            document.getElementById('gridPagination').style.display = 'none';

            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
            // Grid item click handled by inline onclick="handleGridItemClick()"
        }

        // Scroll to an original in the timeline section
        function scrollToOriginInTimeline(originId) {
            // Find the origin data to get the title
            const originData = ORIGINS_DATA.find(o => o.id === originId);
            const title = originData ? originData.title : originId;

            // Close the grid view and switch to timeline
            const gridOverlay = document.getElementById('gridOverlay');
            if (gridOverlay) {
                gridOverlay.classList.remove('visible');
                setTimeout(() => gridOverlay.style.display = 'none', 300);
            }

            // Wait a moment then scroll to origins section
            setTimeout(() => {
                const originsSection = document.getElementById('origins-section');
                if (originsSection) {
                    originsSection.scrollIntoView({ behavior: 'smooth' });

                    // Highlight the specific origin item by title
                    setTimeout(() => {
                        const originItem = document.querySelector(`.timeline-item[data-title="${title}"], .timeline-group-item[data-title="${title}"]`);
                        if (originItem) {
                            originItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            originItem.classList.add('highlight-flash');
                            setTimeout(() => originItem.classList.remove('highlight-flash'), 2000);
                        }
                    }, 500);
                }
            }, 350);
        }
        window.scrollToOriginInTimeline = scrollToOriginInTimeline;

        function renderPaletteGroups(tokens) {
            const groups = {};
            tokens.forEach(id => {
                const traits = tokenTraits[id];
                const palette = traits?.['Palette'] || 'Unknown';
                if (!groups[palette]) groups[palette] = [];
                groups[palette].push(id);
            });

            // Find palettes not shown due to filters (minted but filtered out)
            const shownPalettes = new Set(Object.keys(groups));
            const allMintedPalettes = new Set();
            Object.values(tokenTraits).forEach(traits => {
                if (traits && traits['Palette']) allMintedPalettes.add(traits['Palette']);
            });
            const filteredOutPalettes = [...allMintedPalettes].filter(p => !shownPalettes.has(p));
            // Truly unminted palettes (in PALETTE_DATA but never minted)
            const unmintedPalettes = Object.keys(PALETTE_DATA).filter(p => !allMintedPalettes.has(p));

            // Sort palettes by popularity (most outputs first), then alphabetically for ties
            let sortedPalettes = Object.keys(groups).sort((a, b) => {
                const countDiff = groups[b].length - groups[a].length; // Most outputs first
                if (countDiff !== 0) return countDiff;
                return a.localeCompare(b); // Alphabetical for ties
            });

            // Build tokenâ†’collector lookup once (O(collectors * tokens_per_collector))
            const tokenToCollector = {};
            COLLECTORS_DATA.forEach(c => {
                if (c.tokens) c.tokens.forEach(t => { tokenToCollector[t] = c.name; });
            });

            let html = sortedPalettes.map(palette => {
                const paletteInfo = PALETTE_DATA[palette];
                const swatches = paletteInfo?.colors ? paletteInfo.colors.map(c => `<span style="background:${c}"></span>`).join('') : '';
                const isFav = isPaletteFavorited(palette);
                const bgColor = paletteInfo?.bg || '#333';
                const rawSpotColor = paletteInfo?.colors?.[10] || '#FFE135';
                const spotColor = getContrastingSpotColor(rawSpotColor, '#14131c'); // Contrast against panel bg
                const blurb = PALETTE_BLURBS[palette] || '';

                // Find collectors who own cities with this palette (fast lookup)
                const paletteCollectors = new Set();
                groups[palette].forEach(tokenId => {
                    const name = tokenToCollector[tokenId];
                    if (name) paletteCollectors.add(name);
                });
                const collectorsArray = [...paletteCollectors];
                const maxShow = 5;
                const collectorsHtml = collectorsArray.length > 0 ? `
                    <div class="grid-group-collectors">
                        ${collectorsArray.slice(0, maxShow).map(name => `<span class="grid-group-collector" data-collector="${name}">${name}</span>`).join('')}
                        ${collectorsArray.length > maxShow ? `<span class="grid-group-collectors-more">+${collectorsArray.length - maxShow}</span>` : ''}
                    </div>
                ` : '';

                return `
                <div class="grid-group" data-palette="${palette}" style="--spot-color:${spotColor};">
                    <div class="grid-group-header">
                        <button class="grid-group-fav ${isFav ? 'favorited' : ''}" data-palette="${palette}" title="Favorite palette">${isFav ? 'â™¥' : 'â™¡'}</button>
                        <div class="grid-group-color" style="background:${bgColor}"></div>
                        <div class="grid-group-swatches">${swatches}</div>
                        <span class="grid-group-name" data-palette="${palette}">${palette.toUpperCase()}</span>
                        <button class="grid-group-inspect" data-palette="${palette}" title="Inspect palette">ðŸ‘</button>
                        ${collectorsHtml}
                        <span class="grid-group-count">${groups[palette].length}</span>
                        <button class="grid-group-shuffle" data-palette="${palette}" title="Shuffle order">âŸ³</button>
                        <span class="grid-group-toggle">â–¼</span>
                    </div>
                    <div class="grid-group-blurb" data-palette="${palette}">${blurb}</div>
                    <div class="grid-group-items grid-${gridSize}">${groups[palette].map(id => generateGridItem(id)).join('')}</div>
                </div>
            `}).join('');

            // Add filtered-out palettes section (minted but hidden by current filters)
            if (filteredOutPalettes.length > 0) {
                html += `
                <div class="grid-group explore-palettes-section collapsed">
                    <div class="grid-group-header" style="background: linear-gradient(135deg, rgba(100, 180, 255, 0.5), rgba(80, 150, 220, 0.5));">
                        <span class="grid-group-name" style="color: #fff;">ðŸ” OTHER PALETTES (${filteredOutPalettes.length})</span>
                        <span class="grid-group-toggle" style="color: #fff;">â–¼</span>
                    </div>
                    <div class="grid-group-items" style="display: flex; flex-wrap: wrap; gap: 8px; padding: 16px;">
                        ${filteredOutPalettes.sort().map(palette => {
                            const paletteInfo = PALETTE_DATA[palette];
                            const swatches = paletteInfo?.colors ? paletteInfo.colors.slice(0, 5).map(c => `<span style="background:${c};width:14px;height:14px;border-radius:3px;display:inline-block;"></span>`).join('') : '';
                            const textColor = getContrastColor(paletteInfo?.bg || '#333');
                            return `
                            <div class="explore-palette-chip" data-palette="${palette}" data-minted="true" style="background:${paletteInfo?.bg || '#333'};padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:6px;cursor:pointer;transition:all 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                <span style="font-size:9px;font-weight:700;color:${textColor};text-transform:uppercase;letter-spacing:0.05em;">${palette}</span>
                                <div style="display:flex;gap:2px;">${swatches}</div>
                            </div>
                        `}).join('')}
                    </div>
                </div>`;
            }

            // Add unminted palettes section (never minted, waiting to be discovered)
            if (unmintedPalettes.length > 0) {
                html += `
                <div class="grid-group explore-palettes-section collapsed">
                    <div class="grid-group-header" style="background: linear-gradient(135deg, rgba(232, 184, 109, 0.6), rgba(255, 140, 66, 0.6));">
                        <span class="grid-group-name" style="color: #000;">ðŸŽ¨ UNCOLLECTED PALETTES (${unmintedPalettes.length} WAITING)</span>
                        <span class="grid-group-toggle" style="color: #fff;">â–¼</span>
                    </div>
                    <div class="grid-group-items" style="display: flex; flex-wrap: wrap; gap: 8px; padding: 16px;">
                        ${unmintedPalettes.sort().map(palette => {
                            const paletteInfo = PALETTE_DATA[palette];
                            const swatches = paletteInfo?.colors ? paletteInfo.colors.slice(0, 5).map(c => `<span style="background:${c};width:14px;height:14px;border-radius:3px;display:inline-block;"></span>`).join('') : '';
                            const textColor = getContrastColor(paletteInfo?.bg || '#333');
                            return `
                            <div class="explore-palette-chip" data-palette="${palette}" data-minted="false" style="background:${paletteInfo?.bg || '#333'};padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:6px;cursor:pointer;transition:all 0.2s ease;opacity:0.7;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                <span style="font-size:9px;font-weight:700;color:${textColor};text-transform:uppercase;letter-spacing:0.05em;">${palette}</span>
                                <div style="display:flex;gap:2px;">${swatches}</div>
                            </div>
                        `}).join('')}
                    </div>
                </div>`;
            }

            gridContent.innerHTML = html;

            document.getElementById('gridPagination').style.display = 'none';

            // Palette favorite buttons
            gridContent.querySelectorAll('.grid-group-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = btn.dataset.palette;
                    toggleFavoritePalette(palette);
                });
            });

            // Shuffle buttons
            gridContent.querySelectorAll('.grid-group-shuffle').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = btn.dataset.palette;
                    const group = btn.closest('.grid-group');
                    const itemsContainer = group.querySelector('.grid-group-items');
                    const items = [...itemsContainer.querySelectorAll('.grid-item')];
                    items.sort(() => Math.random() - 0.5);
                    items.forEach(item => itemsContainer.appendChild(item));
                    // Scatter droplet animation
                    for (let i = 0; i < 6; i++) {
                        const droplet = document.createElement('span');
                        droplet.className = 'shuffle-droplet';
                        btn.appendChild(droplet);
                    }
                    setTimeout(() => {
                        btn.querySelectorAll('.shuffle-droplet').forEach(d => d.remove());
                    }, 800);
                });
            });

            // Inspect palette buttons
            gridContent.querySelectorAll('.grid-group-inspect').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = btn.dataset.palette;
                    if (typeof openPaletteInspector === 'function') {
                        paletteHistory = [palette];
                        currentPaletteIndex = 0;
                        openPaletteInspector(palette);
                    }
                });
            });

            // Explore palette chips - filter to show that palette (if minted)
            gridContent.querySelectorAll('.explore-palette-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const palette = chip.dataset.palette;
                    const isMinted = chip.dataset.minted === 'true';

                    if (isMinted) {
                        // Minted palette - filter to just this palette while keeping other filters editable
                        // Update palette filter state
                        gridFilterState.palettes = new Set([palette]);

                        // Sync the palette multi-select UI with the new state
                        const paletteContainer = document.getElementById('paletteMultiSelect');
                        if (paletteContainer) {
                            const checkboxes = paletteContainer.querySelectorAll('.multi-select-item:not(.select-all) input');
                            checkboxes.forEach(cb => {
                                cb.checked = (cb.value === palette);
                            });
                            const selectAll = paletteContainer.querySelector('.select-all input');
                            if (selectAll) selectAll.checked = false;
                            const selectAllText = paletteContainer.querySelector('.select-all-text');
                            if (selectAllText) selectAllText.textContent = 'SELECT ALL';
                            const btn = paletteContainer.querySelector('.multi-select-btn');
                            if (btn) {
                                btn.innerHTML = `1 PALETTE <span class="arrow">â–¼</span>`;
                                btn.classList.add('has-selection');
                            }
                        }
                        gridPage = 1;
                        renderGrid();
                        showStatus(`SHOWING ${palette.toUpperCase()}`);
                    } else {
                        // Unminted palette - open inspector to preview it
                        if (typeof openPaletteInspector === 'function') {
                            paletteHistory = [palette];
                            currentPaletteIndex = 0;
                            openPaletteInspector(palette);
                        }
                    }
                });
            });

            // City favorite buttons
            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });

            gridContent.querySelectorAll('.grid-group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    if (e.target.closest('.grid-group-fav') || e.target.closest('.grid-group-shuffle') || e.target.closest('.grid-group-collector') || e.target.closest('.grid-group-inspect')) return;
                    header.parentElement.classList.toggle('collapsed');
                });
            });

            // Collector name clicks in palette headers
            gridContent.querySelectorAll('.grid-group-collector').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const collectorName = el.dataset.collector;
                    fetchCollectorTokens(collectorName);
                });
            });

            // Grid item click handled by inline onclick="handleGridItemClick()"
        }

        function renderColorSorted(tokens) {
            const sorted = [...tokens].sort((a, b) => {
                const paletteA = tokenTraits[a]?.['Palette'] || '';
                const paletteB = tokenTraits[b]?.['Palette'] || '';
                return getColorSortValue(paletteA) - getColorSortValue(paletteB);
            });

            gridContent.innerHTML = `<div class="grid-items grid-${gridSize}">${sorted.map(id => generateGridItem(id)).join('')}</div>`;

            document.getElementById('gridPagination').style.display = 'none';

            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
            // Grid item click handled by inline onclick="handleGridItemClick()"
        }

        function calculateRarityScore(tokenId) {
            const traits = tokenTraits[tokenId];
            if (!traits || totalMinted === 0) return 100;

            // Calculate combined rarity as product of individual trait rarities
            // Lower score = more rare
            let score = 1;
            const keyTraits = ['Palette', 'Time of Day', 'Zoom', 'Bounds', 'Traffic'];
            keyTraits.forEach(key => {
                const value = traits[key];
                if (value) {
                    const rarity = getTraitRarity(key, value);
                    if (rarity) {
                        score *= (rarity.pct / 100);
                    }
                }
            });
            return score * 100; // Convert to percentage-like number
        }

        function getRarestToken() {
            // Find the rarest token across all minted tokens
            const allTokens = Object.keys(tokenTraits).map(Number);
            if (allTokens.length === 0) return 0;

            // Use OpenSea rarity if available
            if (Object.keys(tokenRarityRanks).length > 0) {
                let rarestToken = allTokens[0];
                let lowestRank = tokenRarityRanks[rarestToken] || 9999;
                allTokens.forEach(tokenId => {
                    const rank = tokenRarityRanks[tokenId] || 9999;
                    if (rank < lowestRank) {
                        lowestRank = rank;
                        rarestToken = tokenId;
                    }
                });
                return rarestToken;
            }

            // Fallback to calculated rarity
            let rarestToken = allTokens[0];
            let lowestScore = calculateRarityScore(rarestToken);

            allTokens.forEach(tokenId => {
                const score = calculateRarityScore(tokenId);
                if (score < lowestScore) {
                    lowestScore = score;
                    rarestToken = tokenId;
                }
            });

            return rarestToken;
        }

        function renderRaritySorted(tokens) {
            // Use OpenSea rarity ranks - tokens with known ranks come first, sorted by rank
            // Tokens without known ranks are sorted by calculated score and shown after
            const withRanks = tokens.map(id => ({
                id,
                openSeaRank: tokenRarityRanks[id] || null,
                score: calculateRarityScore(id)
            })).sort((a, b) => {
                // Tokens with OpenSea ranks come first, sorted by rank
                if (a.openSeaRank && b.openSeaRank) return a.openSeaRank - b.openSeaRank;
                if (a.openSeaRank && !b.openSeaRank) return -1;
                if (!a.openSeaRank && b.openSeaRank) return 1;
                // Both without OpenSea rank - sort by calculated score
                return a.score - b.score;
            });

            // Show OpenSea rank for tokens that have it, no rank badge for others
            gridContent.innerHTML = `<div class="grid-items grid-${gridSize}">${withRanks.map((item) => generateGridItem(item.id, true, item.openSeaRank)).join('')}</div>`;

            document.getElementById('gridPagination').style.display = 'none';

            gridContent.querySelectorAll('.grid-item-fav').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCityFavorite(parseInt(btn.dataset.token), e);
                });
            });
            // Grid item click handled by inline onclick="handleGridItemClick()"
        }

        const urlParams = getUrlParams();
        const lastViewed = getLastViewed();
        // Load a random city on fresh visit (avoid token 0 which can be slow)
        const randomStart = Math.floor(Math.random() * MAX_TOKEN) + 1;
        const initialToken = urlParams.token !== null ? parseInt(urlParams.token) : (lastViewed || randomStart);
        const validInitialToken = !isNaN(initialToken) && initialToken >= 0 && initialToken <= MAX_TOKEN ? initialToken : randomStart;

        // Preload single output in background, grid will always show first
        loadOutput(validInitialToken, true);
        loadAllTokenData();

        // Helper to update minted count UI
        function updateMintedUI(minted) {
            const newMaxToken = minted - 1; // Token IDs are 0-indexed

            // Update UI
            const percent = Math.round((minted / 500) * 100);
            console.log('Updating minted UI:', minted, 'percent:', percent);

            const mintedCountEl = document.getElementById('mintedCount');
            const statsCitiesEl = document.getElementById('statsCities');
            if (mintedCountEl) mintedCountEl.textContent = minted;
            if (statsCitiesEl) statsCitiesEl.textContent = minted;

            // Update progress bars (sidebar and grid header)
            const supplyFill = document.getElementById('supplyFill');
            console.log('supplyFill element:', supplyFill, 'setting width to:', percent + '%');
            if (supplyFill) supplyFill.style.width = percent + '%';
            const gridSupplyFill = document.getElementById('gridSupplyFill');
            const gridMintedCount = document.getElementById('gridMintedCount');
            if (gridSupplyFill) gridSupplyFill.style.width = percent + '%';
            if (gridMintedCount) gridMintedCount.textContent = minted;

            // If new tokens have been minted, fetch their data
            if (newMaxToken > MAX_TOKEN) {
                console.log(`New mints detected: ${MAX_TOKEN + 1} to ${newMaxToken}`);
                // Fetch traits for new tokens
                (async () => {
                    for (let i = MAX_TOKEN + 1; i <= newMaxToken; i++) {
                        await fetchTokenTraits(i);
                    }
                    MAX_TOKEN = newMaxToken;
                    // Update filters and counts with new data
                    extractTraitValues();
                    populateFilters();
                    updateMatchCount();
                    saveCachedTraits();
                    // Re-render grid if it's open to show new mints
                    if (gridMode) renderGrid();
                })();
            }
            // Also set MAX_TOKEN from server data if we have fewer tokens loaded
            else if (newMaxToken !== MAX_TOKEN && newMaxToken >= 0) {
                MAX_TOKEN = newMaxToken;
            }

            if (minted >= 500) {
                document.getElementById('supplyTracker').classList.add('sold-out');
                const dots = document.querySelector('.supply-label .dots');
                if (dots) dots.style.display = 'none';
            }
        }

        // Fetch and update minted count from Art Blocks API, fallback to OpenSea
        async function updateMintedCount() {
            // Try Art Blocks API first
            try {
                const response = await fetch(`https://token.artblocks.io/${CONTRACT}/0`);
                const data = await response.json();
                console.log('Art Blocks API response:', data);
                if (data.invocations) {
                    const minted = parseInt(data.invocations);
                    console.log('Minted count from Art Blocks:', minted);
                    updateMintedUI(minted);
                    return;
                }
            } catch (e) {
                console.log('Art Blocks API failed, trying OpenSea...');
            }

            // Fallback to OpenSea API (v1 endpoint, no key required)
            try {
                const response = await fetch('https://api.opensea.io/api/v1/collection/cities-by-efdot-x-diid/stats');
                const data = await response.json();
                console.log('OpenSea API response:', data);
                if (data.stats && data.stats.total_supply) {
                    const minted = parseInt(data.stats.total_supply);
                    console.log('Minted count from OpenSea:', minted);
                    updateMintedUI(minted);
                    return;
                }
            } catch (e) {
                console.log('OpenSea API also failed');
            }

            // Final fallback: use MAX_TOKEN + 1
            console.log('Using MAX_TOKEN fallback for minted count');
            updateMintedUI(MAX_TOKEN + 1);
        }
        // Set initial value immediately from MAX_TOKEN
        // (loadAllTokenData already fetches the authoritative minted count on startup,
        //  so we skip the redundant updateMintedCount() call here)
        updateMintedUI(MAX_TOKEN + 1);
        // Refresh every 30 seconds to catch new mints, but only when tab is visible
        let mintedCountInterval = setInterval(updateMintedCount, 30000);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearInterval(mintedCountInterval);
                mintedCountInterval = null;
            } else {
                // Immediately refresh when tab becomes visible again, then resume polling
                updateMintedCount();
                mintedCountInterval = setInterval(updateMintedCount, 30000);
            }
        });

        // Mint button wave animation - each segment waves independently (hover only)
        function triggerMintWave() {
            const segs = document.querySelectorAll('#mintToggle .collect-seg');
            segs.forEach((seg, i) => {
                setTimeout(() => {
                    seg.classList.add('wave');
                    setTimeout(() => seg.classList.remove('wave'), 600);
                }, i * 100);
            });
        }

        // Countdown to May 31st
        function updateCountdown() {
            const target = new Date('2025-05-31T23:59:59').getTime();
            const now = new Date().getTime();
            const diff = target - now;
            const timerEl = document.getElementById('countdownTimer');
            const containerEl = document.getElementById('mintCountdown');

            if (diff <= 0) {
                containerEl.classList.add('ended');
                return;
            }

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const secs = Math.floor((diff % (1000 * 60)) / 1000);

            timerEl.textContent = `${days}D ${hours}H ${mins}M ${secs}S`;
        }
        updateCountdown();
        setInterval(updateCountdown, 1000);

        // Welcome screen - blob first, then city if needed, then reveal
        const welcomeScreen = document.getElementById('welcomeScreen');
        const welcomeProgress = document.getElementById('welcomeProgressBar');

        let readyToReveal = false;
        let loadProgress = 0;
        const pageLoadTime = Date.now();

        // Start with city animation showing
        welcomeScreen.classList.add('show-city');

        // Animate progress bar
        function updateWelcomeProgress(percent) {
            loadProgress = percent;
            welcomeProgress.style.width = Math.min(100, percent) + '%';
        }

        // Reveal the page
        function revealPage() {
            if (readyToReveal) return;
            readyToReveal = true;
            updateWelcomeProgress(100);
            setTimeout(() => welcomeScreen.classList.add('hidden'), 400);
            // Check for comparison URL parameter
            if (typeof checkComparisonUrl === 'function') setTimeout(checkComparisonUrl, 500);
        }

        // Preload the first visible city image
        function preloadInitialImage() {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = `${MEDIA_BASE}/${CONTRACT}/${currentTokenId}.png`;
            });
        }

        // Progress animation - faster gradual increase during city phase (0-1.5s)
        updateWelcomeProgress(10);
        setTimeout(() => updateWelcomeProgress(30), 200);
        setTimeout(() => updateWelcomeProgress(50), 500);
        setTimeout(() => updateWelcomeProgress(70), 900);

        // Track image loading
        let imageLoaded = false;
        preloadInitialImage().then((loaded) => {
            imageLoaded = loaded;
            updateWelcomeProgress(Math.max(loadProgress, 85));
            // If image loaded quickly, reveal sooner
            if (loaded && Date.now() - pageLoadTime > 800) {
                updateWelcomeProgress(95);
                setTimeout(revealPage, 200);
            }
        });

        // After 1.5 seconds of city: check if ready
        setTimeout(() => {
            if (readyToReveal) return;

            if (loadProgress >= 80 || imageLoaded) {
                // Images are ready, reveal now
                updateWelcomeProgress(95);
                setTimeout(revealPage, 200);
            } else {
                // Not ready yet - switch to blob animation briefly
                welcomeScreen.classList.remove('show-city');
                updateWelcomeProgress(75);

                // Continue progress during blob phase
                setTimeout(() => updateWelcomeProgress(85), 400);
                setTimeout(() => updateWelcomeProgress(95), 1000);

                // Reveal after blob plays for ~1.5 seconds
                setTimeout(() => {
                    if (!readyToReveal) revealPage();
                }, 1500);
            }
        }, 1500);

        // Force reveal at 4 seconds max regardless
        setTimeout(revealPage, 4000);

        // Side navigation arrows
        document.getElementById('sideNavPrev').addEventListener('click', () => document.getElementById('prevToken').click());
        document.getElementById('sideNavNext').addEventListener('click', () => document.getElementById('nextToken').click());

        // Keyboard hint overlay - shows once then fades away
        const keyboardHintShown = localStorage.getItem('cities-keyboard-hint-shown');
        if (!keyboardHintShown) {
            setTimeout(() => {
                const hint = document.getElementById('keyboardHintOverlay');
                hint.classList.add('visible');
                setTimeout(() => {
                    hint.classList.remove('visible');
                    localStorage.setItem('cities-keyboard-hint-shown', 'true');
                }, 4000);
            }, 5000); // Show 5 seconds after page loads
        }

        // Token ID slot machine animation
        const tokenInput = document.getElementById('tokenId');
        let lastTokenValue = tokenInput.value;
        tokenInput.addEventListener('input', () => {
            if (tokenInput.value !== lastTokenValue) {
                tokenInput.classList.add('digit-change');
                setTimeout(() => tokenInput.classList.remove('digit-change'), 150);
                lastTokenValue = tokenInput.value;
            }
        });

        // Filter glow effect
        document.querySelectorAll('.filter-grid select').forEach(select => {
            select.addEventListener('change', () => {
                if (select.value) {
                    select.classList.add('has-value', 'just-selected');
                    setTimeout(() => select.classList.remove('just-selected'), 400);
                } else {
                    select.classList.remove('has-value');
                }
            });
        });

        // Sidebar note area - rotating placeholder messages
        const notePlaceholders = [
            'Add a note',
            'Leave a thought',
            'Which city is your fave?',
            'Hello from downtown',
            'Notes from the skyline',
            'Urban observations',
            'City whispers'
        ];
        const notePlaceholder = document.getElementById('notePlaceholder');
        const noteInput = document.getElementById('noteInput');
        const noteCharCount = document.getElementById('noteCharCount');
        const noteArea = document.querySelector('.sidebar-note-area');

        // Pick a random placeholder on load
        if (notePlaceholder && noteInput) {
            const randomPlaceholder = notePlaceholders[Math.floor(Math.random() * notePlaceholders.length)];
            notePlaceholder.innerHTML = randomPlaceholder + '<span class="note-dots">...</span><span class="note-cursor">|</span>';
            noteInput.placeholder = randomPlaceholder + '...';

            notePlaceholder.addEventListener('click', () => {
                noteArea?.classList.add('active');
                noteInput.focus();
            });

            noteInput.addEventListener('input', () => {
                if (noteCharCount) noteCharCount.textContent = noteInput.value.length;
            });

            noteInput.addEventListener('blur', () => {
                if (!noteInput.value.trim()) {
                    noteArea?.classList.remove('active');
                }
            });
        }

        // Navigation bounce at limits
        document.getElementById('prevToken').addEventListener('click', () => {
            if (currentTokenId <= 0) {
                document.getElementById('prevToken').classList.add('at-limit-prev');
                setTimeout(() => document.getElementById('prevToken').classList.remove('at-limit-prev'), 300);
            }
        });
        document.getElementById('nextToken').addEventListener('click', () => {
            if (currentTokenId >= MAX_TOKEN) {
                document.getElementById('nextToken').classList.add('at-limit-next');
                setTimeout(() => document.getElementById('nextToken').classList.remove('at-limit-next'), 300);
            }
        });

        // Heart burst effect on favorite
        const originalSaveFavorite = saveFavorite;
        saveFavorite = function() {
            const wasAdded = originalSaveFavorite();
            if (wasAdded !== false) {
                const heartBtn = document.getElementById('saveFavorite');
                heartBtn.classList.add('burst');
                setTimeout(() => heartBtn.classList.remove('burst'), 350);

                // Create color particles from current palette
                const traits = tokenTraits[currentTokenId];
                if (traits && PALETTE_DATA[traits['Palette']]) {
                    const colors = PALETTE_DATA[traits['Palette']].colors.slice(0, 6);
                    const particles = document.createElement('div');
                    particles.className = 'heart-particles';
                    colors.forEach((color, i) => {
                        const p = document.createElement('div');
                        p.className = 'heart-particle';
                        p.style.background = color;
                        const angle = (i / colors.length) * Math.PI * 2;
                        p.style.setProperty('--tx', `${Math.cos(angle) * 25}px`);
                        p.style.setProperty('--ty', `${Math.sin(angle) * 25}px`);
                        particles.appendChild(p);
                    });
                    heartBtn.appendChild(particles);
                    setTimeout(() => particles.remove(), 500);
                }
            }
        };

        // Owner name color from palette
        function updateOwnerColor() {
            const traits = tokenTraits[currentTokenId];
            if (traits && PALETTE_DATA[traits['Palette']]) {
                const colors = PALETTE_DATA[traits['Palette']].colors;
                const brightColor = colors.find(c => {
                    const r = parseInt(c.slice(1, 3), 16);
                    const g = parseInt(c.slice(3, 5), 16);
                    const b = parseInt(c.slice(5, 7), 16);
                    return (r * 299 + g * 587 + b * 114) / 1000 > 120;
                }) || colors[0];
                const ownerLink = document.querySelector('.owner-display a');
                if (ownerLink) ownerLink.style.color = brightColor;
            }
        }

        // Override displayOwnerInfo to add color
        const originalDisplayOwnerInfo = displayOwnerInfo;
        displayOwnerInfo = function(owner, loading) {
            originalDisplayOwnerInfo(owner, loading);
            if (!loading) setTimeout(updateOwnerColor, 50);
        };

        // ===== GALLERY ROOM EXPERIENCE =====
        const galleryRoom = document.getElementById('galleryRoom');
        const galleryRoomWall = document.getElementById('galleryRoomWall');
        const galleryRoomClose = document.getElementById('galleryRoomClose');
        const galleryRoomToggle = document.getElementById('galleryRoomToggle');

        function getGalleryTokens() {
            if (showingFavoritesOnly) {
                const favs = JSON.parse(localStorage.getItem('cities-favorites') || '[]');
                return favs.map(f => f.tokenId).filter(id => tokenTraits[id]);
            }
            return getGridFilteredTokens();
        }

        // Gallery Room - simplified, just art with edge-based scroll speed
        let galleryScrollPos = 0;
        let galleryScrollSpeed = 0.3; // Base slow speed
        let galleryTargetSpeed = 0.3;
        let galleryAnimFrame = null;
        let galleryWallWidth = 0;
        let galleryHoveredFrame = null;
        let galleryOpenedFromCollector = null; // Track if opened from collector view

        // Touch swipe support for gallery room
        let galleryTouchStartX = 0;
        let galleryTouchStartTime = 0;
        let galleryTouchVelocity = 0;
        let galleryIsTouching = false;
        let galleryTouchMoved = false;

        function openGalleryRoom() {
            const tokens = getGalleryTokens();
            if (tokens.length < 3) return;

            // Track if opened from collector view so we can return there
            galleryOpenedFromCollector = currentCollectorFilter ? { ...currentCollectorFilter } : null;

            // Shuffle and limit tokens - reduce on mobile to prevent crashes
            const isMobile = window.innerWidth <= 768;
            const maxTokens = isMobile ? 20 : 40;
            const shuffled = [...tokens].sort(() => Math.random() - 0.5);
            const displayTokens = shuffled.slice(0, Math.min(maxTokens, shuffled.length));

            // Duplicate for seamless loop
            const allTokens = [...displayTokens, ...displayTokens];

            // Update counter
            document.getElementById('galleryRoomCounter').textContent = `${displayTokens.length} Cities`;

            // Use smaller images (400px width) for gallery to reduce memory
            const imgSize = isMobile ? 200 : 400;
            galleryRoomWall.innerHTML = allTokens.map((id) => `
                <div class="gallery-room-frame" data-token="${id}">
                    <img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=${imgSize}" alt="Cities #${id}" loading="lazy" decoding="async">
                </div>
            `).join('');

            galleryRoom.classList.add('open');
            document.body.style.overflow = 'hidden';

            // Calculate wall width after render with slight delay for images to settle
            setTimeout(() => {
                requestAnimationFrame(() => {
                    galleryWallWidth = galleryRoomWall.scrollWidth / 2;
                    galleryScrollPos = 0;
                    startGalleryScroll();
                });
            }, 100);
        }

        function closeGalleryRoom() {
            galleryRoom.classList.remove('open');
            document.body.style.overflow = '';
            if (galleryAnimFrame) {
                cancelAnimationFrame(galleryAnimFrame);
                galleryAnimFrame = null;
            }
        }

        function startGalleryScroll() {
            function animate() {
                // Only animate if not currently touching
                if (!galleryIsTouching) {
                    // Smoothly interpolate speed (faster deceleration for momentum)
                    const decayRate = Math.abs(galleryScrollSpeed) > 1 ? 0.05 : 0.02;
                    galleryScrollSpeed += (galleryTargetSpeed - galleryScrollSpeed) * decayRate;

                    // Only scroll if not hovering a frame
                    if (!galleryHoveredFrame) {
                        galleryScrollPos += galleryScrollSpeed;

                        // Loop seamlessly (handle both directions)
                        if (galleryScrollPos >= galleryWallWidth) {
                            galleryScrollPos -= galleryWallWidth;
                        } else if (galleryScrollPos < 0) {
                            galleryScrollPos += galleryWallWidth;
                        }

                        galleryRoomWall.style.transform = `translateX(${-galleryScrollPos}px)`;
                    }
                }

                galleryAnimFrame = requestAnimationFrame(animate);
            }
            animate();
        }
        // Expose to window for inline onclick
        window.openGalleryRoom = openGalleryRoom;

        // Mouse position affects scroll speed - edges go faster
        galleryRoom.addEventListener('mousemove', (e) => {
            if (galleryHoveredFrame) return; // Don't change speed when hovering frame

            const x = e.clientX;
            const w = window.innerWidth;
            const edgeZone = w * 0.15; // 15% edge zone on each side

            if (x < edgeZone) {
                // Left edge - scroll right (negative direction), speed up based on how far into edge
                const edgeProgress = 1 - (x / edgeZone);
                galleryTargetSpeed = -0.3 - (edgeProgress * 1.5); // -0.3 to -1.8
            } else if (x > w - edgeZone) {
                // Right edge - scroll left (positive direction), speed up
                const edgeProgress = (x - (w - edgeZone)) / edgeZone;
                galleryTargetSpeed = 0.3 + (edgeProgress * 1.5); // 0.3 to 1.8
            } else {
                // Center - slow base speed
                galleryTargetSpeed = 0.3;
            }
        });

        // Hover on frame - pause and scale up
        galleryRoomWall.addEventListener('mouseenter', (e) => {
            const frame = e.target.closest('.gallery-room-frame');
            if (frame) {
                galleryHoveredFrame = frame;
            }
        }, true);

        galleryRoomWall.addEventListener('mouseleave', (e) => {
            const frame = e.target.closest('.gallery-room-frame');
            if (frame && frame === galleryHoveredFrame) {
                galleryHoveredFrame = null;
            }
        }, true);

        // More controls menu toggle
        const moreControlsToggle = document.getElementById('moreControlsToggle');
        const moreControlsMenu = document.getElementById('moreControlsMenu');

        if (moreControlsToggle && moreControlsMenu) {
            moreControlsToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                moreControlsToggle.classList.toggle('open');
                moreControlsMenu.classList.toggle('open');
            });

            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.more-controls-wrapper')) {
                    moreControlsToggle.classList.remove('open');
                    moreControlsMenu.classList.remove('open');
                }
            });

            // Close menu after clicking any button inside
            moreControlsMenu.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    moreControlsToggle.classList.remove('open');
                    moreControlsMenu.classList.remove('open');
                });
            });
        }

        if (galleryRoomToggle) galleryRoomToggle.addEventListener('click', openGalleryRoom);
        if (galleryRoomClose) galleryRoomClose.addEventListener('click', closeGalleryRoom);
        document.getElementById('galleryRoomBack')?.addEventListener('click', closeGalleryRoom);

        // Gallery room controls
        let galleryPaused = false;
        let gallerySpeedMultiplier = 1;
        const gallerySpeedOptions = [0.5, 1, 2, 3];
        let gallerySpeedIndex = 1;

        document.getElementById('galleryShuffleBtn')?.addEventListener('click', () => {
            shuffleGalleryRoom();
        });

        document.getElementById('galleryPauseBtn')?.addEventListener('click', () => {
            galleryPaused = !galleryPaused;
            const btn = document.getElementById('galleryPauseBtn');
            if (galleryPaused) {
                galleryTargetSpeed = 0;
                btn.textContent = '\u25B6'; // Play symbol
                btn.title = 'Play';
            } else {
                galleryTargetSpeed = 0.5 * gallerySpeedMultiplier;
                btn.textContent = '\u23F8'; // Pause symbol
                btn.title = 'Pause';
            }
        });

        document.getElementById('gallerySpeedBtn')?.addEventListener('click', () => {
            gallerySpeedIndex = (gallerySpeedIndex + 1) % gallerySpeedOptions.length;
            gallerySpeedMultiplier = gallerySpeedOptions[gallerySpeedIndex];
            const btn = document.getElementById('gallerySpeedBtn');
            btn.textContent = gallerySpeedMultiplier + '\u00D7';
            if (!galleryPaused) {
                galleryTargetSpeed = 0.5 * gallerySpeedMultiplier;
            }
        });

        // Add shuffle button to gallery room
        function shuffleGalleryRoom() {
            const tokens = getFilteredTokens();
            if (tokens.length === 0) return;

            const isMobile = window.innerWidth <= 768;
            const maxTokens = isMobile ? 20 : 40;
            const shuffled = [...tokens].sort(() => Math.random() - 0.5);
            const displayTokens = shuffled.slice(0, Math.min(maxTokens, shuffled.length));
            const allTokens = [...displayTokens, ...displayTokens];

            document.getElementById('galleryRoomCounter').textContent = `${displayTokens.length} Cities`;

            const imgSize = isMobile ? 200 : 400;
            galleryRoomWall.innerHTML = allTokens.map((id) => `
                <div class="gallery-room-frame" data-token="${id}">
                    <img src="${MEDIA_BASE}/${CONTRACT}/${id}.png?width=${imgSize}" alt="Cities #${id}" loading="lazy" decoding="async">
                </div>
            `).join('');

            setTimeout(() => {
                requestAnimationFrame(() => {
                    galleryWallWidth = galleryRoomWall.scrollWidth / 2;
                });
            }, 100);
        }

        // Compare mode toggle - handler registered after comparison variables are defined (see line ~11294)

        // ========== LEAVE YOUR MARK ==========
        let playgroundCanvas, playgroundCtx;
        let playgroundPalette = null;
        let playgroundTool = 'dot';
        let playgroundSize = 8; // Fixed size matching grid proportions
        let playgroundMarkColor = null; // Current selected color
        let playgroundMultiColor = false; // Multi-color mode (cycles through palette)
        let playgroundColorIndex = 0; // Index for multi-color cycling
        let playgroundRatio = '4:5'; // Default to 4:5 portrait
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Grid settings - Cities style
        const GRID_BORDER = 40; // Border around the drawable area

        function getRandomPalette() {
            const paletteNames = Object.keys(PALETTE_DATA);
            const name = paletteNames[Math.floor(Math.random() * paletteNames.length)];
            return { name, ...PALETTE_DATA[name] };
        }

        function updatePlaygroundColorButtons() {
            const colorsContainer = document.getElementById('playgroundColors');
            // Remove existing color buttons (keep label)
            colorsContainer.querySelectorAll('.playground-color-btn').forEach(btn => btn.remove());

            if (!playgroundPalette || !playgroundPalette.colors.length) return;

            // Show up to 6 colors from the palette
            const colorsToShow = playgroundPalette.colors.slice(0, 6);
            playgroundMarkColor = colorsToShow[0];

            colorsToShow.forEach((color, idx) => {
                const btn = document.createElement('button');
                btn.className = 'playground-color-btn' + (idx === 0 ? ' active' : '');
                btn.style.background = color;
                btn.title = color;
                btn.dataset.color = color;
                btn.addEventListener('click', () => {
                    // Deactivate multi-color mode when selecting a specific color
                    playgroundMultiColor = false;
                    document.getElementById('playgroundMultiColor')?.classList.remove('active');
                    // Update active state
                    colorsContainer.querySelectorAll('.playground-color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    playgroundMarkColor = color;
                });
                colorsContainer.appendChild(btn);
            });
        }

        function getDrawColor() {
            if (playgroundMultiColor) {
                // Cycle through palette colors
                const colors = playgroundPalette.colors;
                const color = colors[playgroundColorIndex % colors.length];
                playgroundColorIndex++;
                return color;
            }
            return playgroundMarkColor;
        }

        function getCanvasDimensions(ratio) {
            const wrap = document.querySelector('.playground-canvas-wrap');
            const maxW = wrap.clientWidth - 40;
            const maxH = wrap.clientHeight - 40;

            let w, h;
            if (ratio === '1:1') {
                w = h = Math.min(maxW, maxH, 800);
            } else if (ratio === '4:5') {
                h = Math.min(maxH, 900);
                w = h * 0.8;
                if (w > maxW) { w = maxW; h = w / 0.8; }
            } else if (ratio === '9:16') {
                h = Math.min(maxH, 900);
                w = h * 0.5625;
                if (w > maxW) { w = maxW; h = w / 0.5625; }
            }
            return { width: Math.floor(w), height: Math.floor(h) };
        }

        // Grid cell size - also used for brush size
        const GRID_CELL = 24;

        function drawGrid() {
            if (!playgroundCtx || !playgroundPalette) return;

            const w = playgroundCanvas.width;
            const h = playgroundCanvas.height;

            // Fill background
            playgroundCtx.fillStyle = playgroundPalette.bg;
            playgroundCtx.fillRect(0, 0, w, h);

            // Use a palette color for the grid
            const gridColor = playgroundPalette.colors.length > 1
                ? playgroundPalette.colors[Math.floor(playgroundPalette.colors.length / 2)]
                : playgroundPalette.colors[0];

            playgroundCtx.strokeStyle = gridColor;
            playgroundCtx.globalAlpha = 0.3;
            playgroundCtx.lineWidth = 2;
            playgroundCtx.lineCap = 'round';

            // Cities-style isometric diamond grid
            // Diamond dimensions
            const diamondW = GRID_CELL * 2;
            const diamondH = GRID_CELL;
            const dashLen = 10;
            const gapLen = 8;

            // Draw rows of diamonds
            for (let row = 0; row < Math.ceil(h / diamondH) + 2; row++) {
                const offsetX = (row % 2) * (diamondW / 2);
                const y = GRID_BORDER + row * diamondH - diamondH;

                for (let col = -1; col < Math.ceil(w / diamondW) + 1; col++) {
                    const x = GRID_BORDER + col * diamondW + offsetX;

                    // Diamond corners
                    const top = { x: x + diamondW / 2, y: y };
                    const right = { x: x + diamondW, y: y + diamondH / 2 };
                    const bottom = { x: x + diamondW / 2, y: y + diamondH };
                    const left = { x: x, y: y + diamondH / 2 };

                    // Draw dashed lines for each diamond edge
                    const edges = [
                        [top, right],
                        [right, bottom],
                        [bottom, left],
                        [left, top]
                    ];

                    edges.forEach(([p1, p2]) => {
                        // Only draw if within canvas (with border)
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        if (midX < GRID_BORDER || midX > w - GRID_BORDER ||
                            midY < GRID_BORDER || midY > h - GRID_BORDER) return;

                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const ux = dx / len;
                        const uy = dy / len;

                        // Draw dashed line
                        let dist = 0;
                        while (dist < len) {
                            const segLen = Math.min(dashLen, len - dist);
                            const x1 = p1.x + ux * dist;
                            const y1 = p1.y + uy * dist;
                            const x2 = p1.x + ux * (dist + segLen);
                            const y2 = p1.y + uy * (dist + segLen);

                            playgroundCtx.beginPath();
                            playgroundCtx.moveTo(x1, y1);
                            playgroundCtx.lineTo(x2, y2);
                            playgroundCtx.stroke();

                            dist += dashLen + gapLen;
                        }
                    });
                }
            }

            playgroundCtx.globalAlpha = 1;
        }

        function initPlayground() {
            playgroundCanvas = document.getElementById('playgroundCanvas');
            playgroundCtx = playgroundCanvas.getContext('2d');

            // Set canvas size based on ratio
            const dims = getCanvasDimensions(playgroundRatio);
            playgroundCanvas.width = dims.width;
            playgroundCanvas.height = dims.height;

            // Get random palette
            playgroundPalette = getRandomPalette();
            document.getElementById('playgroundPaletteName').textContent = playgroundPalette.name;
            updatePlaygroundColorButtons();
            playgroundColorIndex = 0;

            // Draw grid with background
            drawGrid();
        }

        function resizePlaygroundCanvas() {
            // Save current canvas content
            const imageData = playgroundCtx.getImageData(0, 0, playgroundCanvas.width, playgroundCanvas.height);
            const oldW = playgroundCanvas.width;
            const oldH = playgroundCanvas.height;

            // Get new dimensions
            const dims = getCanvasDimensions(playgroundRatio);
            playgroundCanvas.width = dims.width;
            playgroundCanvas.height = dims.height;

            // Redraw grid
            drawGrid();

            // Restore old content (centered)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = oldW;
            tempCanvas.height = oldH;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

            const offsetX = (playgroundCanvas.width - oldW) / 2;
            const offsetY = (playgroundCanvas.height - oldH) / 2;
            playgroundCtx.drawImage(tempCanvas, Math.max(0, offsetX), Math.max(0, offsetY));
        }

        function drawDot(x, y) {
            // Constrain to drawable area (inside border)
            if (x < GRID_BORDER || x > playgroundCanvas.width - GRID_BORDER ||
                y < GRID_BORDER || y > playgroundCanvas.height - GRID_BORDER) return;

            playgroundCtx.fillStyle = getDrawColor();
            playgroundCtx.beginPath();
            playgroundCtx.arc(x, y, playgroundSize / 2, 0, Math.PI * 2);
            playgroundCtx.fill();
        }

        function drawLine(x1, y1, x2, y2) {
            // Constrain endpoints to drawable area
            x1 = Math.max(GRID_BORDER, Math.min(playgroundCanvas.width - GRID_BORDER, x1));
            y1 = Math.max(GRID_BORDER, Math.min(playgroundCanvas.height - GRID_BORDER, y1));
            x2 = Math.max(GRID_BORDER, Math.min(playgroundCanvas.width - GRID_BORDER, x2));
            y2 = Math.max(GRID_BORDER, Math.min(playgroundCanvas.height - GRID_BORDER, y2));

            playgroundCtx.strokeStyle = getDrawColor();
            playgroundCtx.lineWidth = playgroundSize;
            playgroundCtx.lineCap = 'round';
            playgroundCtx.beginPath();
            playgroundCtx.moveTo(x1, y1);
            playgroundCtx.lineTo(x2, y2);
            playgroundCtx.stroke();
        }

        function handlePlaygroundDraw(e) {
            const rect = playgroundCanvas.getBoundingClientRect();
            const scaleX = playgroundCanvas.width / rect.width;
            const scaleY = playgroundCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (playgroundTool === 'dot') {
                drawDot(x, y);
            } else if (playgroundTool === 'line') {
                if (lastX && lastY) {
                    drawLine(lastX, lastY, x, y);
                }
                lastX = x;
                lastY = y;
            }
        }

        function openPlayground() {
            document.getElementById('playgroundOverlay')?.classList.add('open');
            document.getElementById('heatmapToggle')?.classList.add('active');
            document.body.style.overflow = 'hidden';
            setTimeout(initPlayground, 50);
        }
        // Expose to window for inline onclick
        window.openPlayground = openPlayground;

        function closePlayground() {
            document.getElementById('playgroundOverlay')?.classList.remove('open');
            document.getElementById('heatmapToggle')?.classList.remove('active');
            document.body.style.overflow = '';
        }

        // Event listeners for playground
        document.getElementById('heatmapToggle')?.addEventListener('click', openPlayground);
        document.getElementById('playgroundClose').addEventListener('click', closePlayground);

        document.getElementById('playgroundNewPalette').addEventListener('click', () => {
            playgroundPalette = getRandomPalette();
            document.getElementById('playgroundPaletteName').textContent = playgroundPalette.name;
            updatePlaygroundColorButtons();
            playgroundColorIndex = 0;
            drawGrid();
        });

        document.getElementById('playgroundPaletteName').addEventListener('click', () => {
            document.getElementById('playgroundNewPalette').click();
        });

        document.getElementById('playgroundClear').addEventListener('click', () => {
            playgroundColorIndex = 0;
            drawGrid();
        });

        // Multi-color toggle
        document.getElementById('playgroundMultiColor')?.addEventListener('click', () => {
            const btn = document.getElementById('playgroundMultiColor');
            playgroundMultiColor = !playgroundMultiColor;
            btn.classList.toggle('active', playgroundMultiColor);
            if (playgroundMultiColor) {
                // Deselect specific color buttons
                document.querySelectorAll('.playground-color-btn').forEach(b => b.classList.remove('active'));
                playgroundColorIndex = 0;
            } else {
                // Select first color
                const firstColorBtn = document.querySelector('.playground-color-btn');
                if (firstColorBtn) {
                    firstColorBtn.classList.add('active');
                    playgroundMarkColor = firstColorBtn.dataset.color;
                }
            }
        });

        // Download dropdown
        document.getElementById('playgroundDownloadBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('playgroundDownloadMenu').classList.toggle('open');
        });

        document.addEventListener('click', () => {
            document.getElementById('playgroundDownloadMenu').classList.remove('open');
        });

        document.querySelectorAll('.playground-download-option').forEach(opt => {
            opt.addEventListener('click', () => {
                const ratio = opt.dataset.ratio;
                const size = parseInt(opt.dataset.size);
                downloadPlaygroundImage(ratio, size);
                document.getElementById('playgroundDownloadMenu').classList.remove('open');
            });
        });

        function downloadPlaygroundImage(ratio, baseSize) {
            let exportW, exportH;
            if (ratio === '1:1') {
                exportW = exportH = baseSize;
            } else if (ratio === '4:5') {
                exportW = baseSize;
                exportH = baseSize * 1.25;
            } else if (ratio === '9:16') {
                exportW = baseSize;
                exportH = Math.round(baseSize * 16 / 9);
            }

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportW;
            exportCanvas.height = exportH;
            const exportCtx = exportCanvas.getContext('2d');

            // Fill background
            exportCtx.fillStyle = playgroundPalette.bg;
            exportCtx.fillRect(0, 0, exportW, exportH);

            // Scale and center
            const scaleX = exportW / playgroundCanvas.width;
            const scaleY = exportH / playgroundCanvas.height;
            const scale = Math.min(scaleX, scaleY);
            const offsetX = (exportW - playgroundCanvas.width * scale) / 2;
            const offsetY = (exportH - playgroundCanvas.height * scale) / 2;

            exportCtx.drawImage(playgroundCanvas, offsetX, offsetY, playgroundCanvas.width * scale, playgroundCanvas.height * scale);

            const link = document.createElement('a');
            const ratioStr = ratio.replace(':', 'x');
            link.download = `cities-mark-${playgroundPalette.name.replace(/\s+/g, '-').toLowerCase()}-${ratioStr}-${baseSize}px.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        // Ratio selection
        document.querySelectorAll('.playground-ratio-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.playground-ratio-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playgroundRatio = btn.dataset.ratio;
                resizePlaygroundCanvas();
            });
        });

        // Tool selection
        document.querySelectorAll('.playground-tool').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.playground-tool').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playgroundTool = btn.id.replace('tool', '').toLowerCase();
                lastX = 0;
                lastY = 0;
            });
        });

        // Size selection
        document.querySelectorAll('.playground-size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.playground-size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playgroundSize = parseInt(btn.dataset.size);
            });
        });

        // Canvas drawing events
        document.getElementById('playgroundCanvas').addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastX = 0;
            lastY = 0;
            handlePlaygroundDraw(e);
        });

        document.getElementById('playgroundCanvas').addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            handlePlaygroundDraw(e);
        });

        document.getElementById('playgroundCanvas').addEventListener('mouseup', () => {
            isDrawing = false;
            lastX = 0;
            lastY = 0;
        });

        document.getElementById('playgroundCanvas').addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch support
        document.getElementById('playgroundCanvas').addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            lastX = 0;
            lastY = 0;
            const touch = e.touches[0];
            handlePlaygroundDraw({ clientX: touch.clientX, clientY: touch.clientY });
        }, { passive: false });

        document.getElementById('playgroundCanvas').addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const touch = e.touches[0];
            handlePlaygroundDraw({ clientX: touch.clientX, clientY: touch.clientY });
        }, { passive: false });

        document.getElementById('playgroundCanvas').addEventListener('touchend', () => {
            isDrawing = false;
            lastX = 0;
            lastY = 0;
        });

        // ========== COLLECTION PLANNER ==========
        function updateCollectionPlanner() {
            const planner = document.getElementById('collectionPlanner');
            if (!planner) return;
            const favs = JSON.parse(localStorage.getItem('cities-favorites') || '[]');

            // Only show planner if user has favorites
            if (favs.length === 0) {
                planner.classList.remove('visible');
                return;
            }
            planner.classList.add('visible');

            // Grid Set - any 4 cities
            const gridSetSlots = document.getElementById('gridSetSlots');
            const gridSetStatus = document.getElementById('gridSetStatus');
            const gridCities = favs.slice(0, 4);
            const gridCount = Math.min(gridCities.length, 4);

            let gridHtml = '';
            for (let i = 0; i < 4; i++) {
                if (i < gridCities.length) {
                    const id = gridCities[i];
                    gridHtml += `<div class="collection-set-slot filled" onclick="loadOutput(${id}, true)">
                        <img src="${getSmallThumbnailUrl(id)}" alt="City #${id}">
                    </div>`;
                } else {
                    gridHtml += `<div class="collection-set-slot empty">+</div>`;
                }
            }
            gridSetSlots.innerHTML = gridHtml;
            gridSetStatus.textContent = `${gridCount}/4`;
            gridSetStatus.className = 'collection-set-status ' + (gridCount >= 4 ? 'complete' : gridCount > 0 ? 'partial' : 'empty');

            // Energy Set - one of each time of day
            const energySetSlots = document.getElementById('energySetSlots');
            const energySetStatus = document.getElementById('energySetStatus');
            const energyTypes = ['Dawn', 'Day', 'Dusk', 'Night']; // Maps to Rising, Living, Fading, Resting
            const energyLabels = ['\u2600 Rising', '\u2600 Living', '\u2600 Fading', '\u263D Resting'];

            // Find one city of each energy from favorites
            const energyCities = {};
            favs.forEach(id => {
                const traits = tokenTraits[id];
                if (traits) {
                    const time = traits['Time of Day'];
                    if (time && !energyCities[time]) {
                        energyCities[time] = id;
                    }
                }
            });

            let energyHtml = '';
            let energyCount = 0;
            energyTypes.forEach((type, i) => {
                const id = energyCities[type];
                if (id) {
                    energyCount++;
                    energyHtml += `<div class="collection-set-slot filled" onclick="loadOutput(${id}, true)" title="${energyLabels[i]}">
                        <img src="${getSmallThumbnailUrl(id)}" alt="City #${id}">
                    </div>`;
                } else {
                    energyHtml += `<div class="collection-set-slot empty" title="${energyLabels[i]}">${energyLabels[i].split(' ')[0]}</div>`;
                }
            });
            energySetSlots.innerHTML = energyHtml;
            energySetStatus.textContent = `${energyCount}/4`;
            energySetStatus.className = 'collection-set-status ' + (energyCount >= 4 ? 'complete' : energyCount > 0 ? 'partial' : 'empty');

            // Hide promo if both sets are complete
            const promo = document.getElementById('collectionPromo');
            if (gridCount >= 4 && energyCount >= 4) {
                promo.style.display = 'none';
            } else {
                promo.style.display = 'block';
            }
        }
        // Expose to window for inline onclick
        window.updateCollectionPlanner = updateCollectionPlanner;

        // Update planner when favorites change
        const originalToggleFavorite = typeof toggleCityFavorite === 'function' ? toggleCityFavorite : null;

        // Call initial update after data loads
        setTimeout(updateCollectionPlanner, 2000);

        galleryRoom.addEventListener('click', (e) => {
            if (e.target === galleryRoom || e.target.classList.contains('gallery-room-ambient')) {
                closeGalleryRoom();
            }
        });

        // Click on frame to view that token (but not if swiping)
        galleryRoomWall.addEventListener('click', (e) => {
            // Don't trigger click if user was swiping
            if (galleryTouchMoved) {
                galleryTouchMoved = false;
                return;
            }
            const frame = e.target.closest('.gallery-room-frame');
            if (frame) {
                const tokenId = parseInt(frame.dataset.token);
                // Store that we came from gallery room (to return to collector view later)
                sessionStorage.setItem('cities-gallery-context', JSON.stringify(galleryOpenedFromCollector));
                closeGalleryRoom();
                gridPanel.classList.remove('open');
                viewToggleBtn.classList.remove('grid-open');
                document.body.classList.remove('grid-open');
                loadOutput(tokenId, true);
            }
        });

        // ESC key closes gallery room
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && galleryRoom.classList.contains('open')) {
                closeGalleryRoom();
            }
        });

        // Touch swipe support for gallery room
        galleryRoom.addEventListener('touchstart', (e) => {
            galleryIsTouching = true;
            galleryTouchMoved = false;
            galleryTouchStartX = e.touches[0].clientX;
            galleryTouchStartTime = Date.now();
            galleryScrollSpeed = 0; // Stop auto-scroll while touching
            galleryTargetSpeed = 0;
        }, { passive: true });

        galleryRoom.addEventListener('touchmove', (e) => {
            if (!galleryIsTouching) return;
            const touchX = e.touches[0].clientX;
            const deltaX = galleryTouchStartX - touchX;

            // Mark as moved if dragged more than 10px
            if (Math.abs(deltaX) > 10) {
                galleryTouchMoved = true;
            }

            // Update scroll position directly based on touch movement
            galleryScrollPos += deltaX;

            // Keep within bounds (loop)
            if (galleryScrollPos < 0) {
                galleryScrollPos += galleryWallWidth;
            } else if (galleryScrollPos >= galleryWallWidth) {
                galleryScrollPos -= galleryWallWidth;
            }

            galleryRoomWall.style.transform = `translateX(${-galleryScrollPos}px)`;

            // Calculate velocity for momentum
            const timeDelta = Date.now() - galleryTouchStartTime;
            if (timeDelta > 0) {
                galleryTouchVelocity = deltaX / timeDelta * 16; // Normalize to ~60fps
            }

            galleryTouchStartX = touchX;
            galleryTouchStartTime = Date.now();
        }, { passive: true });

        galleryRoom.addEventListener('touchend', (e) => {
            if (!galleryIsTouching) return;
            galleryIsTouching = false;

            // Apply momentum - glide with deceleration
            const momentum = galleryTouchVelocity * 2;
            if (Math.abs(momentum) > 0.5) {
                galleryScrollSpeed = momentum;
                galleryTargetSpeed = 0.3; // Gradually return to base speed
            } else {
                galleryScrollSpeed = 0.3;
                galleryTargetSpeed = 0.3;
            }
        }, { passive: true });

        // Function to return to collector view from single output
        function returnToCollectorGallery() {
            const contextStr = sessionStorage.getItem('cities-gallery-context');
            if (contextStr) {
                try {
                    const context = JSON.parse(contextStr);
                    if (context && context.name && context.tokens) {
                        currentCollectorFilter = context;
                        document.getElementById('collectorBannerName').textContent = context.name;
                        document.getElementById('collectorBannerCount').textContent = context.tokens.length;
                        document.getElementById('collectorBanner').classList.add('visible');
                        gridMode = 'grid';
                        openGridView();
                        sessionStorage.removeItem('cities-gallery-context');
                        return true;
                    }
                } catch (e) {}
            }
            return false;
        }

        // ========== MOBILE ENHANCEMENTS ==========

        // Haptic feedback helper (defined first so other code can use it)
        function haptic(type = 'light') {
            if ('vibrate' in navigator) {
                const patterns = { light: 10, medium: 25, heavy: 50 };
                navigator.vibrate(patterns[type] || 10);
            }
        }

        // Preload adjacent images for smoother swiping
        function preloadAdjacentImages() {
            if (typeof currentTokenId === 'undefined') return;
            const mintedTokens = Object.keys(tokenTraits).map(Number).sort((a, b) => a - b);
            if (mintedTokens.length === 0) return;
            const currentIndex = mintedTokens.indexOf(currentTokenId);
            if (currentIndex === -1) return;
            const prevId = currentIndex > 0 ? mintedTokens[currentIndex - 1] : mintedTokens[mintedTokens.length - 1];
            const nextId = currentIndex < mintedTokens.length - 1 ? mintedTokens[currentIndex + 1] : mintedTokens[0];
            const prevImg = new Image();
            prevImg.src = getPreviewUrl(prevId);
            const nextImg = new Image();
            nextImg.src = getPreviewUrl(nextId);
        }

        // Mobile bottom bar controls
        const mobileBottomBar = document.getElementById('mobileBottomBar') || document.getElementById('mobileBottomBar2');
        const mobileBottomBar2 = document.getElementById('mobileBottomBar2');
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const mobilePrevBtn = document.getElementById('mobilePrevBtn');
        const mobileHeartBtn = document.getElementById('mobileHeartBtn');
        const mobileNextBtn = document.getElementById('mobileNextBtn');
        const mobileGridBtn = document.getElementById('mobileGridBtn');

        // Update mobile heart button state
        function updateMobileHeartState() {
            if (mobileHeartBtn && typeof currentTokenId !== 'undefined') {
                mobileHeartBtn.classList.toggle('favorited', isCityFavorited(currentTokenId));
            }
        }

        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => {
                haptic('light');
                const mobSheet = document.getElementById('mobileSheet');
                const mobOverlay = document.getElementById('mobileSheetOverlay');
                if (mobSheet?.classList.contains('open')) {
                    mobSheet.classList.remove('open');
                    mobOverlay?.classList.remove('open');
                } else {
                    mobSheet?.classList.add('open');
                    mobOverlay?.classList.add('open');
                }
            });
        }

        if (mobilePrevBtn) {
            mobilePrevBtn.addEventListener('click', () => {
                haptic('light');
                document.getElementById('prevToken')?.click();
            });
        }

        if (mobileNextBtn) {
            mobileNextBtn.addEventListener('click', () => {
                haptic('light');
                document.getElementById('nextToken')?.click();
            });
        }

        if (mobileHeartBtn) {
            mobileHeartBtn.addEventListener('click', () => {
                haptic('medium');
                document.getElementById('saveFavorite')?.click();
                setTimeout(updateMobileHeartState, 50);
            });
        }

        if (mobileGridBtn) {
            mobileGridBtn.addEventListener('click', () => {
                haptic('light');
                if (gridPanel && gridPanel.classList.contains('open')) {
                    closeGridView();
                } else {
                    openGridView();
                }
            });
        }

        // Listen for image loads to update mobile state
        if (previewImage) {
            previewImage.addEventListener('load', () => {
                updateMobileHeartState();
                preloadAdjacentImages();
            });
        }

        // Watch for grid panel open/close
        if (gridPanel) {
            const gridPanelObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        const isOpen = gridPanel.classList.contains('open');
                        if (mobileGridBtn) mobileGridBtn.classList.toggle('active', isOpen);
                        if (mobileBottomBar) {
                            mobileBottomBar.style.display = (isOpen || window.innerWidth > 768) ? 'none' : 'flex';
                        }
                        if (mobileBottomBar2) {
                            mobileBottomBar2.style.display = (isOpen || window.innerWidth > 768) ? 'none' : 'flex';
                        }
                    }
                });
            });
            gridPanelObserver.observe(gridPanel, { attributes: true });
        }

        // Double-tap to favorite
        const doubleTapHeart = document.getElementById('doubleTapHeart');
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;

        if (previewImage) {
            previewImage.addEventListener('touchend', (e) => {
                if (typeof isFullscreen !== 'undefined' && isFullscreen) return;

                const currentTime = Date.now();
                const touch = e.changedTouches[0];
                if (!touch) return;

                const tapX = touch.clientX;
                const tapY = touch.clientY;
                const timeDiff = currentTime - lastTapTime;
                const distDiff = Math.sqrt(Math.pow(tapX - lastTapX, 2) + Math.pow(tapY - lastTapY, 2));

                if (timeDiff < 300 && distDiff < 50) {
                    haptic('heavy');

                    if (doubleTapHeart) {
                        doubleTapHeart.style.left = (tapX - 40) + 'px';
                        doubleTapHeart.style.top = (tapY - 40) + 'px';
                        doubleTapHeart.classList.remove('show');
                        void doubleTapHeart.offsetWidth;
                        doubleTapHeart.classList.add('show');
                    }

                    if (typeof currentTokenId !== 'undefined' && !isCityFavorited(currentTokenId)) {
                        document.getElementById('saveFavorite')?.click();
                        updateMobileHeartState();
                    }
                    lastTapTime = 0;
                } else {
                    lastTapTime = currentTime;
                    lastTapX = tapX;
                    lastTapY = tapY;
                }
            });
        }

        // Pull to refresh / shuffle
        const pullRefreshIndicator = document.getElementById('pullRefreshIndicator');
        const pullRefreshText = pullRefreshIndicator?.querySelector('.refresh-text');
        let pullStartY = 0;
        let pullCurrentY = 0;
        let isPulling = false;
        const pullThreshold = 100;

        function isAtTop() {
            const gridContent = document.getElementById('gridContent');
            if (gridPanel && gridPanel.classList.contains('open') && gridContent) {
                return gridContent.scrollTop <= 0;
            }
            return true;
        }

        function scramblePalettes() {
            const gridContent = document.getElementById('gridContent');
            if (!gridContent) return;
            const groups = Array.from(gridContent.querySelectorAll('.grid-group'));
            if (groups.length === 0) return;
            for (let i = groups.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                gridContent.appendChild(groups[j]);
            }
            groups.forEach((group, i) => {
                group.style.animation = 'none';
                void group.offsetWidth;
                group.style.animation = `fadeSlideIn 0.3s ease forwards ${i * 0.02}s`;
            });
        }

        document.addEventListener('touchstart', (e) => {
            if (isAtTop() && (typeof isFullscreen === 'undefined' || !isFullscreen)) {
                pullStartY = e.touches[0]?.clientY || 0;
                isPulling = true;
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!isPulling || !pullRefreshIndicator) return;
            pullCurrentY = e.touches[0]?.clientY || 0;
            const pullDistance = pullCurrentY - pullStartY;

            if (pullDistance > 20 && isAtTop()) {
                pullRefreshIndicator.classList.add('visible');
                if (pullDistance > pullThreshold) {
                    pullRefreshIndicator.classList.add('pulling');
                    if (pullRefreshText) pullRefreshText.textContent = 'Release to shuffle';
                } else {
                    pullRefreshIndicator.classList.remove('pulling');
                    if (pullRefreshText) pullRefreshText.textContent = 'Pull to shuffle';
                }
                const translateY = Math.min(pullDistance * 0.4, 60);
                pullRefreshIndicator.style.transform = `translateX(-50%) translateY(${translateY}px)`;
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (!isPulling || !pullRefreshIndicator) return;
            const pullDistance = pullCurrentY - pullStartY;

            if (pullDistance > pullThreshold && isAtTop()) {
                haptic('heavy');
                pullRefreshIndicator.classList.add('refreshing');
                pullRefreshIndicator.classList.remove('pulling');
                if (pullRefreshText) pullRefreshText.textContent = 'Shuffling...';

                setTimeout(() => {
                    if (gridPanel && gridPanel.classList.contains('open') && gridMode === 'palette') {
                        scramblePalettes();
                    } else if (gridPanel && gridPanel.classList.contains('open')) {
                        renderGrid();
                    } else {
                        document.getElementById('randomFiltered')?.click();
                    }
                    setTimeout(() => {
                        pullRefreshIndicator.classList.remove('visible', 'pulling', 'refreshing');
                        pullRefreshIndicator.style.transform = 'translateX(-50%)';
                        if (pullRefreshText) pullRefreshText.textContent = 'Pull to shuffle';
                    }, 300);
                }, 200);
            } else {
                pullRefreshIndicator.classList.remove('visible', 'pulling');
                pullRefreshIndicator.style.transform = 'translateX(-50%)';
            }
            isPulling = false;
            pullStartY = 0;
            pullCurrentY = 0;
        });

        // Shake to scramble
        if (window.DeviceMotionEvent) {
            let shakeThreshold = 15;
            let lastShakeTime = 0;
            let lastX = 0, lastY = 0, lastZ = 0;

            window.addEventListener('devicemotion', (e) => {
                const acceleration = e.accelerationIncludingGravity;
                if (!acceleration) return;

                const currentTime = Date.now();
                if (currentTime - lastShakeTime < 1000) return;

                const deltaX = Math.abs(acceleration.x - lastX);
                const deltaY = Math.abs(acceleration.y - lastY);
                const deltaZ = Math.abs(acceleration.z - lastZ);

                if ((deltaX > shakeThreshold && deltaY > shakeThreshold) ||
                    (deltaX > shakeThreshold && deltaZ > shakeThreshold) ||
                    (deltaY > shakeThreshold && deltaZ > shakeThreshold)) {
                    lastShakeTime = currentTime;
                    haptic('heavy');

                    if (gridPanel && gridPanel.classList.contains('open') && gridMode === 'palette') {
                        scramblePalettes();
                    } else if (!gridPanel || !gridPanel.classList.contains('open')) {
                        document.getElementById('randomFiltered')?.click();
                    }
                }

                lastX = acceleration.x;
                lastY = acceleration.y;
                lastZ = acceleration.z;
            });
        }

        // Resize handler
        window.addEventListener('resize', () => {
            const isGridOpen = gridPanel && gridPanel.classList.contains('open');
            const showBar = (window.innerWidth <= 768 && !isGridOpen) ? 'flex' : 'none';
            if (mobileBottomBar) mobileBottomBar.style.display = showBar;
            if (mobileBottomBar2) mobileBottomBar2.style.display = showBar;
        });

        // About modal
        const aboutModal = document.getElementById('aboutModal');
        const aboutTrigger = document.getElementById('aboutTrigger');
        const gridAboutTrigger = document.getElementById('gridAboutTrigger');
        const aboutExploreBtn = document.getElementById('aboutExploreBtn');
        const aboutMintBtn = document.getElementById('aboutMintBtn');

        function openAboutModal(e) {
            if (e) e.preventDefault();
            const modal = document.getElementById('aboutModal');
            if (modal) {
                modal.classList.add('open');
                document.body.classList.add('about-open');
                // Hide mint button if sold out
                const isSoldOut = document.getElementById('supplyTracker')?.classList.contains('sold-out');
                const mintBtn = document.getElementById('aboutMintBtn');
                if (mintBtn) {
                    mintBtn.style.display = isSoldOut ? 'none' : 'flex';
                }
                // Update minted count - sync with sidebar count
                const mintedCountEl = document.getElementById('aboutMintedCount');
                const sidebarMinted = document.getElementById('mintedCount')?.textContent;
                if (mintedCountEl) {
                    mintedCountEl.textContent = sidebarMinted && sidebarMinted !== 'â€”' ? sidebarMinted : (MAX_TOKEN + 1);
                }
                // Update collector count
                const collectorCountEl = document.getElementById('aboutCollectorCount');
                if (collectorCountEl && typeof COLLECTORS_DATA !== 'undefined') {
                    collectorCountEl.textContent = COLLECTORS_DATA.length;
                }
                // Start countdown timer
                if (typeof updateMintCountdown === 'function') {
                    updateMintCountdown();
                } else {
                    // Fallback - update countdown directly
                    const now = Date.now();
                    const deadline = new Date('2026-03-31T22:00:00Z').getTime();
                    const remaining = deadline - now;
                    if (remaining > 0) {
                        const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const mins = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                        const secs = Math.floor((remaining % (1000 * 60)) / 1000);
                        const daysEl = document.getElementById('countdownDays');
                        const hoursEl = document.getElementById('countdownHours');
                        const minsEl = document.getElementById('countdownMins');
                        const secsEl = document.getElementById('countdownSecs');
                        if (daysEl) daysEl.textContent = String(days).padStart(2, '0');
                        if (hoursEl) hoursEl.textContent = String(hours).padStart(2, '0');
                        if (minsEl) minsEl.textContent = String(mins).padStart(2, '0');
                        if (secsEl) secsEl.textContent = String(secs).padStart(2, '0');
                    }
                }
            } else {
                console.error('About modal not found');
            }
        }
        // Expose to window for inline onclick
        window.openAboutModal = openAboutModal;

        // Mint countdown timer - March 31, 2026 at 6:00 PM ET (10:00 PM UTC)
        const MINT_DEADLINE = new Date('2026-03-31T22:00:00Z').getTime();
        let countdownInterval = null;

        function updateMintCountdown() {
            const now = Date.now();
            const remaining = MINT_DEADLINE - now;
            const countdownEl = document.getElementById('aboutCountdown');

            if (remaining <= 0) {
                // Hide countdown when expired (already hidden by default)
                if (countdownInterval) clearInterval(countdownInterval);
                return;
            }

            // Show countdown only if there's time remaining
            if (countdownEl) countdownEl.style.display = 'block';

            const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
            const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const mins = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            const secs = Math.floor((remaining % (1000 * 60)) / 1000);

            const daysEl = document.getElementById('countdownDays');
            const hoursEl = document.getElementById('countdownHours');
            const minsEl = document.getElementById('countdownMins');
            const secsEl = document.getElementById('countdownSecs');

            if (daysEl) daysEl.textContent = String(days).padStart(2, '0');
            if (hoursEl) hoursEl.textContent = String(hours).padStart(2, '0');
            if (minsEl) minsEl.textContent = String(mins).padStart(2, '0');
            if (secsEl) secsEl.textContent = String(secs).padStart(2, '0');

            // Update every second while modal is open
            if (!countdownInterval) {
                countdownInterval = setInterval(() => {
                    if (document.getElementById('aboutModal')?.classList.contains('open')) {
                        updateMintCountdown();
                    }
                }, 1000);
            }
        }

        // Check countdown immediately on load to hide if expired
        updateMintCountdown();

        function closeAboutModal() {
            const modal = document.getElementById('aboutModal');
            if (modal) modal.classList.remove('open');
            document.body.classList.remove('about-open');
        }
        window.closeAboutModal = closeAboutModal;

        // Collect popover toggle
        function toggleCollectPopover(btn) {
            const wrapper = btn.closest('.collect-btn-wrapper');
            const popover = wrapper.querySelector('.collect-popover');
            const isOpen = popover.classList.contains('open');

            // Close all other popovers first
            document.querySelectorAll('.collect-popover.open').forEach(p => p.classList.remove('open'));

            if (!isOpen) {
                popover.classList.add('open');
            }
        }
        window.toggleCollectPopover = toggleCollectPopover;

        // Close popover when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.collect-btn-wrapper')) {
                document.querySelectorAll('.collect-popover.open').forEach(p => p.classList.remove('open'));
            }
        });

        // Show set example in wall view
        function showSetExample(setType, collectorName) {
            // Find the collector
            const collector = COLLECTORS_DATA.find(c =>
                c.name.toLowerCase() === collectorName.toLowerCase()
            );
            if (!collector || !collector.tokens || collector.tokens.length === 0) {
                console.warn('Collector not found:', collectorName);
                return;
            }

            // Close about modal first
            closeAboutModal();

            // Small delay to let about modal close, then open wall view
            setTimeout(() => {
                openWallView(collector.name, collector.tokens);
            }, 150);
        }
        window.showSetExample = showSetExample;

        function toggleAboutModal(e) {
            if (e) e.preventDefault();
            const modal = document.getElementById('aboutModal');
            if (modal?.classList.contains('open')) {
                closeAboutModal();
            } else {
                openAboutModal();
            }
        }
        window.toggleAboutModal = toggleAboutModal;

        if (aboutTrigger) {
            aboutTrigger.addEventListener('click', openAboutModal);
        }
        if (gridAboutTrigger) {
            gridAboutTrigger.addEventListener('click', openAboutModal);
        }

        // Close button
        document.getElementById('aboutCloseBtn')?.addEventListener('click', closeAboutModal);

        if (aboutExploreBtn) {
            aboutExploreBtn.addEventListener('click', closeAboutModal);
        }

        // Timeline button in about modal
        document.getElementById('aboutTimelineBtn')?.addEventListener('click', () => {
            closeAboutModal();
            openTimeline();
        });

        // Origins button in about modal
        document.getElementById('aboutOriginsBtn')?.addEventListener('click', () => {
            closeAboutModal();
            openTimeline();
        });

        // Close about modal on clicking outside content (click on modal background)
        if (aboutModal) {
            aboutModal.addEventListener('click', (e) => {
                // Only close if clicking directly on the modal backdrop, not its children
                if (e.target === aboutModal) {
                    closeAboutModal();
                }
            });
            // Stop propagation from content area
            const aboutContent = aboutModal.querySelector('.about-content');
            if (aboutContent) {
                aboutContent.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
        }

        // Expandable sections in about modal use inline onclick handlers
        // (removed duplicate addEventListener that was causing double-toggle)

        // Origins section opens timeline
        document.getElementById('openTimeline')?.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAboutModal();
            openTimeline();
        });

        // Expandable sections in timeline header
        document.querySelectorAll('.timeline-section-header').forEach(header => {
            header.addEventListener('click', () => {
                const section = header.closest('.timeline-section');
                section.classList.toggle('open');
            });
        });

        // Timeline subsection toggles (level 2)
        document.querySelectorAll('.timeline-subsection-header').forEach(header => {
            header.addEventListener('click', (e) => {
                e.stopPropagation();
                const subsection = header.closest('.timeline-subsection');
                subsection.classList.toggle('open');
            });
        });

        // Timeline functionality
        const timelineView = document.getElementById('timelineView');
        const timelineClose = document.getElementById('timelineClose');
        const openTimelineBtn = document.getElementById('openTimeline');
        const sidebarOriginalsBtn = document.getElementById('sidebarOriginalsBtn');
        const gridOriginalsBtn = document.getElementById('gridOriginalsBtn');

        // Thank you messages that rotate on each load
        const thankYouMessages = [
            "To the collectors who saw something worth holding onto â€” you made this possible.",
            "Every piece found its home because someone believed in the vision.",
            "Art lives when it's collected. Thank you for giving these works a life.",
            "From my walls to yours â€” grateful for every collector who took the leap.",
            "You didn't just collect art. You supported a dream.",
            "Three years of Cities, made real by the people who believed early.",
            "To those who collect with their hearts â€” this journey is yours too."
        ];

        function openTimeline() {
            aboutModal?.classList.remove('open');
            timelineView.classList.add('open');
            document.body.style.overflow = 'hidden';
            // Set random thank you message
            const thanksEl = document.getElementById('thanksMessage');
            if (thanksEl) {
                thanksEl.textContent = thankYouMessages[Math.floor(Math.random() * thankYouMessages.length)];
            }
            // Initialize entrance animations
            initTimelineAnimations();
            // Preload images near viewport
            setTimeout(preloadTimelineImages, 100);
        }
        // Expose to window for inline onclick
        window.openTimeline = openTimeline;

        // Add lazy loading to all timeline images for faster initial load
        document.querySelectorAll('.timeline-item img, .timeline-item video, .timeline-group-item img').forEach(el => {
            el.loading = 'lazy';
            el.decoding = 'async';
        });

        // Preload visible timeline images when timeline opens
        function preloadTimelineImages() {
            const viewportHeight = window.innerHeight;
            document.querySelectorAll('.timeline-item img, .timeline-group-item img').forEach(img => {
                const rect = img.getBoundingClientRect();
                // Preload images within 2 viewport heights
                if (rect.top < viewportHeight * 2) {
                    img.loading = 'eager';
                }
            });
        }

        // Timeline entrance animations
        function initTimelineAnimations() {
            const timelineItems = document.querySelectorAll('.timeline-item');

            // Entrance animation observer
            const entranceObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

            // Description visibility observer - only one fully visible at a time
            const descObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                        // Remove in-view from all others
                        timelineItems.forEach(item => item.classList.remove('in-view'));
                        entry.target.classList.add('in-view');
                    }
                });
            }, { threshold: [0.5], rootMargin: '-30% 0px -30% 0px' });

            timelineItems.forEach(item => {
                entranceObserver.observe(item);
                descObserver.observe(item);
            });
        }

        // Open timeline from About modal
        openTimelineBtn?.addEventListener('click', openTimeline);

        // Open timeline from sidebar (single output mode)
        sidebarOriginalsBtn?.addEventListener('click', openTimeline);

        // Open timeline from grid header
        gridOriginalsBtn?.addEventListener('click', openTimeline);

        // Open timeline from story link in sidebar
        document.getElementById('storyLink')?.addEventListener('click', (e) => {
            e.preventDefault();
            openTimeline();
        });

        // Collector message removed from single output view - info lives in collector section

        // Close timeline
        function closeTimelineView() {
            timelineView.classList.remove('open');
            document.body.style.overflow = '';
        }

        timelineClose?.addEventListener('click', closeTimelineView);

        // Explore buttons at bottom of timeline
        document.getElementById('exploreGridBtn')?.addEventListener('click', () => {
            closeTimelineView();
            setTimeout(() => {
                document.getElementById('gridPanel').classList.add('open');
                renderGrid();
            }, 300);
        });

        document.getElementById('exploreCollectorsBtn')?.addEventListener('click', () => {
            closeTimelineView();
            setTimeout(() => {
                if (window.openCollectorsList) openCollectorsList();
            }, 300);
        });

        document.getElementById('exploreOriginsBtn')?.addEventListener('click', () => {
            closeTimelineView();
            setTimeout(() => {
                if (window.renderOriginsGrid) renderOriginsGrid();
                document.getElementById('gridPanel').classList.add('open');
            }, 300);
        });

        // Video controls - play/pause and volume
        const videoPlayPauseBtn = document.getElementById('videoPlayPauseBtn');
        const videoVolumeBtn = document.getElementById('videoVolumeBtn');
        const vimeoIframe = document.getElementById('timelineVimeoPlayer');

        let videoIsPlaying = true;
        let volumeState = 0; // 0 = muted, 1 = low, 2 = medium

        if (vimeoIframe && videoPlayPauseBtn && videoVolumeBtn) {
            // Load Vimeo Player API
            const vimeoScript = document.createElement('script');
            vimeoScript.src = 'https://player.vimeo.com/api/player.js';
            vimeoScript.onload = () => {
                const player = new Vimeo.Player(vimeoIframe);

                // Play/Pause control
                videoPlayPauseBtn.addEventListener('click', () => {
                    if (videoIsPlaying) {
                        player.pause();
                        videoPlayPauseBtn.querySelector('.play-icon').textContent = 'â–¶';
                        videoPlayPauseBtn.classList.remove('active');
                    } else {
                        player.play();
                        videoPlayPauseBtn.querySelector('.play-icon').textContent = 'â¸';
                        videoPlayPauseBtn.classList.add('active');
                    }
                    videoIsPlaying = !videoIsPlaying;
                });

                // Set initial state to playing
                player.play().then(() => {
                    videoPlayPauseBtn.querySelector('.play-icon').textContent = 'â¸';
                    videoPlayPauseBtn.classList.add('active');
                }).catch(() => {});

                // Volume control - cycles through: muted -> low -> medium -> muted
                videoVolumeBtn.addEventListener('click', () => {
                    volumeState = (volumeState + 1) % 3;
                    const volumeIcon = videoVolumeBtn.querySelector('.volume-icon');
                    const volumeIndicator = videoVolumeBtn.querySelector('.volume-indicator');

                    if (volumeState === 0) {
                        player.setVolume(0);
                        volumeIcon.textContent = 'ðŸ”‡';
                        volumeIndicator.textContent = 'Muted';
                        videoVolumeBtn.classList.remove('active');
                    } else if (volumeState === 1) {
                        player.setVolume(0.3);
                        volumeIcon.textContent = 'ðŸ”ˆ';
                        volumeIndicator.textContent = 'Low';
                        videoVolumeBtn.classList.add('active');
                    } else {
                        player.setVolume(0.6);
                        volumeIcon.textContent = 'ðŸ”Š';
                        volumeIndicator.textContent = 'Medium';
                        videoVolumeBtn.classList.add('active');
                    }
                });
            };
            document.head.appendChild(vimeoScript);
        }

        // Marfa video controls
        const marfaPlayPauseBtn = document.getElementById('marfaPlayPauseBtn');
        const marfaMuteBtn = document.getElementById('marfaMuteBtn');
        const marfaIframe = document.getElementById('marfaVimeoPlayer');

        let marfaIsPlaying = false;
        let marfaIsMuted = true;

        if (marfaIframe && marfaPlayPauseBtn && marfaMuteBtn) {
            // Wait for Vimeo API to be ready (already loaded above)
            const initMarfaPlayer = () => {
                if (typeof Vimeo === 'undefined') {
                    setTimeout(initMarfaPlayer, 100);
                    return;
                }
                const marfaPlayer = new Vimeo.Player(marfaIframe);

                // Play/Pause control
                marfaPlayPauseBtn.addEventListener('click', () => {
                    if (marfaIsPlaying) {
                        marfaPlayer.pause();
                        marfaPlayPauseBtn.querySelector('.play-icon').style.display = 'inline';
                        marfaPlayPauseBtn.querySelector('.pause-icon').style.display = 'none';
                    } else {
                        marfaPlayer.play();
                        marfaPlayPauseBtn.querySelector('.play-icon').style.display = 'none';
                        marfaPlayPauseBtn.querySelector('.pause-icon').style.display = 'inline';
                    }
                    marfaIsPlaying = !marfaIsPlaying;
                });

                // Mute/Unmute control
                marfaMuteBtn.addEventListener('click', () => {
                    if (marfaIsMuted) {
                        marfaPlayer.setVolume(0.7);
                        marfaMuteBtn.querySelector('.unmuted-icon').style.display = 'inline';
                        marfaMuteBtn.querySelector('.muted-icon').style.display = 'none';
                    } else {
                        marfaPlayer.setVolume(0);
                        marfaMuteBtn.querySelector('.unmuted-icon').style.display = 'none';
                        marfaMuteBtn.querySelector('.muted-icon').style.display = 'inline';
                    }
                    marfaIsMuted = !marfaIsMuted;
                });

                // Set initial muted state
                marfaPlayer.setVolume(0);
                marfaMuteBtn.querySelector('.unmuted-icon').style.display = 'none';
                marfaMuteBtn.querySelector('.muted-icon').style.display = 'inline';
            };
            initMarfaPlayer();
        }

        // Timeline grid button - goes to origins grid view
        const timelineGridBtn = document.getElementById('timelineGridBtn');
        timelineGridBtn?.addEventListener('click', () => {
            // Close timeline
            timelineView.classList.remove('open');
            document.body.style.overflow = '';
            // Open grid panel with origins view
            document.getElementById('gridPanel').classList.add('open');
            document.querySelectorAll('.grid-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('gridOriginsBtn')?.classList.add('active');
            gridMode = 'origins';
            renderOriginsGrid();
        });

        // Timeline year nav - scroll to year and highlight active
        const timelineYearNav = document.getElementById('timelineYearNav');
        const yearNavItems = document.querySelectorAll('.timeline-year-nav-item');

        yearNavItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const year = item.dataset.year;
                const yearEl = document.querySelector(`.timeline-year[data-year="${year}"]`);
                if (yearEl) {
                    yearEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        });

        // Update active year on scroll (throttled with rAF)
        if (timelineView) {
            let timelineScrollTicking = false;
            timelineView.addEventListener('scroll', () => {
                if (!timelineScrollTicking) {
                    timelineScrollTicking = true;
                    requestAnimationFrame(() => {
                        const yearEls = document.querySelectorAll('.timeline-year[data-year]');
                        let activeYear = null;
                        yearEls.forEach(el => {
                            const rect = el.getBoundingClientRect();
                            if (rect.top < window.innerHeight / 2) {
                                activeYear = el.dataset.year;
                            }
                        });
                        yearNavItems.forEach(item => {
                            item.classList.toggle('active', item.dataset.year === activeYear);
                        });
                        timelineScrollTicking = false;
                    });
                }
            }, { passive: true });
        }

        // Timeline inline action buttons (download and share for physical pieces)
        document.querySelectorAll('.timeline-action-inline.download-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const item = btn.closest('.timeline-item');
                const imgUrl = item?.dataset.img;
                const title = item?.dataset.title || 'artwork';
                if (imgUrl) {
                    const link = document.createElement('a');
                    link.href = imgUrl;
                    link.download = `${title.replace(/\s+/g, '-').toLowerCase()}.jpg`;
                    link.target = '_blank';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            });
        });

        document.querySelectorAll('.timeline-action-inline.share-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const item = btn.closest('.timeline-item');
                const title = item?.dataset.title || 'Efdot artwork';
                const link = item?.dataset.link || 'https://efdotstudio.com/murals';
                const text = `${title} by @eloisefdot`;
                const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(link)}`;
                window.open(tweetUrl, '_blank', 'width=550,height=420');
            });
        });

        // Populate timeline preview grid with curated outputs - 3 rows scrolling like bricks
        const timelinePreviewGrid = document.getElementById('timelinePreviewGrid');
        const previewTokensRow1 = [0, 7, 23, 42, 56, 89, 112, 156, 193, 217, 267, 301, 0, 7, 23, 42];
        const previewTokensRow2 = [15, 33, 67, 98, 134, 178, 203, 245, 289, 310, 15, 33, 67, 98];
        const previewTokensRow3 = [5, 19, 48, 77, 101, 145, 188, 222, 256, 295, 5, 19, 48, 77];

        if (timelinePreviewGrid) {
            [previewTokensRow1, previewTokensRow2, previewTokensRow3].forEach((tokens, rowIndex) => {
                const row = document.createElement('div');
                row.className = `preview-row preview-row-${rowIndex + 1}`;
                tokens.forEach(token => {
                    const img = document.createElement('img');
                    img.src = `${MEDIA_BASE}/${CONTRACT}/${token}.png`;
                    img.alt = `Cities #${token}`;
                    img.loading = 'lazy';
                    img.addEventListener('click', () => {
                        timelineView.classList.remove('open');
                        document.body.style.overflow = '';
                        currentIndex = token;
                        updateDisplay();
                        if (gridPanel.classList.contains('open')) {
                            gridPanel.classList.remove('open');
                        }
                    });
                    row.appendChild(img);
                });
                timelinePreviewGrid.appendChild(row);
            });
        }

        // Explore Collection button - close timeline and open grid
        const exploreCollectionBtn = document.getElementById('exploreCollectionBtn');
        exploreCollectionBtn?.addEventListener('click', () => {
            timelineView.classList.remove('open');
            document.body.style.overflow = '';
            gridPanel.classList.add('open');
            gridPanel.setAttribute('aria-hidden', 'false');
        });

        // Email capture form
        const emailForm = document.getElementById('emailCaptureForm');
        emailForm?.addEventListener('submit', (e) => {
            e.preventDefault();
            const email = document.getElementById('emailInput').value;
            // Open ConvertKit/Substack subscription in new tab
            // Replace with your actual ConvertKit form URL
            window.open(`https://efdot.substack.com/subscribe?email=${encodeURIComponent(email)}`, '_blank');
            document.getElementById('emailInput').value = '';
            showStatus('Redirecting to subscribe...', 'success');
        });

        // Timeline Zoom View
        const timelineZoom = document.getElementById('timelineZoom');
        const timelineZoomClose = document.getElementById('timelineZoomClose');
        const timelineZoomPrev = document.getElementById('timelineZoomPrev');
        const timelineZoomNext = document.getElementById('timelineZoomNext');
        const timelineZoomArtwork = document.getElementById('timelineZoomArtwork');
        const timelineZoomTitle = document.getElementById('timelineZoomTitle');
        const timelineZoomYear = document.getElementById('timelineZoomYear');
        const timelineZoomDesc = document.getElementById('timelineZoomDesc');
        const timelineZoomProvenance = document.getElementById('timelineZoomProvenance');
        const timelineZoomStrip = document.getElementById('timelineZoomStrip');

        // Collect all zoomable timeline items (both standalone items and grouped items)
        const zoomableItems = Array.from(document.querySelectorAll('.timeline-item[data-title], .timeline-group-item[data-title]')).filter(item => {
            // Exclude italy grid, culmination, and physicals section
            return !item.classList.contains('italy') && !item.classList.contains('culmination') && !item.classList.contains('physicals-section');
        });
        let currentZoomIndex = 0;

        // Print links for pieces that have prints available
        // type: 'poster' = open edition museum poster, 'edition' = signed/numbered screen print
        // remaining: number left for limited editions
        const printLinks = {
            'Street View': { url: 'https://shop.efdotstudio.com/products/street-view-print', type: 'poster' },
            'Traffic on the Avenue': { url: 'https://shop.efdotstudio.com/products/traffic-on-the-avenue-print', type: 'poster' },
            'Roundabout': { url: 'https://shop.efdotstudio.com/products/roundabout-print', type: 'poster' },
            'Silent Skyline': { url: 'https://shop.efdotstudio.com/products/silent-skyline-print', type: 'poster' },
            'Midnight In Manhattan': { url: 'https://shop.efdotstudio.com/products/midnight-in-manhattan-print', type: 'poster' },
            'You Are Here': { url: 'https://shop.efdotstudio.com/products/you-are-here-print', type: 'edition', remaining: 2 },
            'Sweet Streets': { url: 'https://shop.efdotstudio.com/products/sweet-streets-print', type: 'edition', remaining: 8 },
            'Soft Swerve': { url: 'https://shop.efdotstudio.com/products/soft-swerve-print', type: 'edition', remaining: 7 }
        };

        const timelineZoomPrice = document.getElementById('timelineZoomPrice');
        const timelineZoomPrint = document.getElementById('timelineZoomPrint');

        function updateZoomView(index) {
            const item = zoomableItems[index];
            if (!item) return;

            const imgEl = item.querySelector('img');
            const imgSrc = imgEl ? imgEl.src : (item.dataset.img || '');
            const title = item.dataset.title || '';
            // Check for year in element or data attribute (group items use data-year)
            const year = item.querySelector('.timeline-item-year')?.textContent || item.dataset.year || '';
            const desc = item.querySelector('.timeline-item-desc')?.textContent || '';
            const provenanceEl = item.querySelector('.timeline-provenance');
            // For group items, also check for collector name to show provenance
            const collectorEl = item.querySelector('.timeline-group-item-collector');
            const link = item.dataset.link || '';

            timelineZoomArtwork.src = imgSrc;
            timelineZoomTitle.textContent = title;
            timelineZoomYear.textContent = year;
            timelineZoomDesc.textContent = desc;

            if (provenanceEl) {
                const name = provenanceEl.querySelector('.provenance-name')?.textContent || '';
                timelineZoomProvenance.innerHTML = name ? `<a href="${link}" target="_blank">âŸ</a> ${name}` : '';
            } else if (collectorEl) {
                // For group items, use the collector name
                const collectorName = collectorEl.textContent || '';
                if (collectorName && collectorName !== 'Available') {
                    timelineZoomProvenance.innerHTML = `<a href="${link}" target="_blank">âŸ</a> ${collectorName}`;
                } else if (collectorName === 'Available') {
                    timelineZoomProvenance.innerHTML = `<a href="${link}" target="_blank">Available on SuperRare â†’</a>`;
                } else {
                    timelineZoomProvenance.innerHTML = '';
                }
            } else {
                timelineZoomProvenance.innerHTML = '';
            }

            // Show print button if print available
            if (printLinks[title]) {
                const printInfo = printLinks[title];
                timelineZoomPrint.href = printInfo.url;
                if (printInfo.type === 'edition') {
                    const remainingText = printInfo.remaining ? ` Â· ${printInfo.remaining} left` : '';
                    timelineZoomPrint.innerHTML = `âœŽ Signed Edition${remainingText}`;
                } else {
                    timelineZoomPrint.innerHTML = 'ðŸ–¼ Poster Available';
                }
                timelineZoomPrint.classList.add('visible');
            } else {
                timelineZoomPrint.classList.remove('visible');
            }

            // Show Make Offer button for collected 1/1s
            const timelineZoomOffer = document.getElementById('timelineZoomOffer');
            if (timelineZoomOffer && provenanceEl && link) {
                timelineZoomOffer.href = link;
                timelineZoomOffer.classList.add('visible');
            } else if (timelineZoomOffer) {
                timelineZoomOffer.classList.remove('visible');
            }

            // Update thumbnails
            document.querySelectorAll('.timeline-zoom-thumb').forEach((thumb, i) => {
                thumb.classList.toggle('active', i === index);
            });

            currentZoomIndex = index;
        }

        function openZoomView(index) {
            // Build thumbnail strip if empty
            if (timelineZoomStrip.children.length === 0) {
                zoomableItems.forEach((item, i) => {
                    const imgEl = item.querySelector('img');
                    const src = imgEl ? imgEl.src : (item.dataset.img || '');
                    const thumb = document.createElement('img');
                    thumb.src = src;
                    thumb.className = 'timeline-zoom-thumb';
                    thumb.addEventListener('click', () => updateZoomView(i));
                    timelineZoomStrip.appendChild(thumb);
                });
            }

            updateZoomView(index);
            timelineZoom.classList.add('open');
        }

        // Add share/action buttons to timeline items
        zoomableItems.forEach((item) => {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'timeline-item-actions';

            const title = item.dataset.title || '';
            const link = item.dataset.link || '';
            const imgEl = item.querySelector('img');
            const imgSrc = imgEl ? imgEl.src : '';

            // Share button
            const shareBtn = document.createElement('button');
            shareBtn.className = 'timeline-action-btn';
            shareBtn.innerHTML = 'â†—';
            shareBtn.title = 'Share';
            shareBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const shareText = `${title} by @eaboricua â€” part of the Cities collection`;
                if (navigator.share) {
                    navigator.share({ title, text: shareText, url: link || window.location.href });
                } else {
                    navigator.clipboard.writeText(link || window.location.href);
                    showStatus('Link copied!', 'success');
                }
            });

            // Download button (if image available)
            if (imgSrc) {
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'timeline-action-btn';
                downloadBtn.innerHTML = 'â†“';
                downloadBtn.title = 'Save image';
                downloadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const a = document.createElement('a');
                    a.href = imgSrc;
                    a.download = `${title.replace(/\s+/g, '-').toLowerCase()}.png`;
                    a.target = '_blank';
                    a.click();
                });
                actionsDiv.appendChild(downloadBtn);
            }

            actionsDiv.appendChild(shareBtn);
            item.appendChild(actionsDiv);
        });

        // Timeline item clicks - open FRAMED view first (not zoom)
        let currentFrameIndex = 0;
        const timelineFrame = document.getElementById('timelineFrame');
        const timelineFrameImage = document.getElementById('timelineFrameImage');
        const timelineFrameTitle = document.getElementById('timelineFrameTitle');
        const timelineFrameYear = document.getElementById('timelineFrameYear');
        const timelineFrameClose = document.getElementById('timelineFrameClose');
        const timelineFramePrev = document.getElementById('timelineFramePrev');
        const timelineFrameNext = document.getElementById('timelineFrameNext');
        const timelineFrameMode = document.getElementById('timelineFrameMode');
        const timelineFrameViewBtn = document.getElementById('timelineFrameViewBtn');

        function updateFrameView(index) {
            const item = zoomableItems[index];
            if (!item) return;

            const imgEl = item.querySelector('img');
            const imgSrc = imgEl ? imgEl.src : (item.dataset.img || '');
            const title = item.dataset.title || '';
            const year = item.dataset.year || '';
            const link = item.dataset.link || '';

            timelineFrameImage.src = imgSrc;
            timelineFrameTitle.textContent = title;
            timelineFrameYear.textContent = year;

            // Store link for view button
            timelineFrameViewBtn.dataset.link = link;
            timelineFrameViewBtn.textContent = link ? 'View Artwork â†’' : 'Close';

            // Update nav buttons
            timelineFramePrev.disabled = zoomableItems.length <= 1;
            timelineFrameNext.disabled = zoomableItems.length <= 1;

            currentFrameIndex = index;
        }

        function openFrameView(index) {
            updateFrameView(index);
            timelineFrame.classList.add('open');
        }

        function closeFrameView() {
            timelineFrame.classList.remove('open');
        }

        zoomableItems.forEach((item, index) => {
            item.addEventListener('click', (e) => {
                // Don't open frame if clicking provenance link or action buttons
                if (e.target.closest('.provenance-link') || e.target.closest('.timeline-action-btn')) return;
                openFrameView(index);
            });
        });

        // Frame view navigation
        timelineFrameClose?.addEventListener('click', closeFrameView);
        timelineFramePrev?.addEventListener('click', () => {
            const newIndex = (currentFrameIndex - 1 + zoomableItems.length) % zoomableItems.length;
            updateFrameView(newIndex);
        });
        timelineFrameNext?.addEventListener('click', () => {
            const newIndex = (currentFrameIndex + 1) % zoomableItems.length;
            updateFrameView(newIndex);
        });

        // Light/dark mode toggle for frame view
        timelineFrameMode?.addEventListener('click', () => {
            timelineFrame.classList.toggle('light-mode');
            timelineFrameMode.textContent = timelineFrame.classList.contains('light-mode') ? 'â˜¼' : 'â˜¾';
        });

        // View artwork button - opens external link with warning
        timelineFrameViewBtn?.addEventListener('click', () => {
            const link = timelineFrameViewBtn.dataset.link;
            if (link) {
                const confirmed = confirm('You are about to leave Cities Explorer and visit an external site. Continue?');
                if (confirmed) {
                    window.open(link, '_blank');
                }
            } else {
                closeFrameView();
            }
        });

        // Click outside frame to close
        timelineFrame?.addEventListener('click', (e) => {
            if (e.target === timelineFrame || e.target.classList.contains('timeline-frame-content')) {
                closeFrameView();
            }
        });

        // Keyboard navigation for frame view
        document.addEventListener('keydown', (e) => {
            if (!timelineFrame?.classList.contains('open')) return;

            if (e.key === 'Escape') {
                closeFrameView();
            } else if (e.key === 'ArrowLeft') {
                const newIndex = (currentFrameIndex - 1 + zoomableItems.length) % zoomableItems.length;
                updateFrameView(newIndex);
            } else if (e.key === 'ArrowRight') {
                const newIndex = (currentFrameIndex + 1) % zoomableItems.length;
                updateFrameView(newIndex);
            } else if (e.key === 'Enter') {
                timelineFrameViewBtn?.click();
            }
        });

        // Zoom navigation
        timelineZoomClose?.addEventListener('click', () => timelineZoom.classList.remove('open'));
        timelineZoomPrev?.addEventListener('click', () => {
            const newIndex = (currentZoomIndex - 1 + zoomableItems.length) % zoomableItems.length;
            updateZoomView(newIndex);
            document.getElementById('loupe')?.classList.remove('visible');
        });
        timelineZoomNext?.addEventListener('click', () => {
            const newIndex = (currentZoomIndex + 1) % zoomableItems.length;
            updateZoomView(newIndex);
            document.getElementById('loupe')?.classList.remove('visible');
        });

        // Zoom view share/download buttons
        const zoomShareBtn = document.getElementById('zoomShareBtn');
        const zoomDownloadBtn = document.getElementById('zoomDownloadBtn');

        zoomShareBtn?.addEventListener('click', () => {
            const item = zoomableItems[currentZoomIndex];
            const title = item?.dataset.title || 'Cities artwork';
            const link = item?.dataset.link || window.location.href;
            const shareText = `${title} by @eaboricua â€” part of the Cities collection`;
            if (navigator.share) {
                navigator.share({ title, text: shareText, url: link });
            } else {
                navigator.clipboard.writeText(link);
                showStatus('Link copied!', 'success');
            }
        });

        zoomDownloadBtn?.addEventListener('click', () => {
            const item = zoomableItems[currentZoomIndex];
            const title = item?.dataset.title || 'artwork';
            const imgSrc = timelineZoomArtwork.src;
            if (imgSrc) {
                const a = document.createElement('a');
                a.href = imgSrc;
                a.download = `${title.replace(/\s+/g, '-').toLowerCase()}.png`;
                a.target = '_blank';
                a.click();
            }
        });

        // Magnifying Loupe functionality
        const loupeBtn = document.getElementById('loupeBtn');
        const loupe = document.getElementById('loupe');
        const loupeInner = document.getElementById('loupeInner');
        const zoomMain = document.querySelector('.timeline-zoom-main');
        let loupeActive = false;
        const loupeZoom = 3; // 3x magnification
        const loupeSize = 180;

        loupeBtn?.addEventListener('click', () => {
            loupeActive = !loupeActive;
            loupeBtn.classList.toggle('active', loupeActive);
            if (!loupeActive) {
                loupe.classList.remove('visible');
            }
        });

        // Update loupe on mouse move over artwork
        timelineZoomArtwork?.addEventListener('mousemove', (e) => {
            if (!loupeActive) return;

            const rect = timelineZoomArtwork.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Position loupe at cursor
            loupe.style.left = `${e.clientX - loupeSize / 2}px`;
            loupe.style.top = `${e.clientY - loupeSize / 2}px`;

            // Calculate background position for zoom
            const bgX = (x / rect.width) * 100;
            const bgY = (y / rect.height) * 100;

            loupeInner.style.backgroundImage = `url(${timelineZoomArtwork.src})`;
            loupeInner.style.backgroundSize = `${rect.width * loupeZoom}px ${rect.height * loupeZoom}px`;
            loupeInner.style.backgroundPosition = `${bgX}% ${bgY}%`;

            loupe.classList.add('visible');
        });

        timelineZoomArtwork?.addEventListener('mouseenter', () => {
            if (loupeActive) {
                timelineZoomArtwork.style.cursor = 'none';
            }
        });

        timelineZoomArtwork?.addEventListener('mouseleave', () => {
            loupe.classList.remove('visible');
            timelineZoomArtwork.style.cursor = loupeActive ? 'crosshair' : 'default';
        });

        // Reset loupe when changing artwork
        const originalUpdateZoomView = window.updateZoomView;
        const resetLoupe = () => {
            loupe.classList.remove('visible');
        };

        // Disable loupe when closing zoom view
        timelineZoomClose?.addEventListener('click', () => {
            loupeActive = false;
            loupeBtn?.classList.remove('active');
            loupe.classList.remove('visible');
        });

        // Keyboard navigation for zoom (arrows only)
        document.addEventListener('keydown', (e) => {
            // Frame mockup navigation handled by main keydown handler
            if (document.getElementById('frameMockup')?.classList.contains('open')) return;
            if (!timelineZoom.classList.contains('open')) return;
            if (e.key === 'ArrowLeft') timelineZoomPrev?.click();
            if (e.key === 'ArrowRight') timelineZoomNext?.click();
        });

        // Italy Gallery
        const italyGallery = document.getElementById('italyGallery');
        const italyGalleryGrid = document.getElementById('italyGalleryGrid');
        const italyGalleryClose = document.getElementById('italyGalleryClose');

        const italyPieces = [
            { title: 'Echo Hill', collector: 'Soren Wrenn', img: 'https://images.ninfa.io/nfts/original/c8330669474b599172d9caf56c186cb5d60a1483ae7a114734313a20ca8b8df1.jpeg' },
            { title: 'Around the Duomo', collector: 'Soren Wrenn', img: 'https://images.ninfa.io/nfts/original/ea9a2b42ef67db20ce7fb63c592e9f75036e874df9ea593835384ede046be449.jpeg' },
            { title: 'Through The Piazza', collector: 'M Studio', img: 'https://images.ninfa.io/nfts/original/e9ff95e5215d28b765cabcb3b2360520266c86d74683b7ecaa59630f5e0db086.jpeg' },
            { title: 'Shifted Shadow', collector: 'Almost Serious Gallery', img: 'https://images.ninfa.io/nfts/original/c16d801ae69e5ed00046d63b8ed30be387e477297a62767d1178f142add4a31b.jpeg' },
            { title: 'Last Lap', collector: 'Georgie', img: 'https://images.ninfa.io/nfts/original/ed64013129837544d5fe74e63f414a6c74fee743b95f9e5223e911ac0303a476.jpeg' },
            { title: 'Radial Intent', collector: 'R Alderman', img: 'https://images.ninfa.io/nfts/original/a2cc2905f3f49f56757890038b3cf715bcc4139a05660b378f43b4fa9c93b9af.jpeg' },
            { title: 'Across the Arno', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/d3ca7d2aa862e1ff132864f703c8680d1038bc470c279db28909cbaa0c8c79ad.jpeg' },
            { title: 'Drawn To Center', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/fa42a57fcc480226220ec5cf90dd1a6b58a567ccf49b52f35c9ee91170498a63.jpeg' },
            { title: 'Walled Memory', collector: 'BatSoupYum', img: 'https://images.ninfa.io/nfts/original/f9bd77a279884e9b4ed1edeaa8f213cec0f8c210a4558eb2f6c01c021f540200.jpeg' }
        ];

        function openItalyGallery() {
            // Populate grid
            italyGalleryGrid.innerHTML = italyPieces.map(piece => `
                <div class="italy-gallery-item">
                    <div class="italy-gallery-frame">
                        <img src="${piece.img}" alt="${piece.title}">
                    </div>
                    <div class="italy-gallery-info">
                        <div class="italy-gallery-name">${piece.title}</div>
                        <div class="italy-gallery-collector">${piece.collector ? `Collected by ${piece.collector}` : 'Available'}</div>
                    </div>
                </div>
            `).join('');
            italyGallery.classList.add('open');
        }

        italyGalleryClose?.addEventListener('click', () => {
            italyGallery.classList.remove('open');
        });

        // Italy grid click - open gallery view
        document.querySelector('.timeline-item.italy')?.addEventListener('click', (e) => {
            if (!e.target.classList.contains('collector-link')) {
                e.preventDefault();
                openItalyGallery();
            }
        });

        // Timeline "more" button toggle for descriptions
        document.querySelectorAll('.timeline-more-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const wrapper = btn.closest('.timeline-desc-wrapper');
                wrapper.classList.toggle('expanded');
            });
        });

        // Timeline collector links - click to view their collection
        document.querySelectorAll('.timeline-italy-collectors .collector-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.stopPropagation();
                const collectorName = link.dataset.collector;
                if (collectorName) {
                    // Close timeline and open collector view
                    timelineView.classList.remove('open');
                    document.body.style.overflow = '';
                    fetchCollectorTokens(collectorName, true); // true = from timeline
                }
            });
        });

        // Unified ESC key navigation - closes views in proper hierarchy
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const lightbox = document.getElementById('originsLightbox');
                const playgroundOverlay = document.getElementById('playgroundOverlay');
                const frameMockupEl = document.getElementById('frameMockup');
                const italyGalleryEl = document.getElementById('italyGallery');
                const timelineFrameEl = document.getElementById('timelineFrame');

                const aboutModalEl = document.getElementById('aboutModal');

                // Priority 0: Close about modal (most common, easy escape)
                if (aboutModalEl?.classList.contains('open')) {
                    aboutModalEl.classList.remove('open');
                    return;
                }

                // Priority 0.5: Close Italy gallery if open
                if (italyGalleryEl?.classList.contains('open')) {
                    italyGalleryEl.classList.remove('open');
                    return;
                }

                // Priority 1: Close Leave Your Mark playground if open
                if (playgroundOverlay?.classList.contains('open')) {
                    closePlayground();
                    return;
                }

                // Priority 2: Close frame mockup if open
                if (frameMockupEl?.classList.contains('open')) {
                    closeFrameMockup();
                    return;
                }

                // Priority 3: Close lightbox if open
                if (lightbox?.classList.contains('open')) {
                    lightbox.classList.remove('open');
                    return;
                }

                // Priority 3.5: Close timeline frame view (back to timeline)
                if (timelineFrameEl?.classList.contains('open')) {
                    timelineFrameEl.classList.remove('open');
                    return;
                }

                // Priority 4: Close fullscreen zoom view (back to timeline)
                if (timelineZoom?.classList.contains('open')) {
                    timelineZoom.classList.remove('open');
                    return;
                }

                // Priority 5: Close timeline view entirely
                if (timelineView?.classList.contains('open')) {
                    timelineView.classList.remove('open');
                    document.body.style.overflow = '';
                    return;
                }
            }
        });

        // Origins Lightbox functionality
        const originsLightbox = document.getElementById('originsLightbox');
        const originsLightboxImg = document.getElementById('originsLightboxImg');
        const originsLightboxTitle = document.getElementById('originsLightboxTitle');
        const originsLightboxYear = document.getElementById('originsLightboxYear');
        const originsLightboxPrice = document.getElementById('originsLightboxPrice');
        const originsLightboxBtn = document.getElementById('originsLightboxBtn');
        const originsLightboxClose = document.getElementById('originsLightboxClose');

        // Close lightbox
        originsLightboxClose?.addEventListener('click', () => {
            originsLightbox.classList.remove('open');
        });

        originsLightbox?.addEventListener('click', (e) => {
            if (e.target === originsLightbox) {
                originsLightbox.classList.remove('open');
            }
        });

        // Physical items lightbox
        document.querySelectorAll('.physical-item[data-img]').forEach(item => {
            item.style.cursor = 'pointer';
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const img = item.dataset.img;
                const title = item.dataset.title;
                const price = item.dataset.price || '';
                const link = item.dataset.link;

                originsLightboxImg.src = img;
                originsLightboxTitle.textContent = title;
                originsLightboxYear.textContent = 'Original Artwork';
                originsLightboxPrice.textContent = price;
                originsLightboxBtn.href = link;
                originsLightboxBtn.textContent = 'View in Shop';
                originsLightbox.classList.add('open');
            });
        });

        // ========== SIMPLIFIED BUTTON HANDLERS ==========
        // These are added at the end to ensure all functions are defined

        // Grid nav buttons
        document.getElementById('gridTimelineBtn')?.addEventListener('click', function() {
            console.log('Timeline button clicked');
            if (window.openTimeline) window.openTimeline();
            else if (typeof openTimeline === 'function') openTimeline();
        });

        document.getElementById('gridCompareBtn')?.addEventListener('click', function() {
            console.log('Compare button clicked');
            if (window.showComparisonSelectUI) window.showComparisonSelectUI();
            else if (typeof showComparisonSelectUI === 'function') showComparisonSelectUI();
        });

        document.getElementById('gridGalleryBtn')?.addEventListener('click', function() {
            console.log('Gallery button clicked');
            if (window.openGalleryRoom) window.openGalleryRoom();
            else if (typeof openGalleryRoom === 'function') openGalleryRoom();
        });

        // Sidebar footer buttons
        document.getElementById('sidebarTimelineBtn')?.addEventListener('click', function() {
            console.log('Sidebar Timeline button clicked');
            if (window.openTimeline) window.openTimeline();
            else if (typeof openTimeline === 'function') openTimeline();
        });

        document.getElementById('sidebarAboutBtn')?.addEventListener('click', function() {
            console.log('Sidebar About button clicked');
            if (window.openAboutModal) window.openAboutModal();
            else if (typeof openAboutModal === 'function') openAboutModal();
        });

        // Drift Mode - Meditative Screensaver Gallery
        (function() {
            const driftMode = document.getElementById('driftMode');
            const driftTrack = document.getElementById('driftTrack');
            const driftClose = document.getElementById('driftClose');
            const driftToggle = document.getElementById('driftToggle');

            let driftAnimationId = null;
            let driftPosition = 0;
            let driftSpeed = 0.3; // Base speed (pixels per frame)
            let driftTargetSpeed = 0.3;
            let driftItems = [];

            function getThumbnailUrlForDrift(tokenId) {
                return `https://cities-images.efdotstudio.com/thumbnails/${tokenId}.jpg`;
            }

            function openDriftMode() {
                // Get favorites or random harmonized selection
                let tokens = [];
                try {
                    const favs = JSON.parse(localStorage.getItem('cities-favorites') || '[]');
                    tokens = favs.map(f => f.tokenId);
                } catch(e) {}

                // If no favorites, pick random harmonized set
                if (tokens.length < 5) {
                    const allTokens = [];
                    for (let i = 0; i <= 320; i++) allTokens.push(i);
                    // Shuffle and pick 20
                    for (let i = allTokens.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allTokens[i], allTokens[j]] = [allTokens[j], allTokens[i]];
                    }
                    tokens = allTokens.slice(0, 20);
                }

                // Duplicate tokens for infinite scroll effect
                const displayTokens = [...tokens, ...tokens, ...tokens];

                driftTrack.innerHTML = displayTokens.map(tokenId => `
                    <div class="drift-item" data-token="${tokenId}">
                        <div class="drift-frame">
                            <img src="${getThumbnailUrlForDrift(tokenId)}" alt="Cities #${tokenId}" loading="lazy">
                            <div class="drift-label">#${tokenId}</div>
                        </div>
                    </div>
                `).join('');

                driftItems = driftTrack.querySelectorAll('.drift-item');
                driftPosition = 0;
                driftMode.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Start animation
                animateDrift();
            }

            function closeDriftMode() {
                driftMode.classList.remove('active');
                document.body.style.overflow = '';
                if (driftAnimationId) {
                    cancelAnimationFrame(driftAnimationId);
                    driftAnimationId = null;
                }
            }

            function animateDrift() {
                // Smooth speed interpolation
                driftSpeed += (driftTargetSpeed - driftSpeed) * 0.05;

                driftPosition -= driftSpeed;

                // Get track width for looping
                const itemWidth = 280 + 12 + 12 + 60; // img + padding + gap
                const totalWidth = driftItems.length * itemWidth;
                const resetPoint = totalWidth / 3;

                // Loop back when we've scrolled one third
                if (Math.abs(driftPosition) >= resetPoint) {
                    driftPosition += resetPoint;
                }

                driftTrack.style.transform = `translateY(-50%) translateX(${driftPosition}px)`;

                driftAnimationId = requestAnimationFrame(animateDrift);
            }

            // Mouse position affects speed
            driftMode.addEventListener('mousemove', (e) => {
                const x = e.clientX / window.innerWidth;
                // Left side = slow (0.2), right side = fast (3)
                driftTargetSpeed = 0.2 + (x * x * 4);
            });

            // Reset speed when mouse leaves
            driftMode.addEventListener('mouseleave', () => {
                driftTargetSpeed = 0.3;
            });

            // Click item to view
            driftTrack.addEventListener('click', (e) => {
                const item = e.target.closest('.drift-item');
                if (item) {
                    const tokenId = item.dataset.token;
                    closeDriftMode();
                    // Open wall view for this token
                    if (window.openWallView) {
                        window.openWallView(tokenId, driftMode.classList.contains('light') ? 'light' : 'dark');
                    } else {
                        // Fallback: navigate to token
                        loadToken(parseInt(tokenId));
                    }
                }
            });

            // Close button
            driftClose.addEventListener('click', closeDriftMode);

            // Toggle light/dark
            driftToggle.addEventListener('click', () => {
                driftMode.classList.toggle('light');
                driftMode.classList.toggle('dark');
                driftToggle.textContent = driftMode.classList.contains('light') ? 'Dark' : 'Light';
            });

            // ESC to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && driftMode.classList.contains('active')) {
                    closeDriftMode();
                }
                // Secret trigger: Shift+D for Drift mode
                if (e.key === 'D' && e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    if (driftMode.classList.contains('active')) {
                        closeDriftMode();
                    } else {
                        openDriftMode();
                    }
                }
            });

            // Expose globally
            window.openDriftMode = openDriftMode;
            window.closeDriftMode = closeDriftMode;
        })();

        // Water droplet animation for yellow pill buttons
        (function() {
            let lastDropletTime = 0;

            function createDroplets(btn) {
                // Only trigger occasionally (20% chance, max once per 3 seconds)
                const now = Date.now();
                if (now - lastDropletTime < 3000) return;
                if (Math.random() > 0.2) return;

                lastDropletTime = now;

                // Create two droplets
                const leftDroplet = document.createElement('span');
                const rightDroplet = document.createElement('span');

                leftDroplet.className = 'pill-droplet left';
                rightDroplet.className = 'pill-droplet right';

                btn.appendChild(leftDroplet);
                btn.appendChild(rightDroplet);

                // Remove after animation
                setTimeout(() => {
                    leftDroplet.remove();
                    rightDroplet.remove();
                }, 1200);
            }

            // Add hover listener to all yellow pill buttons
            document.addEventListener('mouseenter', (e) => {
                const btn = e.target.closest('.collector-guide-pill-btn:not(.secondary)');
                if (btn) createDroplets(btn);
            }, true);
        })();

        // Secret triggers for Drift Mode
        (function() {
            // Konami-style: type C-I-T-Y from any view
            const secretCode = ['c', 'i', 't', 'y'];
            let codeIndex = 0;
            let codeTimer = null;

            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const key = e.key.toLowerCase();

                // Check if key matches next in sequence
                if (key === secretCode[codeIndex]) {
                    codeIndex++;

                    // Reset timer
                    if (codeTimer) clearTimeout(codeTimer);
                    codeTimer = setTimeout(() => {
                        codeIndex = 0;
                    }, 2000); // 2 seconds to complete sequence

                    // Full sequence entered
                    if (codeIndex === secretCode.length) {
                        codeIndex = 0;
                        if (codeTimer) clearTimeout(codeTimer);
                        if (window.openDriftMode) {
                            window.openDriftMode();
                        }
                    }
                } else {
                    // Wrong key, reset
                    codeIndex = 0;
                }

                // Spacebar in grid view opens drift mode
                if (e.key === ' ' && document.getElementById('gridPanel')?.classList.contains('open')) {
                    // Make sure we're not in an input
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        if (window.openDriftMode) {
                            window.openDriftMode();
                        }
                    }
                }
            });
        })();


        // Energy Quadrant View
        function openEnergyQuadrant() {
            const modal = document.getElementById('energyQuadrantModal');
            if (!modal || !COLLECTORS_DATA || COLLECTORS_DATA.length === 0) return;

            // Build energy-to-collector mapping
            const energyCollectors = { Rising: [], Living: [], Fading: [], Resting: [] };

            COLLECTORS_DATA.forEach(collector => {
                if (!collector.tokens || collector.tokens.length === 0) return;
                const energyCounts = { Rising: 0, Living: 0, Fading: 0, Resting: 0 };
                collector.tokens.forEach(tokenId => {
                    const traits = tokenTraits[tokenId];
                    if (traits && traits['Energy'] && energyCounts.hasOwnProperty(traits['Energy'])) {
                        energyCounts[traits['Energy']]++;
                    }
                });
                ALL_ENERGIES.forEach(energy => {
                    if (energyCounts[energy] > 0) {
                        energyCollectors[energy].push({
                            name: collector.name,
                            count: energyCounts[energy],
                            total: collector.count,
                            tokens: collector.tokens
                        });
                    }
                });
            });

            // Sort each quadrant by count descending
            ALL_ENERGIES.forEach(energy => {
                energyCollectors[energy].sort((a, b) => b.count - a.count);
            });

            // Render each quadrant
            const quadrantIds = { Rising: 'eqRising', Living: 'eqLiving', Fading: 'eqFading', Resting: 'eqResting' };
            let totalCollectors = 0;

            // Helper: get accent color from a collector's most recently minted city
            function getCollectorAccentColor(tokens) {
                if (!tokens || tokens.length === 0) return null;
                const mostRecent = Math.max(...tokens);
                const traits = tokenTraits[mostRecent];
                if (traits && traits['Palette'] && PALETTE_DATA[traits['Palette']]) {
                    const colors = PALETTE_DATA[traits['Palette']].colors;
                    // Pick a visible accent â€” try index 2, then 1, then 0
                    return colors[2] || colors[1] || colors[0] || null;
                }
                return null;
            }

            function hexToRgb(hex) {
                const h = hex.replace('#', '');
                return [parseInt(h.substring(0,2),16), parseInt(h.substring(2,4),16), parseInt(h.substring(4,6),16)];
            }

            // Count total cities per energy across all collectors
            const energyCityTotals = { Rising: 0, Living: 0, Fading: 0, Resting: 0 };

            // Helper: get best palette bg color for a collector's cities (uses most-owned city palette)
            function getCollectorPaletteBg(tokens) {
                if (!tokens || tokens.length === 0) return null;
                // Count palette frequency
                const paletteCounts = {};
                tokens.forEach(id => {
                    const traits = tokenTraits[id];
                    if (traits && traits['Palette']) {
                        paletteCounts[traits['Palette']] = (paletteCounts[traits['Palette']] || 0) + 1;
                    }
                });
                // Get most common palette
                const sorted = Object.entries(paletteCounts).sort((a, b) => b[1] - a[1]);
                if (sorted.length > 0) {
                    const paletteName = sorted[0][0];
                    const paletteInfo = PALETTE_DATA[paletteName];
                    if (paletteInfo) {
                        // Use a mid-tone color from the palette for the pill background
                        const colors = paletteInfo.colors || [];
                        return colors[1] || colors[0] || paletteInfo.bg || null;
                    }
                }
                return null;
            }

            // Helper: pick black or white text for contrast against a background
            function getContrastTextColor(hexBg) {
                const h = hexBg.replace('#', '');
                const r = parseInt(h.substring(0, 2), 16);
                const g = parseInt(h.substring(2, 4), 16);
                const b = parseInt(h.substring(4, 6), 16);
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                return luminance > 0.45 ? '#111111' : '#ffffff';
            }

            ALL_ENERGIES.forEach(energy => {
                const container = document.getElementById(quadrantIds[energy]);
                if (!container) return;
                const collectors = energyCollectors[energy];
                totalCollectors += collectors.length;

                // Sum total cities for this energy
                const energyTotal = collectors.reduce((sum, c) => sum + c.count, 0);
                energyCityTotals[energy] = energyTotal;

                // Update the total label
                const totalEl = document.getElementById('eqTotal' + energy);
                if (totalEl) {
                    totalEl.textContent = `${collectors.length} collectors Â· ${energyTotal} cities`;
                }

                container.innerHTML = collectors.map(c => {
                    const displayName = formatCollectorName(c.name).toUpperCase();
                    const isLarge = c.count >= 3;
                    const pillBg = getCollectorPaletteBg(c.tokens) || '#555';
                    const textColor = getContrastTextColor(pillBg);
                    const [r, g, b] = hexToRgb(pillBg);
                    const countColor = textColor === '#111111' ? 'rgba(0,0,0,0.45)' : 'rgba(255,255,255,0.55)';
                    const hoverBg = textColor === '#111111' ? `rgba(${r},${g},${b},0.85)` : `rgba(${Math.min(r+30,255)},${Math.min(g+30,255)},${Math.min(b+30,255)},1)`;
                    return `<div class="eq-chip${isLarge ? ' eq-chip-lg' : ''}" data-collector-name="${c.name}" title="${displayName}: ${c.count} ${energy} ${c.count === 1 ? 'city' : 'cities'} (${c.total} total)" style="background:${pillBg};color:${textColor};border:1px solid rgba(${r},${g},${b},0.3);"
                        onmouseenter="this.style.background='${hoverBg}';this.style.boxShadow='0 4px 16px rgba(${r},${g},${b},0.4)';this.style.borderColor='rgba(${r},${g},${b},0.5)'"
                        onmouseleave="this.style.background='${pillBg}';this.style.boxShadow='none';this.style.borderColor='rgba(${r},${g},${b},0.3)'">
                        <span class="eq-chip-name">${displayName}</span>
                        <span class="eq-chip-count" style="color:${countColor}">${c.count}</span>
                    </div>`;
                }).join('');
            });

            // Update subtitle
            const subtitle = document.getElementById('eqSubtitle');
            if (subtitle) {
                const uniqueNames = new Set();
                ALL_ENERGIES.forEach(e => energyCollectors[e].forEach(c => uniqueNames.add(c.name)));
                const totalCities = Object.values(energyCityTotals).reduce((a, b) => a + b, 0);
                subtitle.textContent = `${uniqueNames.size} collectors Â· ${totalCities} cities across ${ALL_ENERGIES.length} energies`;
            }

            // Energy Set nudge: show how many collectors have completed the full set + mono city sets
            const nudgeEl = document.getElementById('eqNudge');
            if (nudgeEl) {
                const uniqueCollectorMap = {};
                ALL_ENERGIES.forEach(e => energyCollectors[e].forEach(c => {
                    if (!uniqueCollectorMap[c.name]) uniqueCollectorMap[c.name] = {};
                    uniqueCollectorMap[c.name][e] = c.count;
                }));
                const energySetCollectors = [];
                const almostCollectors = [];
                const citySetCollectors = { Rising: [], Living: [], Fading: [], Resting: [] };
                Object.entries(uniqueCollectorMap).forEach(([name, energies]) => {
                    const hasAll = ALL_ENERGIES.every(e => energies[e] > 0);
                    if (hasAll) energySetCollectors.push(name);
                    else {
                        const owned = ALL_ENERGIES.filter(e => energies[e] > 0);
                        if (owned.length === 3) {
                            const missing = ALL_ENERGIES.find(e => !energies[e]);
                            almostCollectors.push({ name, missing });
                        }
                    }
                    ALL_ENERGIES.forEach(e => {
                        if ((energies[e] || 0) >= 4) citySetCollectors[e].push(name);
                    });
                });
                const hasAnySets = energySetCollectors.length > 0 || ALL_ENERGIES.some(e => citySetCollectors[e].length > 0);
                if (hasAnySets) {
                    const citySetIcons = { Rising: 'â˜€ï¸', Living: 'ðŸ™ï¸', Fading: 'ðŸŒ†', Resting: 'ðŸŒƒ' };
                    let nudgeHtml = '<div class="eq-nudge-showcase">';
                    // Energy Set holders (all 4 energies) - shown first and proudest
                    if (energySetCollectors.length > 0) {
                        nudgeHtml += `<div class="eq-nudge-set-row energy-full" onclick="openPerfectSets()">`;
                        nudgeHtml += `<span class="eq-nudge-set-icon">âš¡</span>`;
                        nudgeHtml += `<span class="eq-nudge-set-label">Energy Set</span>`;
                        nudgeHtml += `<span class="eq-nudge-set-names">`;
                        energySetCollectors.forEach(name => {
                            nudgeHtml += `<span class="eq-nudge-set-name" data-collector-name="${name}">${formatCollectorName(name).toUpperCase()}</span>`;
                        });
                        nudgeHtml += `</span>`;
                        nudgeHtml += `</div>`;
                    }
                    // Per-energy set holders
                    ALL_ENERGIES.forEach(e => {
                        const names = citySetCollectors[e];
                        if (names.length > 0) {
                            nudgeHtml += `<div class="eq-nudge-set-row ${e.toLowerCase()}" onclick="openPerfectSets('${e}')">`;
                            nudgeHtml += `<span class="eq-nudge-set-icon">${citySetIcons[e]}</span>`;
                            nudgeHtml += `<span class="eq-nudge-set-label">${e}</span>`;
                            nudgeHtml += `<span class="eq-nudge-set-names">`;
                            names.forEach(name => {
                                nudgeHtml += `<span class="eq-nudge-set-name" data-collector-name="${name}">${formatCollectorName(name).toUpperCase()}</span>`;
                            });
                            nudgeHtml += `</span>`;
                            nudgeHtml += `<span class="eq-nudge-set-count">${names.length}</span>`;
                            nudgeHtml += `</div>`;
                        }
                    });
                    // Almost collectors - subtle, de-emphasized
                    if (almostCollectors.length > 0) {
                        nudgeHtml += `<div class="eq-nudge-almost-row">`;
                        nudgeHtml += `<span class="eq-nudge-almost-tag">${almostCollectors.length} one away</span>`;
                        almostCollectors.forEach(ac => {
                            nudgeHtml += `<span class="eq-nudge-almost-name" data-collector-name="${ac.name}" title="${formatCollectorName(ac.name)} needs ${ac.missing}">${formatCollectorName(ac.name).toUpperCase()} <span class="eq-nudge-almost-miss">Â· ${ac.missing}</span></span>`;
                        });
                        nudgeHtml += `</div>`;
                    }
                    nudgeHtml += '</div>';
                    nudgeEl.innerHTML = nudgeHtml;
                    nudgeEl.classList.add('visible');
                } else {
                    nudgeEl.classList.remove('visible');
                }
            }

            // Add click handlers to chips
            modal.querySelectorAll('.eq-chip').forEach(chip => {
                chip.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const name = chip.dataset.collectorName;
                    const collector = COLLECTORS_DATA.find(c => c.name === name);
                    if (collector && collector.tokens) {
                        closeEnergyQuadrant(true);
                        setTimeout(() => openWallView(collector.name, collector.tokens), 150);
                    }
                });
            });

            // Add click handlers to set name chips and almost-name chips in nudge
            modal.querySelectorAll('.eq-nudge-set-name, .eq-nudge-almost-name').forEach(chip => {
                chip.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const name = chip.dataset.collectorName;
                    const collector = COLLECTORS_DATA.find(c => c.name === name);
                    if (collector && collector.tokens) {
                        closeEnergyQuadrant(true);
                        setTimeout(() => openWallView(collector.name, collector.tokens), 150);
                    }
                });
            });

            modal.classList.add('open');
            document.body.style.overflow = 'hidden';
        }

        function closeEnergyQuadrant(navigatingAway) {
            const modal = document.getElementById('energyQuadrantModal');
            if (modal) modal.classList.remove('open');
            document.body.style.overflow = '';
            // Return to collectors panel unless we're navigating to another view
            if (!navigatingAway) {
                openCollectorsPanel();
            }
        }

        // Trigger button with boost launch animation (global so onclick fallback works)
        window.launchEnergyQuadrant = function() {
            const btn = document.getElementById('energyQuadrantBtn');
            if (!btn || btn.classList.contains('launching')) return;
            btn.classList.add('launching');
            // Open the modal partway through the animation
            setTimeout(() => {
                try {
                    openEnergyQuadrant();
                } catch(e) {
                    console.error('Energy quadrant error:', e);
                }
                // Reset button state after animation completes (always runs)
                setTimeout(() => {
                    btn.classList.remove('launching');
                }, 400);
            }, 350);
        };
        document.getElementById('energyQuadrantBtn')?.addEventListener('click', (e) => {
            e.stopPropagation();
            launchEnergyQuadrant();
        });

        // Dream grid button in collectors header
        document.getElementById('dreamGridBtn')?.addEventListener('click', (e) => {
            e.stopPropagation();
            if (typeof openDreamGrid === 'function') openDreamGrid();
        });

        // Close on backdrop click (outside the container)
        document.getElementById('energyQuadrantModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'energyQuadrantModal') closeEnergyQuadrant();
        });

        // Close on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('energyQuadrantModal')?.classList.contains('open')) {
                closeEnergyQuadrant();
            }
        });

        // ========== PERFECT SETS VIEW ==========
        function openPerfectSets(scrollToEnergy) {
            const modal = document.getElementById('perfectSetsModal');
            const body = document.getElementById('perfectSetsBody');
            const subtitle = document.getElementById('perfectSetsSubtitle');
            if (!modal || !body || !COLLECTORS_DATA || COLLECTORS_DATA.length === 0) return;

            // Close energy quadrant first (navigating away, don't reopen collectors)
            closeEnergyQuadrant(true);

            // Build collector -> energy -> token list mapping
            const collectorEnergies = {};
            COLLECTORS_DATA.forEach(collector => {
                if (!collector.tokens || collector.tokens.length === 0) return;
                const energyTokens = { Rising: [], Living: [], Fading: [], Resting: [] };
                collector.tokens.forEach(tokenId => {
                    const traits = tokenTraits[tokenId];
                    if (traits && traits['Energy'] && energyTokens.hasOwnProperty(traits['Energy'])) {
                        energyTokens[traits['Energy']].push(tokenId);
                    }
                });
                ALL_ENERGIES.forEach(energy => {
                    if (energyTokens[energy].length >= 4) {
                        if (!collectorEnergies[energy]) collectorEnergies[energy] = [];
                        collectorEnergies[energy].push({
                            name: collector.name,
                            tokens: energyTokens[energy],
                            totalOwned: collector.count
                        });
                    }
                });
            });

            // Sort collectors within each energy by token count descending
            ALL_ENERGIES.forEach(energy => {
                if (collectorEnergies[energy]) {
                    collectorEnergies[energy].sort((a, b) => b.tokens.length - a.tokens.length);
                }
            });

            const energyIcons = { Rising: '&#9728;', Living: '&#128694;', Fading: '&#9925;', Resting: '&#127769;' };
            const energyEmoji = { Rising: '\u2600\uFE0F', Living: '\uD83C\uDFD9\uFE0F', Fading: '\uD83C\uDF06', Resting: '\uD83C\uDF03' };
            let totalSets = 0;
            let html = '';

            ALL_ENERGIES.forEach(energy => {
                const sets = collectorEnergies[energy] || [];
                totalSets += sets.length;
                const sectionId = 'perfectSetsSection' + energy;

                html += `<div class="perfect-sets-section ps-section-${energy.toLowerCase()}" id="${sectionId}">`;
                html += `<div class="perfect-sets-section-header">`;
                html += `<span class="perfect-sets-section-icon">${energyEmoji[energy]}</span>`;
                html += `<span class="perfect-sets-section-name">${energy} City Sets</span>`;
                html += `<span class="perfect-sets-section-count">${sets.length} set${sets.length !== 1 ? 's' : ''}</span>`;
                html += `</div>`;

                if (sets.length === 0) {
                    html += `<div class="perfect-set-empty">No collectors have 4+ ${energy} cities yet</div>`;
                } else {
                    html += `<div class="perfect-sets-grid">`;
                    sets.forEach(set => {
                        const displayName = formatCollectorName(set.name).toUpperCase();
                        // Take first 4 tokens for the quad display
                        const quadTokens = set.tokens.slice(0, 4);
                        html += `<div class="perfect-set-card">`;
                        html += `<div class="perfect-set-card-header">`;
                        html += `<span class="perfect-set-collector" data-collector-name="${set.name}" title="View ${displayName}'s wall">${displayName}</span>`;
                        html += `<span class="perfect-set-count">${set.tokens.length} cities</span>`;
                        html += `</div>`;
                        html += `<div class="perfect-set-quad">`;
                        quadTokens.forEach(tokenId => {
                            html += `<div class="perfect-set-cell" data-token-id="${tokenId}" title="Output #${tokenId}" style="cursor:pointer">`;
                            html += `<img src="${getSmallThumbnailUrl(tokenId)}" alt="#${tokenId}" loading="lazy">`;
                            html += `<span class="perfect-set-cell-id">#${tokenId}</span>`;
                            html += `</div>`;
                        });
                        html += `</div>`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                }
                html += `</div>`;
            });

            body.innerHTML = html;
            if (subtitle) {
                subtitle.textContent = `${totalSets} perfect set${totalSets !== 1 ? 's' : ''} across all energies`;
            }

            // Add click handlers for collector names
            body.querySelectorAll('.perfect-set-collector').forEach(el => {
                el.addEventListener('click', () => {
                    const name = el.dataset.collectorName;
                    const collector = COLLECTORS_DATA.find(c => c.name === name);
                    if (collector) {
                        closePerfectSets(true);
                        setTimeout(() => openWallView(collector.name, collector.tokens), 150);
                    }
                });
            });

            // Add click handlers for individual city cells
            body.querySelectorAll('.perfect-set-cell').forEach(el => {
                el.addEventListener('click', () => {
                    const tokenId = parseInt(el.dataset.tokenId);
                    if (!isNaN(tokenId)) {
                        closePerfectSets(true);
                        setTimeout(() => loadOutput(tokenId, true), 150);
                    }
                });
            });

            modal.classList.add('open');
            document.body.style.overflow = 'hidden';

            // Scroll to the requested energy section
            if (scrollToEnergy) {
                setTimeout(() => {
                    const section = document.getElementById('perfectSetsSection' + scrollToEnergy);
                    if (section) section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }
        }

        function closePerfectSets(navigatingAway) {
            const modal = document.getElementById('perfectSetsModal');
            if (modal) modal.classList.remove('open');
            document.body.style.overflow = '';
            // Return to energy quadrant unless navigating to a specific view
            if (!navigatingAway) {
                openEnergyQuadrant();
            }
        }

        // Close Perfect Sets on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('perfectSetsModal')?.classList.contains('open')) {
                closePerfectSets();
            }
        });

    </script>

    <a href="https://shop.efdotstudio.com/collections/cities-collection/Cities" target="_blank" title="Shop Cities Prints"><img src="ef-logo.png" alt="Efdot" class="efdot-shop-fixed"></a>

    <!-- Drift Mode - Meditative Gallery -->
    <div class="drift-mode dark" id="driftMode">
        <button class="drift-close" id="driftClose">&times;</button>
        <button class="drift-toggle" id="driftToggle">Light</button>
        <div class="drift-hint">click a city to view Â· move cursor right to speed up Â· esc to exit</div>
        <div class="drift-track" id="driftTrack"></div>
    </div>
</body>
</html>
